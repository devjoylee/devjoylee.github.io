{"componentChunkName":"component---src-templates-post-jsx","path":"/node-tutorial-04/","result":{"data":{"site":{"siteMetadata":{"title":"joy.blog"}},"markdownRemark":{"id":"e278a06a-ce12-5b31-bd4c-1745944b77b6","excerpt":"🅰 서버 기반 인증 시스템 (Session / Cookie) 서버 기반 인증 시스템은 로그인 시 세션 ID를 클라이언트에게 발급해주고 클라이언트는 요청 시마다 세션 ID가 담긴 쿠키를 헤더에 담아 보내는 방식이다. 상태를 유지해야 하므로 Stateful한 구조를 가지고 있다. 인증방식 사용자가 로그인하면 올바른 사용자임을 확인하고 고유한 세션 ID 값을 …","html":"<h2>🅰 서버 기반 인증 시스템 (Session / Cookie)</h2>\n<p>서버 기반 인증 시스템은 로그인 시 <strong>세션 ID를 클라이언트에게 발급</strong>해주고 클라이언트는 요청 시마다 <strong>세션 ID가 담긴 쿠키를 헤더에 담아</strong> 보내는 방식이다. 상태를 유지해야 하므로 Stateful한 구조를 가지고 있다.</p>\n<h3>인증방식</h3>\n<ol>\n<li>사용자가 로그인하면 올바른 사용자임을 확인하고 고유한 세션 ID 값을 생성한다.</li>\n<li>생성된 ID 값은 세션 저장소에 저장 후 클라이언트에게 발급해준다.</li>\n<li>클라이언트는 세션 ID를 받아 쿠키에 저장하고, 인증이 필요한 요청마다 쿠키에 세션 ID를 담아 헤더에 실어 보낸다.</li>\n<li>서버에서는 쿠키를 받아 세션 저장소와 비교해 올바른 요청인지 확인한다.</li>\n<li>인증이 완료되고 서버는 요청에 응답한다.</li>\n</ol>\n<h3>장점</h3>\n<p>중요한 정보는 서버에 있기 때문에 쿠키 자체(세션 ID)는 유의미한 값을 가지고 있지 않다.</p>\n<h3>단점</h3>\n<ul>\n<li>쿠키값 자체가 의미가 없다는 것은 안전해 보일 수 있으나, 해커가 훔친 쿠키를 이용해 HTTP 요청을 보내면 서버에서는 올바른 사용자가 보낸 요청인지 알 수 없다.(세션 하이재킹 공격)\n→ 세션에 유효시간을 넣어줘야 한다. / B 방식도 마찬가지.</li>\n<li>세션을 저장해야 하므로 사용자가 늘어날 경우 서버의 RAM에 부하가 걸리게 된다. 이를 피하기 위해 데이터베이스에 저장하기도 하는데 이 역시 데이터베이스에 부하를 줄 수 있다.</li>\n<li>시스템 확장이 어렵다. 단순한 사양 업그레이드가 아닌 더 많은 트래픽을 감당하기 위해 여러 프로세스를 돌리거나, 여러 대의 서버 컴퓨터를 추가하는 것을 의미한다.</li>\n</ul>\n<h2>🅱 토큰 기반 인증 시스템(JWT)</h2>\n<p>토큰 기반 인증 시스템은 로그인 시 토큰을 발급해주고, 서버에 요청을 할 때 HTTP 헤더에 토큰을 함께 보내도록 하여 유효성 검사를 하는 방식이다. 사용자의 인증 정보를 더 이상 서버에 저장하지 않고 클라이언트의 요청으로만 인가를 처리할 수 있으므로 Stateless 한 구조를 가진다.</p>\n<p>JWT는 <strong>Json Web Token</strong>의 약자로 <strong>인증에 필요한 정보를 암호화시킨 토큰</strong>을 뜻한다.</p>\n<p>세션/쿠키 방식과 유사하게 클라이언트는 <strong>Access Token(JWT)을 HTTP 헤더</strong>에 실어 서버로 보낸다. A 방식과 가장 큰 차이점은 세션 저장소에 유저의 정보를 넣는 반면에 B 방식은 토큰 안에 유저의 정보를 넣는다는 점이다. 서버 측에서는 인증을 위해 암호화를 하느냐, 별도의 저장소를 이용하냐는 차이가 발생한다.</p>\n<h3>인증방식</h3>\n<ol>\n<li>사용자가 로그인 시 올바른 사용자임을 확인하고, 클라이언트에게 Access Token(JWT)을 발급해준다.</li>\n<li>클라이언트는 전달받은 토큰을 저장해 두고, 인증이 필요한 요청마다 토큰을 HTTP 헤더에 담아 보낸다.</li>\n<li>서버에서는 암호화된 토큰을 복호화 해 올바른 요청인지 확인한다.</li>\n<li>인증이 완료되고 서버는 요청에 응답한다.</li>\n</ol>\n<h3>장점</h3>\n<ul>\n<li>간편하다. A 방식은 저장소의 관리가 필요하지만 Access Token을 발급해준 후 요청이 들어오면 검증만 해주면 되기 때문에 추가 저장소가 필요 없다. 즉 Stateless 하다.</li>\n<li>쿠키를 사용함으로 인해 발생하는 취약점이 사라진다. 하지만, 토큰을 사용하는 환경에서의 취약점에 대비해야 한다.</li>\n<li>확장성이 뛰어나다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다. Ex) facebook, Google..</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>이미 발급된 JWT를 돌이킬 수 없다. A 방식처럼 세션 저장소를 사용하는 경우에는 해당 세션이 악의적으로 사용될 경우 지워버리면 되지만, JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능하다. 즉 유효기간이 지나기 전까지 실컷 털릴 수 있다</li>\n<li>JWT의 길이가 길다. 인증이 필요한 요청이 많아질수록 서버의 자원 낭비가 발생한다.</li>\n</ul>\n<h2>결론</h2>\n<p>서버 기반 인증 방식은 과거에 사용하던 방식이다. 서버 기반 인증 방식을 대체하기 위하여 등장한 것이 토큰 기반 인증 방식이지만 토큰을 사용한다고 해서 무조건 해킹의 위험에서 벗어난 것이 아니다.</p>\n<!--\n## 🔎 모듈 이란?\n\n노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와 다릅니다. 모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있습니다. 자바스크립트에서 코드를 재사용하기 위해 함수로 만드는 것과 비슷하며 노드에서는 보통 파일 하나가 모듈 하나가 됩니다. 파일별로 코드를 모듈화할 수 있어 관리하기 편합니다.\n\n> 모듈 : 특정한 기능을 하는 함수나 변수들의 집합\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183278114-3116e3ab-b132-4086-b009-36462369999e.jpg\" width=\"450\" />\n\n3-3 ~ 3-6\n3-7 ~ 3-11 -->\n<p><br /><br /><br /></p>\n<blockquote>\n<p>REFERENCE <br /> 쉽게 알아보는 서버 인증 1편 - <a href=\"https://tansfil.tistory.com/58?category=255594\">https://tansfil.tistory.com/58?category=255594</a><br />[JWT] 토큰(Token) 기반 인증에 대한 소개 - velopert.com/2350</p>\n</blockquote>","frontmatter":{"title":"[Node] Server Authentication (Session vs JWT)","date":"November 25, 2022","update":"November 25, 2022","tags":["nodejs"],"series":"NodeJS"},"fields":{"slug":"/node-tutorial-04/","readingTime":{"minutes":7.45}}},"seriesList":{"edges":[{"node":{"id":"8a9a5d98-bf45-5a21-bd44-2487569b5f3e","fields":{"slug":"/node-tutorial-01/"},"frontmatter":{"title":"[Node] 서버와 런타임 개념 이해하기"}}},{"node":{"id":"9b57e35f-18e7-5638-b11d-aa3e963ffad8","fields":{"slug":"/node-tutorial-02/"},"frontmatter":{"title":"[Node] 호출스택과 이벤트 루프"}}},{"node":{"id":"94b2f32d-e349-5890-8d55-82c1dbc82daa","fields":{"slug":"/node-tutorial-03/"},"frontmatter":{"title":"[Node] 노드의 주요 특성 Non Blocking / Single Thread"}}},{"node":{"id":"e278a06a-ce12-5b31-bd4c-1745944b77b6","fields":{"slug":"/node-tutorial-04/"},"frontmatter":{"title":"[Node] Server Authentication (Session vs JWT)"}}}]},"previous":{"fields":{"slug":"/next-tutorial-03/"},"frontmatter":{"title":"Next-Auth로 Google 로그인 기능 구현"}},"next":{"fields":{"slug":"/next-tutorial-04/"},"frontmatter":{"title":"Next-Auth + MongoDB 로그인 유저값 저장하기"}}},"pageContext":{"id":"e278a06a-ce12-5b31-bd4c-1745944b77b6","series":"NodeJS","previousPostId":"55916079-cb63-5ed7-abfd-dcd7616c3159","nextPostId":"6c343ba9-3d2f-5509-814a-5775fe4b6022"}},"staticQueryHashes":[]}
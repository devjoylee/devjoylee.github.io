{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"💡 Redux란? Redux란 '상태 관리 라이브러리'로써 기존에 흩어져 있는 state들을 한 곳에 모아 관리하여 예측 불가능한 버그를 최소화하고 효율적으로 state를 사용할 수 있도록 합니다. 또한 Redux는 React 외에도 Angular, Vue, jQuery 등 다양한 환경에서 사용할 수 있습니다. why-using-redux 에서의 상태관리…","fields":{"slug":"/redux-about/"},"frontmatter":{"date":"February 20, 2022","title":"Redux - 상태 관리 라이브러리","tags":["react","redux"]},"rawMarkdownBody":"\r\n## 💡 Redux란?\r\n\r\nRedux란 '상태 관리 라이브러리'로써 기존에 흩어져 있는 state들을 한 곳에 모아 관리하여 예측 불가능한 버그를 최소화하고 효율적으로 state를 사용할 수 있도록 합니다. 또한 Redux는 React 외에도 Angular, Vue, jQuery 등 다양한 환경에서 사용할 수 있습니다.\r\n\r\n![why-using-redux](https://user-images.githubusercontent.com/68415905/157664466-dffebac5-4ead-438f-895b-dd53e3b01b70.jpg)\r\n\r\n- `React`에서의 상태관리\r\n\r\nReact에서의 상태는 `props`를 통해 각 컴포넌트로 전달됩니다. 특정 컴포넌트에서 state가 변화하면 `props`로 연결된 모든 컴포넌트가 함께 업데이트 됩니다.\r\n\r\n- `Redux`에서의 상태관리\r\n\r\nRedux에서의 상태는 컴포넌트끼리 공유하지 않고 `store`라는 파일을 거쳐 필요한 컴포넌트로 즉시 전달됩니다. `store`는 앱에서 사용되는 모든 state를 저장하고 관리하는 장소입니다.\r\n\r\n## 📝 Redux의 3원칙\r\n\r\n- 애플리케이션 상태는 모두 한 곳에서 집중 관리됩니다. (동기화 필요 ✘)\r\n- 상태는 불변(읽기 전용) 데이터 이며, 오직 액션 만이 상태 교체를 요청 할 수 있습니다. (예측 가능)\r\n- 리듀서(함수)를 통해 상태의 최종 값만 설정합니다. (단순화)\r\n\r\n## 🔀 Redux 설치\r\n\r\n```bash\r\nnpm install redux react-redux\r\n```\r\n\r\n## 🧐 Redux의 상태 생성하기\r\n\r\n```bash\r\nredux/\r\n├── actions/\r\n│   ├── index.js # 액션 내보내기(export) 파일\r\n│   ├── actionTypes.js # 액션 타입 (액션 타입: 상수)\r\n│   ├── auth.js\r\n│   └── counter.js\r\n├── reducers/\r\n│   ├── index.js # 리듀서 엔트리 ([루트 리듀서:병합] 내보내기)\r\n│   ├── auth.js\r\n│   └── counter.js\r\n└── store.js # 스토어 엔트리 (스토어 생성 ← 루트 리듀서)\r\n```\r\n\r\n### 1. action type 지정\r\n\r\n### 2. reducer 함수 추가\r\n\r\n리듀서는 상태(state)와 액션(action)을 전달 받아 '현재 상태'를 '새로운 상태'로 교체 한 후 반환합니다.\r\n\r\n```jsx\r\nconst initialState = 0;\r\nconst reducer = (state = initialState, action) {\r\n  switch(action.type) {\r\n    case INCREASE_COUNT:\r\n      return state + 1\r\n    case DECREASE_COUNT:\r\n      return state - 1\r\n    default:\r\n      return state\r\n  }\r\n}\r\n```\r\n\r\n### 3. store 만들기\r\n\r\n```jsx\r\nimport { createStore } from \"redux\"\r\n\r\n// Redux 스토어 생성\r\n// - 리듀서 함수를 전달 받음\r\nconst store = createStore(reducer)\r\n```\r\n\r\n## 🧐 Redux의 상태 전달하기\r\n\r\n### Provider\r\n\r\n### useSelector\r\n\r\n### useDispatch\r\n"},{"excerpt":"☝ 프로젝트 시작하기 전 이번 프로젝트부터는 javascript가 아닌 typescript를 사용하기로 했다. 타입스크립트가 적용된 CRA를 내려받고 절대경로(ex ) 설정도 해두었다.  타입스크립트 절대경로 설정 (tsconfig.json) 📌 프로젝트 링크 Github\n배포링크 📑 견적서 게시판 제작 1. json-server로 REST-API 요청 …","fields":{"slug":"/estimate-board/"},"frontmatter":{"date":"February 10, 2022","title":"견적서 게시판 (필터링 기능)","tags":["wanted","typescript","react","heroku"]},"rawMarkdownBody":"\r\n## ☝ 프로젝트 시작하기 전\r\n\r\n이번 프로젝트부터는 javascript가 아닌 typescript를 사용하기로 했다. 타입스크립트가 적용된 CRA를 내려받고 절대경로(ex `components/Filter`) 설정도 해두었다.\r\n\r\n`npx create-react-app [project-name] --template typescript`\r\n\r\n- 타입스크립트 절대경로 설정 (**tsconfig.json**)\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    // etc..\r\n    \"baseUrl\": \"src\"\r\n  },\r\n  \"include\": [\"src\"]\r\n}\r\n```\r\n\r\n## 📌 프로젝트 링크\r\n\r\n[Github](https://github.com/devjoylee/estimate-board)\r\n[배포링크](https://estimate-board-page.herokuapp.com/)\r\n\r\n## 📑 견적서 게시판 제작\r\n\r\n### 1. json-server로 REST-API 요청\r\n\r\njson-server로 가상의 서버를 만들어 REST-API 요청을 보내고 서버에 저장된 데이터베이스로 부터 필요한 데이터를 가져올 수 있도록 만들었다.\r\n\r\n> REST-API란? <br/>\r\n> url과 method를 사용해 HTTP 기반으로 클라이언트가 서버로 CRUD를 요청하는 것<br/>\r\n> ▪ Create : POST => 새로운 데이터 생성<br/>\r\n> ▪ Read : GET => 데이터 불러오기<br/>\r\n> ▪ Update : PUT => 데이터 수정<br/>\r\n> ▪ Delete : DELETE => 데이터 삭제<br/>\r\n\r\n먼저 json-server를 설치하고 프로젝트 최상단에 `server` 폴더를 생성했다.\r\n\r\n```bash\r\nnpm install json-server\r\n```\r\n\r\n그리고 server를 생성하는 명령어 파일(index.js)을 추가한 후 데이터가 저장된 db.json 파일을 만들었다. 저장한 데이터를 가져오기 위해서는 서버 url로 GET 요청을 보내야 한다. <br/>(요청 url - localhost:3001/requests)\r\n\r\n```json\r\n// db.json\r\n{\r\n  \"requests\": [\r\n    {\r\n      \"id\": 1,\r\n      \"title\": \"자동차 시제품 제작\",\r\n      \"client\": \"A 고객사\",\r\n      \"due\": \"2020.12.14\",\r\n      \"count\": 2,\r\n      \"amount\": 100,\r\n      \"method\": [\"밀링\", \"선반\"],\r\n      \"material\": [\"알루미늄\"],\r\n      \"status\": \"대기중\"\r\n    }\r\n    // ...\r\n  ]\r\n}\r\n```\r\n\r\n```js\r\n// index.js\r\nconst jsonServer = require(\"json-server\")\r\nconst path = require(\"path\")\r\n\r\nconst server = jsonServer.create()\r\nconst router = jsonServer.router(path.resolve(__dirname + \"/db.json\"))\r\nconst middlewares = jsonServer.defaults({\r\n  static: path.resolve(__dirname + \"/../build/\"),\r\n})\r\n\r\nconst port = process.env.PORT || 3001\r\n\r\nserver.use(middlewares)\r\n\r\nserver.use(jsonServer.bodyParser)\r\n\r\nserver.use(router)\r\nserver.listen(port, () => {\r\n  console.log(\"JSON Server is running\")\r\n})\r\n```\r\n\r\nserver로 보내는 GET 요청은 fetch 함수를 사용한다. useEffect를 사용해서 렌더링 시 데이터를 요청하고 불러온 데이터는 state에 저장하도록 설계했다.\r\n\r\n```jsx\r\nconst [apiData, setApiData] = useState<Estimate[]>([]);\r\n\r\nuseEffect(() => {\r\n  const fetchData = async () => {\r\n    const data = await fetch(\"/requests\")\r\n    setApiData(await data.json())\r\n  }\r\n  fetchData()\r\n}, [])\r\n```\r\n\r\nGET 요청 성공 여부를 알고 싶다면 브라우저 네트워크 탭을 확인하면 된다.\r\n\r\n![get](https://user-images.githubusercontent.com/68415905/156305269-37019cd0-fc20-4442-b98b-25cf1883295d.JPG)\r\n\r\n### 2. 필터링 기능 구현\r\n\r\n이번 프로젝트에서 필요한 필터링 기능은 총 2가지 이다. 각 기능은 서로 다른 방식으로 구현을 해보기로 했다.\r\n\r\n1. select 박스 형태의 카테고리 선택에 따라 해당 카테고리 내역만 출력<br/>\r\n   👉 `filter`와 `include()` method를 사용해서 구현\r\n2. 토글 버튼 클릭 시, '상담 중' 라벨이 붙어있는 내역만 출력<br/>\r\n   👉 className를 각각 부여하고 토글버튼 클릭 시 `display:block` or `none` 처리\r\n\r\n![image](https://user-images.githubusercontent.com/68415905/156330421-4364ff3e-a37e-41e3-b28f-bb22abd1466d.jpg)\r\n\r\n### - 카테고리 필터링\r\n\r\n먼저 카테고리 필터링은 util 함수를 따로 작성하였다. `filterData`라는 이 함수는 서버에서 받아온 API 데이터와 category에서 선택된 옵션을 비교하여 선택된 옵션과 모두 일치하는 item만 데이터에서 필터링시켜 출력하도록 구현했다.\r\n\r\n```jsx\r\n// filterData.ts\r\nimport { Estimate, Category } from \"types\"\r\n\r\nexport const filterData = (apiData: Estimate[], categories: Category) => {\r\n  const filtered = apiData.filter((item: Estimate) => {\r\n    // '재료' 카테고리에서 선택된 옵션과 모두 일치하면 true\r\n    const materials = categories.material.every((option: string) =>\r\n      item.material.includes(option)\r\n    )\r\n    // '가공방식' 카테고리에서 선택된 옵션과 모두 일치하면 true\r\n    const methods = categories.method.every((option: string) =>\r\n      item.method.includes(option)\r\n    )\r\n    // 두 조건에 모두 부합하는 item만 필터링하여 출력\r\n    return materials && methods\r\n  })\r\n  return filtered\r\n}\r\n```\r\n\r\n이때, 선택된 카테고리는 `categories`라는 state를 만들어 관리했다. 받아온 api데이터와 categories 목록을 `filterData` 함수의 인자로 넘겨주면 필터링된 새로운 데이터를 반환한다.\r\n필터링 데이터는 컴포넌트로 넘겨주어 `map`으로 각 아이템을 출력하게 했다.\r\n\r\nuseMemo를 사용하기 전 데이터를 state에 저장할지 useMemo로 메모리에 저장해둘지 고민을 많이 했는데 어떤 방식이 더 좋은지는 아직 잘 모르겠다. state에 저장을 하면 렌더링마다 같은 필터링이 반복되고, useMemo에 저장을 하면 추가적으로 메모리를 소비하는데 어떤게 더 좋은 선택일지는 차차 고민해보도록 해야겠다.\r\n\r\n```jsx\r\n// mainPage.ts\r\nconst [categories, setCategories] = useState({\r\n  method: [],\r\n  material: [],\r\n})\r\nconst filteredList = useMemo(() => {\r\n  return filterData(apiData, categories)\r\n}, [apiData, categories])\r\nreturn (\r\n  // 카테고리 컴포넌트 (옵션 선택 시 state 업데이트)\r\n  <FilterList categories={categories} setCategories={setCategories} />\r\n  // map으로 list를 순회하며 각 아이템을 출력하는 컴포넌트\r\n  <EstimateList list={filteredList} isChecked={isChecked} />\r\n)\r\n```\r\n\r\n### - 토글 필터링\r\n\r\n토글 필터링은 조금 간단한 방식을 사용했다. 먼저 `isChecked`라는 state를 만들어 토글이 on/off 되었을 때를 관리하도록 했다.\r\n\r\n```jsx\r\nconst [isChecked, setIsChecked] = useState(false)\r\nconst handleClick = () => {\r\n  setIsChecked(!isChecked)\r\n}\r\nreturn (\r\n  // ..\r\n  <Toggle isChecked={isChecked} handleClick={handleClick} />\r\n)\r\n```\r\n\r\n그리고 데이터 정보에 따라 status가 상담중이면 `active`, 대기중이면 `pending` 이라는 클래스명을 부여하고 토글이 켜진 경우(`isChecked`가 참인 경우) 상담중(`active`) 아이템만 display:block 시키고 나머지는 모두 display:none 하도록 설계했다.\r\n\r\n```jsx\r\n// EstimateItem.tsx\r\ninterface StyleProps {\r\n  isChecked: boolean;\r\n}\r\n\r\nexport const EstimateItem = ({ isChecked }: EstimateItemProps) => {\r\n  return (\r\n    <EstimateItemContainer\r\n      className={status === '상담중' ? 'active' : 'pending'}\r\n      isChecked={isChecked}\r\n    >\r\n    // ...\r\n    </EstimateItemContainer>\r\n  );\r\n}};\r\n\r\nconst EstimateItemContainer = styled.li<StyleProps>`\r\n  &.pending {\r\n    display: ${({ isChecked }) => (isChecked ? 'none' : 'block')};\r\n  }\r\n`;\r\n```\r\n\r\n<br/>\r\n\r\n- 🔎 필터링 구현 영상\r\n\r\n![gif](https://user-images.githubusercontent.com/68415905/156321675-9bc7f32d-0c7e-4cde-b0da-bb9daa8a132a.gif)\r\n\r\n## ♻ 프로젝트 리팩토링\r\n\r\n### 필터 기능 수정\r\n\r\n사실 이번 프로젝트에서 내가 맡은 부분은 필터 기능 구현이 아닌 UI 컴포넌트 설계과 토글 기능 구현 담당이었다. 그래서 필터링 부분에 대해서는 프로젝트가 끝난 후 다른 팀원이 작성한 필터링 코드를 보며 개선할 부분을 생각해보고 추가적으로 학습하였다.\r\n\r\n- 리팩토링 전\r\n\r\n```jsx\r\nimport { Estimate } from \"types/card\"\r\nimport { Category } from \"types/category\"\r\n\r\nexport const getFilter = (apiData: Estimate[], categories: Category) => {\r\n  const newData = []\r\n  for (let i = 0; i < apiData.length; i++) {\r\n    const methodFiltered = apiData[i].method.filter((data: string) =>\r\n      categories.method.includes(data)\r\n    )\r\n    const materialFiltered = apiData[i].material.filter((data: string) =>\r\n      categories.material.includes(data)\r\n    )\r\n    if (\r\n      methodFiltered.length >= categories.method.length &&\r\n      materialFiltered.length >= categories.material.length\r\n    ) {\r\n      newData.push(apiData[i])\r\n    }\r\n  }\r\n  return newData\r\n}\r\n```\r\n\r\n위 코드에서 리팩토링한 항목은 아래와 같다.\r\n\r\n1. type이 불필요하게 2군데로 나누어져 있음\r\n   👉 type 파일 1개로 합치기\r\n\r\n2. filter method도 배열을 반환하는데 별도로 배열 변수를 추가해서 push함\r\n\r\n   👉 추가로 할당된 배열을 없애고 filter된 배열 자체를 return하도록 수정\r\n\r\n3. for loop내부에서 filter를 써서 시간복잡도 발생\r\n\r\n   👉 2번에서 배열을 삭제함으로써 for loop 필요 없어짐\r\n\r\n4. 함수명을 getFilter에서 filterData 변경 (좀 더 명시적으로)\r\n\r\n<br/>\r\n\r\n- 리팩토링 후\r\n\r\n```jsx\r\nimport { Estimate, Category } from \"types\"\r\n\r\nexport const filterData = (apiData: Estimate[], categories: Category) => {\r\n  const filtered = apiData.filter((item: Estimate) => {\r\n    // '재료' 카테고리에서 선택된 옵션과 모두 일치하면 true\r\n    const materials = categories.material.every((option: string) =>\r\n      item.material.includes(option)\r\n    )\r\n    // '가공방식' 카테고리에서 선택된 옵션과 모두 일치하면 true\r\n    const methods = categories.method.every((option: string) =>\r\n      item.method.includes(option)\r\n    )\r\n    // 두 조건에 모두 부합하는 item만 필터링하여 출력\r\n    return materials && methods\r\n  })\r\n  return filtered\r\n}\r\n```\r\n\r\n### 옵션명 유틸 함수 추가\r\n\r\n아이템별로 `[밀링], [밀링,선반], [선반]...` 과 같이 옵션이 다 달랐는데 데이터가 가진 옵션을 분석하여 동적으로 카테고리 옵션을 만들어주었다.\r\n\r\n1. `.flat()` method로 데이터가 가진 옵션명 모두 합치기\r\n\r\n   ex) `[밀링], [밀링,선반], [선반]` ➡ `[밀링, 밀링, 선반, 선반]`\r\n\r\n2. `Set`을 사용하여 중복 제거\r\n\r\n   ex) `[밀링, 밀링, 선반, 선반]` ➡ `[밀링, 선반]`\r\n\r\n하지만 기존에는 두가지 옵션(material,method)을 각각 따로 `flat`처리하고 다른 state로 관리해서 코드의 가독성이 떨어졌다. 그래서 `getOptionList`라는 유틸함수를 만들어 코드의 가독성을 높이고 state도 1개로 통일시켜 재사용성을 높였다.\r\n\r\n<br/>\r\n\r\n- 리팩토링 전\r\n\r\n```jsx\r\nconst methodArr = apiData.map(data => data.method).flat(Infinity);\r\nconst materialArr = apiData.map(data => data.material).flat(Infinity);\r\nconst methodSet = Array.from(new Set(methodArr));\r\nconst materialSet = Array.from(new Set(materialArr));\r\nconst [selectMethod, setSelectMethod] = useState<string[]>([]);\r\nconst [selectMaterial, setSelectMaterial] = useState<string[]>([]);\r\nconst [isMethodOpen, setIsMethodOpen] = useState(false);\r\nconst [isMaterialOpen, setIsMaterialOpen] = useState(false);\r\n```\r\n\r\n- 리팩토링 후\r\n\r\n```js\r\nconst optionName = name === '가공방식' ? 'method' : 'material';\r\nconst optionList = getOptionList(apiData, optionName);\r\nconst [select, setSelect] = useState<string[]>([]);\r\nconst [isOpen, setIsOpen] = useState(false);\r\n```\r\n\r\n```js\r\n// getOptionList.ts\r\nimport { Estimate } from \"types\"\r\n\r\nexport const getOptionList = (\r\n  apiData: Estimate[],\r\n  option: \"method\" | \"material\"\r\n) => {\r\n  const list = apiData.map(data => data[option]).flat(1)\r\n  return Array.from(new Set(list))\r\n}\r\n```\r\n"},{"excerpt":"☝ 프로젝트 시작하기 전 이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다. no…","fields":{"slug":"/admin-registry/"},"frontmatter":{"date":"January 31, 2022","title":"어드민 페이지 (이미지 첨부 기능 / useForm)","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\r\n## ☝ 프로젝트 시작하기 전\r\n\r\n이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다.\r\n\r\n![none](https://user-images.githubusercontent.com/68415905/154843327-bd704dff-8fd1-40fd-a59c-ad9473b74690.jpg)\r\n\r\n## 📌 프로젝트 링크\r\n\r\n[Github](https://github.com/devjoylee/admin-product-registry)\r\n[배포링크](https://wanted-admin-product.netlify.app/)\r\n\r\n## 🧾 상품 등록 페이지\r\n\r\n### 이미지 첨부 기능 `input▫type=\"file\"`\r\n\r\n상품 썸네일은 **최대 1개,** 상품 대표 이미지는 **여러개** 첨부 가능하도록 기능 구현.\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154844537-f04a2902-3194-478e-80b4-772e8f32539b.png)\r\n\r\n- 파일 업로드 버튼 custom 하기 : **input**의 `id`와 **label**의 `htmlFor`에 같은 id를 입력한 후 input은 `display:none` 해주고 `label` 스타일링.\r\n\r\n- 이미지 파일만 첨부 가능하게 : `accept=\"image/*\"` 또는 `accept=\"image/png\"`\r\n- 파일 중복 선택 `multiple`\r\n\r\n```jsx\r\n// ImageUpload.js\r\n<input\r\n  id={id}\r\n  type=\"file\"\r\n  accept=\"image/*\"\r\n  style={{ display: 'none' }}\r\n  multiple={!(id === 'thumbnail')}\r\n/>\r\n<label htmlFor={id}>\r\n  <RiAddLine />\r\n  이미지 첨부\r\n</label >\r\n```\r\n\r\n```jsx\r\n// Page.js\r\n<ImageUpload id=\"thumbnail\" />\r\n<ImageUpload id=\"main-img\" />\r\n\r\n```\r\n\r\n---\r\n\r\n### 업로드한 이미지 정보 가져오기 `e.target.files`\r\n\r\n- 이미지가 1개 인경우 `e.target.files[0]` 으로 첫번째 파일 정보를 바로 가져온다\r\n\r\n  ex) `e.target.files[0].name`\r\n\r\n![Untitled (1)](https://user-images.githubusercontent.com/68415905/154844914-ba2629f7-f07c-43f5-9dc3-6ed2b477bcd8.png)\r\n\r\n- 이미지가 여러개인 경우 `Array.from(e.target.files).map()` <br/>\r\n  `e.target.files` 로 불러온 객체 형식의 데이터를 배열로 바꾸어서 관리해준다.\r\n\r\n![Untitled (2)](https://user-images.githubusercontent.com/68415905/154844917-3640cfb1-63e8-4bc6-a679-a714aa0b575f.png)\r\n\r\n첨부한 이미지 데이터가 담긴 배열을 `map`으로 순회하며 이미지 파일명만 추출해서 새로운 state에 저장하고 화면에 출력하도록 설계했다.\r\n\r\n```jsx\r\n// ImageUpload.js\r\nconst [imageList, setImageList] = useState([])\r\nconst handleUpload = e => {\r\n  const uploadedImage = Array.from(e.target.files).map(file => file.name)\r\n  if (id === \"thumbnail\") {\r\n    setImageList(uploadedImage)\r\n  } else {\r\n    setImageList([...imageList, ...uploadedImage].reverse())\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 이미지 preview `URL.createObjectURL`\r\n\r\n`URL.createObjectURL`로 이미지 파일의 URL을 추출하고 img태그의 src로 넣어준다.\r\n\r\n```jsx\r\nconst [imgUrl, setImgUrl] = useState(\"\")\r\nconst getImageUrl = e => {\r\n  let file = e.target.files[0]\r\n  let url = URL.createObjectURL(file)\r\n  setImgUrl(url)\r\n}\r\n```\r\n\r\n```jsx\r\n<img src={imgUrl} alt=\"\" />\r\n```\r\n\r\n---\r\n\r\n## ♻ 프로젝트 리팩토링\r\n\r\n처음엔 필수옵션이 기입되지 않은 경우 '필수 값을 모두 입력하세요!' 라는 alert이 보여지도록 코드를 작성했다. 하지만 사용자의 입장에서 어떤 옵션이 비어있는지 구체적으로 알 수 있으면 좋을 것 같아 alert에서 비어있는 옵션명도 함께 알려주도록 리팩토링 해보기로 했다.\r\n\r\n먼저 validation이라는 유틸함수를 만들고 값이 전달되지 않는 필수 옵션명의 이름을 리턴하도록 작성했다. 그리고 코드의 가독성을 위해 useForm이라는 커스텀 hook을 만들었고 validation에서 리턴된 옵션명을 alert에 출력하는 함수를 리턴하도록 구현했다.\r\n\r\n![캡처](https://user-images.githubusercontent.com/68415905/154845357-06d08840-fb5d-455f-8aec-fe1331ce6d80.JPG)\r\n\r\n### validation.js\r\n\r\n```jsx\r\nexport const validation = required => {\r\n  const inVaild = Object.keys(required).filter(\r\n    key => !required[key] || required[key].length === 0\r\n  )\r\n\r\n  const inVaildList = inVaild.map(el => {\r\n    switch (el) {\r\n      case \"category\":\r\n        return \"카테고리\"\r\n      case \"productName\":\r\n        return \"상품명\"\r\n      case \"description\":\r\n        return \"상품 구성 소개 정보\"\r\n      case \"stock\":\r\n        return \"상품 총 재고\"\r\n      case \"option\":\r\n        return \"상품 옵션\"\r\n      default:\r\n        throw new Error(\"Unknown option type\")\r\n    }\r\n  })\r\n\r\n  return inVaildList\r\n}\r\n```\r\n\r\n### useForm.js\r\n\r\n```jsx\r\nexport const useForm = requiredList => {\r\n  const [required, setRequired] = useState(requiredList)\r\n  const addRequired = useCallback(\r\n    (name, value) => {\r\n      setRequired(prev => ({\r\n        ...prev,\r\n        [name]: value,\r\n      }))\r\n    },\r\n    [setRequired]\r\n  )\r\n\r\n  const handleClick = () => {\r\n    const inVaild = validation(required)\r\n    if (!inVaild.length) {\r\n      submitForm()\r\n    } else {\r\n      alert(\r\n        `필수 값을 모두 입력하세요 ❗❗\r\n👉 ${inVaild.join(\", \")}을(를) 추가해주세요!`\r\n      )\r\n    }\r\n  }\r\n\r\n  const submitForm = () => {\r\n    alert(\"상품이 등록 되었습니다 🎉🎉\")\r\n  }\r\n\r\n  return { addRequired, handleClick }\r\n}\r\n```\r\n\r\n- useForm 사용\r\n\r\n```jsx\r\nconst { addRequired, handleClick } = useForm({\r\n  category: [],\r\n  productName: \"\",\r\n  description: \"\",\r\n  stock: \"\",\r\n  option: [],\r\n})\r\n\r\nreturn (\r\n  <RegistryForm onSubmit={e => e.preventDefault()}>\r\n    <TopButton name=\"저장하기\" handleClick={handleClick} type=\"submit\" />\r\n    <BasicInformation title=\"상품 기본 정보\" addRequired={addRequired} />\r\n    <OptionMain title=\"상품 옵션\" addRequired={addRequired} />\r\n    // ...\r\n  </RegistryForm>\r\n)\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Stack Overflow https://stackoverflow.com/questions/60151566/display-file-name-for-custom-input-file-using-reactjs<br />[React] useForm 만들기 https://velog.io/@junghyeonsu/React-useForm\r\n"},{"excerpt":"☝ 프로젝트 시작하기 전 프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다. 본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다. 프로젝트 폴더 구조는 어떻게 만들까? 커…","fields":{"slug":"/currency-converter/"},"frontmatter":{"date":"January 28, 2022","title":"환율 계산기(Currency Converter) 만들기","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\r\n## ☝ 프로젝트 시작하기 전\r\n\r\n프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다.\r\n\r\n본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다.\r\n\r\n- 프로젝트 폴더 구조는 어떻게 만들까?\r\n- 커밋은 어떤 방식을 사용할 것인가?\r\n- 네임 컨벤션은 어떻게 따를 것인가? (컴포넌트이름, branch이름, 상수처리 등 )\r\n- CSS는 어떤 툴을 사용할 것인가? (Styled Component, SASS, CSS Modules 등)\r\n\r\n크게 4가지 주제로 팀원들과 협업규칙을 정했고 Docs로 정리해두었다. [👉 Docs 보러가기](https://www.notion.so/50aee26d48df4e0baf7ac3f8203c7f08)\r\n\r\n## 📌 프로젝트 링크\r\n\r\n[Github](https://github.com/devjoylee/currency-converter)\r\n[배포링크](https://currency-converter-w.netlify.app/)\r\n\r\n## 📲 환율 계산기 만들기\r\n\r\n환율 정보는 제공된 API(https://currencylayer.com/)에서 실시간 환율 데이터를 `fetch`해서 사용했다. 계산기에 값을 입력하고 화폐단위를 선택하면 해당 환율을 출력하도록 로직을 설계했다.\r\n\r\n### 입력값 상태 저장\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154837797-6f5b9bb5-eebb-4a9f-9b4f-8fc47bc9c815.png)\r\n\r\n먼저 입력값은 2가지로 나뉜다.\r\n\r\n1. **input으로 입력한 금액**\r\n\r\n2. **select 박스로 선택한 화폐단위**\r\n\r\n```jsx\r\nconst [inputValue, setInputValue] = useState(\"\")\r\nconst [currency, setCurrency] = useState(\"USD\")\r\n```\r\n\r\n각각 다른 state를 만들어 입력 값을 관리하도록 하였고 input의 입력값에는 10자리 이하 숫자만 입력되도록 하기위해 입력값 length가 10을 넘는 경우 return 시켰다. 그리고 `toLocaleString` 을 사용해 숫자 3자리마다 콤마(,)가 자동으로 보이도록 만들었다. ex) 1,000,000\r\n\r\n```jsx\r\n// input에 값이 입력될 때\r\nconst handleType = e => {\r\n  const pureString = e.target.value.split(\",\").join(\"\")\r\n  if (isNaN(Number(pureString))) return\r\n  if (pureString.length > 10) return\r\n  if (Number(pureString) >= 1000) {\r\n    setInputValue(Number(pureString).toLocaleString())\r\n  } else {\r\n    setInputValue(pureString)\r\n  }\r\n}\r\n// select box 값이 선택될 때\r\nconst handleChange = e => {\r\n  setCurrency(e.target.value)\r\n  setInputValue(\"\")\r\n}\r\n```\r\n\r\n### 탭 기능 구현\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154838315-42884797-688c-43c6-aab6-bc06f9b33f2a.JPG)\r\n\r\n위 select 박스에서 선택된 단위는 아래 탭박스에 나타나지 않도록 하기위해 전체 화폐단위 값을 가져와서 `filter`로 select 박스에 선택된 값을 제외하고 탭을 다시 정렬하도록 구현했다. 활성화된 탭은 border-bottom값을 none으로 해주었다.\r\n\r\n```jsx\r\nconst [tabs, setTabs] = useState(TAB_CURRENCY)\r\nconst [currentTab, setCurrentTab] = useState(\"\")\r\n\r\nconst handleClick = e => {\r\n  setCurrentTab(e.target.innerHTML)\r\n} // 탭 클릭 시 현재 탭 상태 업데이트\r\n\r\nuseEffect(() => {\r\n  const handleTab = () => {\r\n    let changedTabs = TAB_CURRENCY.filter(tab => tab !== currency)\r\n    setTabs(changedTabs)\r\n    setCurrentTab(changedTabs[0])\r\n  }\r\n  handleTab()\r\n}, [currency, setCurrentTab])\r\n```\r\n\r\n### 실시간 날짜 & 환율 계산\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154838566-6341a0f4-bad8-4f66-b706-f6accb9e7488.jpg)\r\n\r\n데이터를 성공적으로 받아오면, `DateConverter`와 `CurrencyCalculator`로 실시간 환율을 계산한다. 환율 계산할 때는, 콤마(,)때문에 string으로 변한 value값을 다시 number로 바꾸어 준다. ex) “1,000” → 1000\r\n\r\n- 날짜 계산 (dateConverter.js)\r\n\r\n```jsx\r\nexport const DateConverter = timestamp => {\r\n  const time = new Date(timestamp * 1000)\r\n  const year = time.getFullYear()\r\n  const month = time.toLocaleString(\"en\", { month: \"short\" })\r\n  const date = time.getDate()\r\n  return `${year}-${month}-${date}`\r\n}\r\n```\r\n\r\n- 환율 계산 (currencyCalculator.js)\r\n\r\n```jsx\r\nconst CurrencyCalculator = (target, base, money) => {\r\n  let targetRate = apiData.quotes[`USD${target}`]\r\n  let baseRate = apiData.quotes[`USD${base}`]\r\n  let exchangeRate = Number((targetRate / baseRate) * money)\r\n  return exchangeRate.toLocaleString(\"en\", {\r\n    maximumFractionDigits: 2,\r\n  })\r\n}\r\n```\r\n\r\n## ♻ 프로젝트 리팩토링\r\n\r\n### API 상수화\r\n\r\n처음에는 API key, 화폐정보 등이 모두 포함된 API를 통째로 string으로 써서 data를 불러왔는데 화폐정보가 바뀔때 API를 수정해야한다는 불편함이 생겨 좀더 편리한 구조로 API 주소를 바꾸었다.\r\n\r\n- **리팩토링 전**\r\n\r\n```jsx\r\n// constants.js\r\nexport const API_ENDPOINT =\r\n  \"http://api.currencylayer.com/live?access_key=7cceb7113b3a6f9436614acd65e70c26&format=1\"\r\n\r\n// converter.jsx\r\nfetch(API_ENDPOINT)\r\n```\r\n\r\n- **리팩토링 후**\r\n\r\n```jsx\r\n// constants.js\r\nconst KEY = \"7cceb7113b3a6f9436614acd65e70c26\"\r\nexport const SELECT_CURRENCY = [\"KRW\", \"JPY\", \"PHP\"]\r\nexport const TAB_CURRENCY = [\"USD\", \"KRW\", \"JPY\", \"CAD\", \"HKD\", \"CNY\"]\r\nexport const API_ENDPOINT = currencies =>\r\n  `http://api.currencylayer.com/live?access_key=${KEY}&currencies=${currencies}&format=1`\r\n\r\n// converter.jsx\r\nfetch(API_ENDPOINT(TAB_CURRENCY.join(\",\")))\r\n```\r\n\r\n### API fetch 실패 시 로딩화면 추가\r\n\r\n처음에는 사용자가 입력창에 값을 입력하기 전 까지는 fetch 성공여부를 알 수 없었다. (fetch 실패 시 계산 안됨). 그래서 fetch가 실패한 경우 로딩이 실패했다는 UI를 보여줌으로써 사용자가 입력창에 입력을 해서 확인해보는 불필요한 작업을 최소화시켰다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/68415905/154838974-eb069e65-bbf1-4dbc-8794-2560ec8ac318.JPG\" width=\"450\" />\r\n\r\n### Netlify 배포 오류\r\n\r\n![error](https://user-images.githubusercontent.com/68415905/154839736-666c1574-4817-4461-9789-6d8edcf6bbda.jpg)\r\n프로젝트가 끝난 후, Netlify로 배포를 하려는데 `Mixed Content`라는 HTTP 관련 이슈가 생겨 배포가 안되는 문제가 발생했다. 알아본 결과 최신 브라우저에서는 `https` 페이지에서 `http` 리소스를 요청할 수 없다는 것을 알게되었다. 로컬에서는 API 사용이 가능했던 이유는 리액트 개발 서버는 http도 사용하기 때문이라고 했다.\r\n\r\n그래서 차선책으로 HTTP 업로드가 가능한 AWS를 통해 배포를 하기로 결정했다.\r\n[AWS 링크](http://beefplz.s3-website.ap-northeast-2.amazonaws.com/)\r\n\r\n하지만 AWS는 Netlify처럼 자동으로 업데이트되지 않고 배포한 사람이 매번 직접 빌드를 해야한다는 단점이 있었다. 그래서 Netlify에서 앞서 발생한 이슈를 해결할 수 있는 방법이 있을까 찾아보다가 public 위치에 `_redirects`라는 파일을 만들면 된다는 글을 보게되었다!\r\n\r\n```bash\r\n// _redirects\r\n/api/* http://api.currencylayer.com/:splat 200\r\n```\r\n\r\n```jsx\r\nfetch(`http://api.currencylayer.com/live?access_key=${KEY}`)\r\n👇\r\nfetch(`/api/live?access_key=${KEY}`)\r\n```\r\n\r\n`_redirects`에 HTTP 주소를 추가한 후, fetch 경로를 위처럼 수정하니 HTTP 이슈 없이 Netlify 배포에 성공했다! 🎉\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Netlify 공식문서 https://www.netlify.com/blog/2021/12/13/setting-up-redirects-on-netlify/\r\n"},{"excerpt":"✨ useReducer 정의 useState처럼 state를 생성 및 관리하는 hook입니다. 여러개의 하위값을 가진 복잡한 state를 다뤄야하거나 배열값에 추가,삭제,수정 등의 동시작업이 필요한 경우 사용합니다.  : state 업데이트를 위한 요구  : 요구의 내용  : state를 업데이트하는 역할 (은행) reducer 🔎 useReducer 사…","fields":{"slug":"/hook-useReducer/"},"frontmatter":{"date":"January 25, 2022","title":"[React] React Hook - useReducer","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useReducer 정의\r\n\r\nuseState처럼 state를 생성 및 관리하는 hook입니다. 여러개의 하위값을 가진 복잡한 state를 다뤄야하거나 배열값에 추가,삭제,수정 등의 동시작업이 필요한 경우 사용합니다.\r\n\r\n```jsx\r\nconst [state, dispatch] = useReducer(reducer, initialState)\r\n```\r\n\r\n- `dispatch` : state 업데이트를 위한 요구\r\n- `action` : 요구의 내용\r\n- `reducer` : state를 업데이트하는 역할 (은행)\r\n\r\n![reducer](https://user-images.githubusercontent.com/68415905/156757818-b586bdeb-e253-4466-80eb-0b9af175d2e9.JPG)\r\n\r\n## 🔎 useReducer 사용하기\r\n\r\n### 1. 필요한 action 정하기\r\n\r\nreducer에서 사용할 action은 상수화시켜 관리하면 유지보수가 편리합니다.\r\n\r\n```jsx\r\nconst ACTION_TYPES = {\r\n  DEPOSIT: \"deposit\",\r\n  WITHDRAW: \"withdraw\",\r\n}\r\n```\r\n\r\n### 2. reducer 함수 작성\r\n\r\nreducer함수에는 `switch`~`case`문을 사용하여 action에 따라 state를 업데이트 시켜주는 코드를 작성합니다. `payload`란 배나 비행기에 실려온 '화물'을 뜻하는데 여기서는 action이 실행되었을 때 전달되는 값을 의미합니다.\r\n\r\n```jsx\r\n// 기존 state에 전달된 payload 값을 더하거나 빼서 state 업데이트\r\nconst reducer = (state, action) => {\r\n  switch (action.type) {\r\n    case ACTION_TYPES.DEPOSIT:\r\n      return state + action.payload\r\n    case ACTION_TYPES.WITHDRAW:\r\n      return state - action.payload\r\n    default:\r\n      return state\r\n  }\r\n}\r\n```\r\n\r\n### 3. useReducer 호출\r\n\r\nuseReducer의 인자로 reducer 함수와 초기값(initialState)을 넘겨주면 state와 dispatch를 반환합니다. (`state`: 현재 상태 / `dispatch`: state 업데이트에 필요한 요구)\r\n\r\n```jsx\r\nconst [state, dispatch] = useReducer(reducer, initialState)\r\n```\r\n\r\n### 4. dispatch로 action 실행\r\n\r\n`dispatch`를 사용해서 필요한 값을 전달하고 action을 실행합니다. ex) '입금' 버튼을 클릭했을 때, 'DEPOSIT' action 실행. '출금' 버튼을 클릭했을 때, 'WITHDRAW' action 실행\r\n\r\n```jsx\r\nconst [value, setValue] = useState(0)\r\nconst [money, dispatch] = useReducer(reducer, 0)\r\nconst handleDeposit = () =>\r\n  dispatch({ type: ACTION_TYPES.DEPOSIT, payload: number })\r\nconst handleWithdraw = () =>\r\n  dispatch({ type: ACTION_TYPES.WITHDRAW, payload: number })\r\n\r\nreturn (\r\n  <div>\r\n    <h2>Reducer 은행</h2>\r\n    <p>잔고 : {money}원</p>\r\n    <input type=\"number\" value={value} step=\"1000\" />\r\n    <button onclick={handleDeposit}>입금</button>\r\n    <button onclick={handleWithdraw}>출금</button>\r\n  </div>\r\n)\r\n```\r\n\r\n## 🧐 useReducer 예시\r\n\r\n### reducer 함수\r\n\r\n```jsx\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case \"CHANGE_INPUT\":\r\n      return {\r\n        ...state,\r\n        inputs: {\r\n          ...state.inputs,\r\n          [action.name]: action.value,\r\n        },\r\n      }\r\n    case \"CREATE_USER\":\r\n      return {\r\n        inputs: initialState.inputs,\r\n        users: state.users.concat(action.user),\r\n      }\r\n    case \"TOGGLE_USER\":\r\n      return {\r\n        ...state,\r\n        users: state.users.map(user =>\r\n          user.id === action.id ? { ...user, active: !user.active } : user\r\n        ),\r\n      }\r\n    case \"REMOVE_USER\":\r\n      return {\r\n        ...state,\r\n        users: state.users.filter(user => user.id !== action.id),\r\n      }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n```\r\n\r\n### dispatch 함수\r\n\r\n```jsx\r\nconst [state, dispatch] = useReducer(reducer, initialState)\r\nconst nextId = useRef(4)\r\n\r\nconst { users } = state\r\nconst { username, email } = state.inputs\r\n\r\nconst onChange = useCallback(e => {\r\n  const { name, value } = e.target\r\n  dispatch({\r\n    type: \"CHANGE_INPUT\",\r\n    name,\r\n    value,\r\n  })\r\n}, [])\r\n\r\nconst onCreate = useCallback(() => {\r\n  dispatch({\r\n    type: \"CREATE_USER\",\r\n    user: {\r\n      id: nextId.current,\r\n      username,\r\n      email,\r\n    },\r\n  })\r\n  nextId.current += 1\r\n}, [username, email])\r\n\r\nconst onToggle = useCallback(id => {\r\n  dispatch({\r\n    type: \"TOGGLE_USER\",\r\n    id,\r\n  })\r\n}, [])\r\n\r\nconst onRemove = useCallback(id => {\r\n  dispatch({\r\n    type: \"REMOVE_USER\",\r\n    id,\r\n  })\r\n}, [])\r\n```\r\n\r\n<br/>\r\n\r\n> REFERENCE<br /> Youtube 별코딩 https://youtu.be/tdORpiegLg0<br/>벨로퍼트 리액트 https://react.vlpt.us/basic/20-useReducer.html\r\n"},{"excerpt":"✨ useCallback 정의 useCallback은 useMemo와 같이 Memoization 기법을 사용하여 컴포넌트 최적화에 사용됩니다. useMemo는 함수에서 반환되는 '값'을 저장한다면 useCallback은 '함수 그 자체'를 저장해두고 재사용하는 것입니다. useCallback 역시 2개의 인자를 필요로 하는데, memoization할 콜백…","fields":{"slug":"/hook-useCallback/"},"frontmatter":{"date":"January 20, 2022","title":"[React] React Hook - useCallback","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useCallback 정의\r\n\r\nuseCallback은 useMemo와 같이 Memoization 기법을 사용하여 컴포넌트 최적화에 사용됩니다. useMemo는 함수에서 반환되는 '값'을 저장한다면 useCallback은 '함수 그 자체'를 저장해두고 재사용하는 것입니다. useCallback 역시 2개의 인자를 필요로 하는데, memoization할 콜백함수와 dependency array를 인자로 받아옵니다.\r\n\r\n```jsx\r\nconst result = useCallback(() => {\r\n  return value\r\n}, [])\r\n```\r\n\r\n## 🔎 useCallback 사용하기\r\n\r\n함수형 컴포넌트가 렌더링되면 내부의 모든 변수가 초기화됩니다. 그러므로 컴포넌트 내부에 존재하는 함수 역시 렌더링될 때마다 초기화되고 새로운 함수가 생성됩니다.\r\n\r\n이때, 내부 함수를 useCallback으로 감싸주면, 컴포넌트가 렌더링 되어도 함수가 초기화되는 것을 막을 수 있습니다. 첫 렌더링 때, 함수 객체를 만들어서 초기화한 후 저장해두고 이후 렌더링 부터는 저장된 함수를 사용하는 것 입니다.\r\n\r\n- `useCallback` 적용 전\r\n\r\n```jsx\r\nfunction App() {\r\n  const [number, setNumber] = useState(0);\r\n  const someFunction = () => { // 렌더링마다 초기화\r\n    console.log(`number: ${number}`)\r\n    return\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log(\"someFunction이 변경되었습니다.\")\r\n  }, [someFunction])\r\n\r\n  return (\r\n    // 렌더링 발생 로직..\r\n  )\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n- `useCallback` 적용 후\r\n\r\n```jsx\r\nfunction App() {\r\n  const [number, setNumber] = useState(0);\r\n  const someFunction = useCallback(() => { // 첫 렌더링에만 초기화\r\n    console.log(`number: ${number}`)\r\n    return\r\n  }, [number]); // number가 바뀔 때 만 업데이트\r\n\r\n  useEffect(() => {\r\n    console.log(\"someFunction이 변경되었습니다.\")\r\n  }, [someFunction])\r\n\r\n  return (\r\n    // 렌더링 발생 로직..\r\n  )\r\n}\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n> REFERENCE<br/>Youtube 별코딩 https://youtu.be/XfUF9qLa3mU<br/>useCallback 과 useMemo 의 차이 https://basemenks.tistory.com/238\r\n"},{"excerpt":"✨ useMemo 정의 useMemo는 'Memoization' 되어있는 값을 반환시켜주는 hook입니다. Memoization이란 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말합니다. Memoization을 절적히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션…","fields":{"slug":"/hook-useMemo/"},"frontmatter":{"date":"January 14, 2022","title":"[React] React Hook - useMemo","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useMemo 정의\r\n\r\nuseMemo는 'Memoization' 되어있는 값을 반환시켜주는 hook입니다. Memoization이란 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말합니다. Memoization을 절적히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션의 성능을 최적화할 수 있습니다.\r\n\r\n```jsx\r\nconst result = useMemo(() => {\r\n  return calculate(a, b) // 10\r\n}, [a, b])\r\n```\r\n\r\n- 컴포넌트 성능 최적화에 사용된다!\r\n- dependency array에 추가한 값이 업데이트되면 useMemo값도 업데이트 된다.\r\n- 꼭 필요할 때만 사용할 것! 추가로 메모리를 소비해야하므로 많이 쓴다고 좋은 것 x\r\n\r\n## 🔎 useMemo 특징\r\n\r\n### 1. state 관리 최적화\r\n\r\n- `useMemo` 적용 전\r\n\r\nApp 컴포넌트가 렌더링될 때마다, `hardCalculate`와 `easyCalculate`가 다시 실행되어 딜레이가 발생할 수 있습니다.\r\n\r\n```jsx\r\n// calculate.js\r\nconst hardCalculate = num => {\r\n  console.log(\"어려운 계산!\")\r\n  for (let i = 0; i < 999999999; i++) {} // take your time..\r\n  return num + 10000\r\n}\r\nconst easyCalculate = num => {\r\n  console.log(\"쉬운 계산!\")\r\n  return num + 1\r\n}\r\n```\r\n\r\n```jsx\r\n// App.js\r\nconst App = () => {\r\n  const hardSum = hardCalculate(num);\r\n  const easySum = easyCalculate(num);\r\n\treturn (\r\n\t\t//...\r\n\t)\r\n};\r\n```\r\n\r\n<br/>\r\n\r\n- `useMemo` 적용 후\r\n\r\n첫 렌더링 시, useMemo가 적용된 함수의 리턴값을 저장해두고 이후 컴포넌트가 리렌더링되었을 때 저장되있던 값을 불러와 사용합니다. dependency array로 전달한 인자값이 변하면, 함수를 다시 실행 해서 저장된 값을 업데이트 시켜줍니다.\r\n\r\n```jsx\r\n// App.js\r\nconst App = () => {\r\n  const hardSum = useMemo(() => hardCalculate(num), [num]);\r\n  const easySum = easyCalculate(num);\r\n  return (\r\n    // ...\r\n  )\r\n}\r\n```\r\n\r\n### 2. 객체 주소 관리하기\r\n\r\n- `useMemo` 적용 전\r\n\r\nuseEffect의 dependency array로 객체를 전달할 경우, 객체에 변화가 없어도 useEffect가 실행됩니다. 렌더링이 발생하면 객체 메모리 주소가 새로운 주소로 바뀌기 때문입니다.\r\n\r\n```jsx\r\nconst location = {\r\n  country: isKorea ? \"한국\" : \"캐나다\",\r\n}\r\n\r\nuseEffect(() => {\r\n  console.log(\"렌더링\")\r\n}, [location])\r\n```\r\n\r\n위처럼 변수에 객체타입을 저장하면 객체 자신이 아닌 **객체가 담긴 메모리의 주소**가 할당됩니다. 객체값에는 변화가 없더라도 렌더링 시 `location`에 새로운 주소가 할당되었으므로 useEffect가 실행됩니다.\r\n\r\n![JPG](https://user-images.githubusercontent.com/68415905/156110497-9051a4f5-5669-4a08-9726-d16d56a86a4d.jpg)\r\n\r\n- `useMemo` 적용 후\r\n\r\nuseMemo를 사용해서 `객체 메모리 주소`값을 가진 변수가 매 렌더링 시 업데이트 되지 않도록 설정합니다. 이때, 객체 내부에서 변하는 값을 useMemo의 dependency array로 전달하여 그 값이 업데이트된 경우에만 변수(메모리주소)가 업데이트되도록 합니다.\r\n\r\n```jsx\r\nconst location = useMemo(() => {\r\n\treturn {\r\n\t  country: isKorea ? '한국' : '캐나다',\r\n\t};\r\n}, [isKorea]; // isKorea가 변할 때 location의 메모리 주소 업데이트\r\n\r\nuseEffect(() => {\r\n  console.log('렌더링');\r\n}, [location]); // location의 메모리주소가 업데이트 되면 실행\r\n```\r\n\r\n## 🚫 useMemo 사용 시 주의점\r\n\r\n성능 최적화를 할때는 기대되는 성능이 지불하는 대가에 비해서 미미하지 않은지 반드시 따져보고 사용을 해야합니다. 예를 들어, useMemo hook 함수를 남용하면, 컴포넌트의 복잡도가 올라가기 때문에 코드를 읽기도 어려워지고 유지보수성도 떨어지게 됩니다. 또한 useMemo가 적용된 레퍼런스는 재활용을 위해서 가바지 컬렉션(garbage collection)에서 제외되기 때문에 메모리를 더 쓰게 됩니다.\r\n\r\n일반적으로 수초 이상 걸리는 로직이 프론트엔드(front-end)에 존재하다는 것은 흔치 않은 일이고, 만약 그렇게 오래 걸리는 로직이 있다고 해도 useEffect 등을 이용해서 비동기로 처리하는 방안을 먼저 고려해보는 것이 좋습니다. 또한 컴포넌트가 여러 번 렌더링된다고 해서 실제로 심각한 성능 이슈로 이어지는 경우가 매우 적기때문에 무조건적인 useMemo의 사용은 지양할 필요가 있습니다.\r\n\r\n<br/>\r\n<br/>\r\n\r\n> REFERENCE<br />Youtube 별코딩 https://youtu.be/e-CnI8Q5RY4<br/>React Hooks: useMemo 사용법 https://www.daleseo.com/react-hooks-use-memo/\r\n"},{"excerpt":"✨ useContext 정의 Context API : 전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 방법 Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다. Prop drilling을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려해볼 것! **Prop drilling : …","fields":{"slug":"/hook-useContext/"},"frontmatter":{"date":"January 11, 2022","title":"[React] React Hook - useContext","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useContext 정의\r\n\r\n**Context API** : 전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 방법\r\n\r\n- Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다.\r\n- **Prop drilling**을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려해볼 것! <br/>\\*\\*_Prop drilling_ : 컴포넌트가 필요한 데이터를 여러 컴포넌트를 거쳐 전달받는 과정\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/155961762-07444598-b37f-4a31-991b-7cf610056aa4.png)\r\n\r\n## 🌱 Context 사용 전\r\n\r\n부모 App 컴포넌트에서 전역적으로 생성한 state를 자식 컴포넌트인 Header에서 사용하고자 합니다. state값은 App → Page → Header 순서로 전달됩니다. 중간에 있는 Page 컴포넌트는 state를 전달하는 매개체일 뿐, state 값을 사용하지는 않습니다.\r\n\r\n```jsx\r\n// App.js\r\nfunction App() {\r\n  const [isDark, setIsDark] = useState(false)\r\n  return <Page isDark={isDark} setIsDark={setIsDark} />\r\n}\r\n```\r\n\r\n```jsx\r\n// Page.js\r\nfunction Page({ isDark, setIsDark }) {\r\n  return (\r\n    <div>\r\n      <Header isDark={isDark} />\r\n      <Content isDark={isDark} />\r\n      <Footer isDark={isDark} setIsDark={setIsDark} />\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n```jsx\r\n// Header.js\r\nfunction Header({ isDark }) {\r\n  return (\r\n    <header\r\n      style={{\r\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\r\n        color: isDark ? \"white\" : \"black\",\r\n      }}\r\n    ></header>\r\n  )\r\n}\r\n```\r\n\r\n## 🍀 Context 생성\r\n\r\n`context` 폴더를 만들고 js 파일을 생성한 후 context 코드를 작성합니다.\r\n\r\n```jsx\r\n// ThemeContext.js\r\nimport { createContext } from \"react\"\r\n\r\nexport const ThemeContext = createContext(null)\r\n```\r\n\r\n## 🌿 Context 전달\r\n\r\n생성한 Context는 데이터를 가진 부모컴포넌트에 import 시킨 후 `Provider`로 컴포넌트를 감싸줍니다. 그리고 `value`라는 prop에 전달하고자 하는 데이터를 집어넣어 줍니다.\r\n\r\n`Provider` 가 감싸는 모든 하위 컴포넌트는 `value`로 전달한 데이터에 접근이 가능합니다. <br/>(불필요한 props 전달 ❌)\r\n\r\n```jsx\r\n// App.js\r\nimport React, { useState } from \"react\"\r\nimport Page from \"./components/Page\"\r\nimport { ThemeContext } from \"./context/ThemeContext\"\r\n\r\nfunction App() {\r\n  const [isDark, setIsDark] = useState(false)\r\n  return (\r\n    <ThemeContext.Provider value={{ isDark, setIsDark }}>\r\n      <Page />\r\n    </ThemeContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\r\n```\r\n\r\n```jsx\r\n// Page.js\r\nfunction Page() {\r\n  return (\r\n    <div>\r\n      <Header />\r\n      <Content />\r\n      <Footer />\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n## 🌳 Context 사용\r\n\r\n부모 컴포넌트에서 Context 로 state값을 전달하면 자식 컴포넌트에서 `useContext`를 사용해 데이터를 가져옵니다.\r\n\r\n```jsx\r\n// Header.js\r\nfunction Header() {\r\n  const { isDark } = useContext(ThemeContext) // Context 불러오기\r\n  return (\r\n    <header\r\n      style={{\r\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\r\n        color: isDark ? \"white\" : \"black\",\r\n      }}\r\n    ></header>\r\n  )\r\n}\r\n```\r\n\r\n```jsx\r\n// Footer.js\r\nimport React, { useContext } from \"react\"\r\nimport { ThemeContext } from \"../context/ThemeContext\"\r\n\r\nfunction Footer() {\r\n  const { isDark, setIsDark } = useContext(ThemeContext) // Context 불러오기\r\n  const toggleTheme = () => setIsDark(!isDark)\r\n  return (\r\n    <footer\r\n      style={{\r\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\r\n      }}\r\n    >\r\n      <button onClick={toggleTheme}>Dark Mode</button>\r\n    </footer>\r\n  )\r\n}\r\n```\r\n"},{"excerpt":"✨ useRef 정의 Ref는 'reference'의 약자로 '참조'라는 뜻입니다. useRef는 인자로 전달된 값을 에 할당하여 객체로 반환해 주는데, 이때 current에 할당된 값은 렌더링되어도 그대로 유지됩니다.\n그래서 렌더링에 상관없이 동일한 참조값이 필요한 경우 useRef를 사용합니다. 또한 current 값이 바뀌어도 컴포넌트가 리렌더링되지…","fields":{"slug":"/hook-useRef/"},"frontmatter":{"date":"January 08, 2022","title":"[React] React Hook - useRef","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useRef 정의\r\n\r\n```jsx\r\nconst ref = useRef(value) // { current: value }\r\n```\r\n\r\nRef는 'reference'의 약자로 '참조'라는 뜻입니다. useRef는 인자로 전달된 값을 `current`에 할당하여 객체로 반환해 주는데, 이때 current에 할당된 값은 렌더링되어도 그대로 유지됩니다.\r\n그래서 렌더링에 상관없이 동일한 참조값이 필요한 경우 useRef를 사용합니다.\r\n\r\n또한 current 값이 바뀌어도 컴포넌트가 리렌더링되지 않기때문에 자주 업데이트 되는 값은 <br/>state가 아닌 ref로 관리하면 불필요한 렌더링을 줄일 수 있습니다.\r\n\r\n## 🤔 useRef 언제 사용할까?\r\n\r\n### 1. 컴포넌트 내부 변수 관리\r\n\r\n변화는 감지해야 하지만, 렌더링이 불필요한 변수값을 다룰 때 useRef를 사용하면 컴포넌트 성능을 높일 수 있습니다. useRef를 활용한 변수는 아래와 같은 곳에 쓰입니다.\r\n\r\n- setTimeout, setInterval을 통해 만들어진 id\r\n- scroll 위치\r\n- 배열에 새 항목을 추가할 때 필요한 고유값 key\r\n\r\n```jsx\r\n// App.js\r\nconst users = [\r\n  {\r\n    id: 1,\r\n    username: \"joy\",\r\n  },\r\n  {\r\n    id: 2,\r\n    username: \"user1\",\r\n  },\r\n]\r\n\r\nconst nextId = useRef(3) // 새로운 유저 id값 3으로 지정\r\nconst onCreate = username => {\r\n  users.push({\r\n    id: nextId, // ref에 저장된 id 값 할당\r\n    username: username,\r\n  })\r\n  nextId.current += 1 // id값 1 증가\r\n}\r\n```\r\n\r\n### 2. DOM 요소에 접근\r\n\r\n`Document.querySelector()` 와 비슷한 기능으로 DOM에 직접적인 접근이 필요할 때 useRef를 사용할 수 있습니다. 사용하고자 하는 DOM 요소의 인라인 속성으로 useRef 값이 할당된 변수를 전달해주면 해당 Ref의 current 값에 DOM 요소가 저장됩니다.\r\n\r\n```jsx\r\nconst inputRef = useRef(null)\r\nconsole.log(inputRef) // {current: input}\r\n\r\nreturn <input ref={inputRef} type=\"text\" />\r\n```\r\n\r\nDOM 요소에 접근이 필요한 경우는 아래와 같습니다.\r\n\r\n- 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.\r\n- 애니메이션을 직접적으로 실행시킬 때.\r\n- 서드 파티 DOM 라이브러리를 React와 같이 사용할 때.\r\n\r\n```jsx\r\n// input.js\r\nconst App = () => {\r\n  const inputRef = useRef()\r\n  useEffect(() => {\r\n    inputRef.current.focus() // input 요소에 focus\r\n  }, [])\r\n\r\n  return (\r\n    <div>\r\n      <input ref={inputRef} type=\"text\" placeholder=\"username\" />\r\n      <button onClick={login}>로그인</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n## 🔎 useRef 특징\r\n\r\n1. 렌더링이 발생해도 current에 저장된 값은 그대로 유지됩니다.\r\n2. current 값이 바뀌어도 컴포넌트가 리렌더링되지 않습니다.\r\n\r\n### Ref와 변수의 차이점\r\n\r\n- 공통점 : 렌더링 발생 ❌\r\n\r\n- 차이점 : ref 와 변수에 각각 값을 저장하다가 **렌더링이 발생하면** 변수에 저장된 값은 초기화되지만 ref에 저장된 값은 그대로 유지됩니다.\r\n\r\n```jsx\r\nimport React, { useState, useRef } from \"react\"\r\n\r\nconst App = () => {\r\n  const [render, setRender] = useState(0)\r\n  console.log(\"렌더링 발생!!\")\r\n  const countRef = useRef(0)\r\n  let countVar = 0\r\n\r\n  return (\r\n    <div>\r\n      <p>Ref: {countRef.current}</p>\r\n      <p>Var: {countVar}</p>\r\n      <button onClick={() => countRef.current++}>Ref올려</button>\r\n      <button onClick={() => countVar++}>Var올려</button>\r\n      <button onClick={() => setRender(render + 1)}>렌더링 발생!</button>\r\n    </div>\r\n  )\r\n}\r\nexport default App\r\n```\r\n\r\n```jsx\r\nRef : 0 , Var : 0\r\nRef : 1 , Var : 1\r\nRef : 2 , Var : 2\r\nRef : 3 , Var : 3\r\n렌더링 발생!!\r\nRef : 4 , Var : 0\r\nRef : 5 , Var : 1\r\nRef : 6 , Var : 2\r\n렌더링 발생!!\r\nRef : 7 , Var : 0\r\nRef : 8 , Var : 1\r\n```\r\n\r\n### Ref와 state의 차이점\r\n\r\n- `state` 변화 → 렌더링 ⭕ → 컴포넌트 내부 변수들 초기화\r\n\r\n- `ref` 변화 → 렌더링 ❌ → 변수 값이 유지됨 <br/>\r\n  (state에 의해 다시 렌더링 되었을 때도 그대로 유지)\r\n\r\n```jsx\r\nimport React, { useState, useRef } from \"react\"\r\n\r\nconst App = () => {\r\n  const [count, setCount] = useState(0)\r\n  const countRef = useRef(0)\r\n  console.log(\"렌더링!\")\r\n\r\n  return (\r\n    <div>\r\n      <p>State: {count}</p>\r\n      <p>Ref: {countRef.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>State올려</button>\r\n      <button onClick={() => countRef.current++}>Ref올려</button>\r\n    </div>\r\n  )\r\n}\r\nexport default App\r\n```\r\n\r\n- `state올려` 버튼 클릭 : 클릭할 때마다 화면에 증가한 state값이 나타납니다.\r\n\r\n  → state가 매번 업데이트되면서 App 컴포넌트가 다시 렌더링 되기 때문\r\n\r\n- `ref올려` 버튼 클릭 : 화면에는 변화가 없지만 내부적으로 ref값이 증가합니다.\r\n\r\n  → ref는 렌더링을 발생시키지 않으므로 화면이 업데이트되지 않기 때문\r\n\r\n  → 이후에 state가 변하고 렌더링이 발생하면, 이때 변화된 ref값이 화면에 나타난다!\r\n\r\n### useRef로 무한렌더링 방지\r\n\r\n렌더링 될 때마다 렌더링 횟수를 카운트하는 state를 만들고자 합니다. 아래 코드처럼 useEffect 내부에 상태 업데이트 함수를 사용하면 이렇게 무한루프가 발생하게 됩니다.\r\n\r\n렌더링 → `useEffect` 실행→ `setRenderCount` → state 업데이트 → 렌더링 → `useEffect` 실행 → `setRenderCount` → state 업데이트 → 렌더링 ...\r\n\r\n```jsx\r\nconst [renderCount, setRenderCount] = useState(1)\r\n\r\nuseEffect(() => {\r\n  console.log(\"렌더링\")\r\n  setRenderCount(renderCount + 1) // 렌더링 발생\r\n})\r\n```\r\n\r\n그러므로 이 경우에는, 렌더링 횟수를 저장하는 renderCount를 `useRef`로 관리하면 `useEffect` 내부에서 렌더링이 발생하지 않으므로 무한 렌더링을 막을 수 있습니다.\r\n\r\n```jsx\r\nconst renderCount = useRef(1)\r\n\r\nuseEffect(() => {\r\n  console.log(\"렌더링\")\r\n  renderCount.current++ // 렌더링 발생 ❌\r\n})\r\n```\r\n\r\n<br />\r\n<br />\r\n\r\n> REFERENCE<br /> Youtube 별코딩 https://youtu.be/VxqZrL4FLz8<br />[React] useRef() 는 언제 사용하는가? https://yoonjong-park.tistory.com/entry/React-useRef-는-언제-사용하는가\r\n"},{"excerpt":"✨ useEffect 정의 첫 렌더링 할 때(mount), 다시 렌더링될 때(update), 화면에서 사라질 때(unmount), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다.  를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다. 렌더링될 때마다 실행 - De…","fields":{"slug":"/hook-useEffect/"},"frontmatter":{"date":"December 26, 2021","title":"[React] React Hook - useEffect","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useEffect 정의\r\n\r\n첫 렌더링 할 때(**mount**), 다시 렌더링될 때(**update**), 화면에서 사라질 때(**unmount**), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다. `useEffect` 를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다.\r\n\r\n- 렌더링될 때마다 실행 - Dependency array ❌\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code...\r\n})\r\n```\r\n\r\n- 첫 렌더링될 때(mount)만 실행 - Dependency array 빈 배열\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n}, [])\r\n```\r\n\r\n- 첫 렌더링 될때 + 특정 `state`**가 바뀔 때** 실행 - Dependency array에 `state` 전달\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n}, [value])\r\n```\r\n\r\n- 컴포넌트 unmount 시 실행 - `return` 추가\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n  return () => {\r\n    // clean up!!\r\n  }\r\n}, [])\r\n```\r\n\r\n## 🤔 useEffect 언제 사용할까?\r\n\r\n### 마운트할 때 필요한 작업\r\n\r\n- props 로 받은 값을 컴포넌트의 로컬 상태로 설정\r\n- 외부 API 요청 (REST API 등)\r\n- 라이브러리 사용 (D3, Video.js 등...)\r\n- setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약\r\n\r\n### 언마운트할 때 필요한 작업\r\n\r\n- setInterval, setTimeout 을 사용하여 등록한 작업들 clear 하기<br/>\r\n  (clearInterval, clearTimeout)\r\n- 라이브러리 인스턴스 제거\r\n\r\n## 🔎 useEffect 제대로 사용하기\r\n\r\n### Dependency Array\r\n\r\n해당 컴포넌트에 state가 여러개 있는 경우, state가 호출될 때 다른 state값도 다같이 렌더링 됩니다. 이때 useEffect를 사용해 dependency array에 호출하고자 하는 state값을 전달해주면 다른 불필요한 state 렌더링을 막을 수 있습니다.\r\n\r\n```jsx\r\nconst [count, setCount] = useState(1)\r\nconst [name, setName] = useState(\"\")\r\n\r\n// count만 렌더링!  name은 사용 x\r\nuseEffect(() => {\r\n  console.log(\"count 렌더링\")\r\n}, [count])\r\n\r\n// name만 렌더링! count은 사용 x\r\nuseEffect(() => {\r\n  console.log(\"name 렌더링\")\r\n}, [name])\r\n```\r\n\r\n### return\r\n\r\n`useEffect` 에서는 함수를 return 할 수 있는데 이때 반환되는 함수를 **cleanup 함수**라고 부릅니다. cleanup 함수는 useEffect 에 대한 뒷정리를 해준다고 이해하시면 되는데요, deps 가 비어있는 경우에는 컴포넌트가 사라질 때 cleanup 함수가 호출됩니다.\r\n\r\n**_timer.js_**\r\n\r\n```jsx\r\nimport React, {useEffect} from 'react';\r\n\r\nconst Timer = () => {\r\n\tuseEffect(()=> {\r\n\t\t// 컴포넌트가 mount 될 때 실행\r\n\t\tconst timer = setInterval(() => {\r\n\t\t\tconsole.log('타이머 실행 중....');\r\n\t\t}, 1000);\r\n\r\n\t\t// 컴포넌트가 unmount 될 때 실행\r\n\t\treturn () => {\r\n\t\t\tclearInterval(timer);\r\n\t\t\tconsole.log('타이머 종료!');\r\n\t\t}\r\n}, []);\r\nreturn (\r\n\t<div>타이머를 시작합니다.</div>\r\n)\r\nexport default Timer;\r\n```\r\n\r\n**_App.js_**\r\n\r\n```jsx\r\nimport React, { useState } from \"react\"\r\nimport Timer from \"./Timer\"\r\n\r\nfunction App() {\r\n  const [showTimer, setShowTimer] = useState(false)\r\n  return (\r\n    <div>\r\n      {showTimer && <Timer />}\r\n      <button onClick={() => setShowTimer(!showTimer)}>Toggle</button>\r\n    </div>\r\n  )\r\n}\r\nexport default App\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/16-useEffect.html<br/>Youtube 별코딩 https://youtu.be/kyodvzc5GHU\r\n"},{"excerpt":"✨ useState 정의 상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.  : 상태 값 저장 변수 (현재 상태 값)  : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수) 💡 useState…","fields":{"slug":"/hook-useState/"},"frontmatter":{"date":"December 23, 2021","title":"[React] React Hook - useState","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useState 정의\r\n\r\n상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.\r\n\r\n```jsx\r\nconst [state, setState] = useState(<상태 초기 값>);\r\n```\r\n\r\n- `state` : 상태 값 저장 변수 (현재 상태 값)\r\n- `setState` : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수)\r\n\r\n## 💡 useState 예시\r\n\r\n### Counter 만들기\r\n\r\n초기값을 1로 설정 후, 버튼 클릭할 때마다 상태값(`count`)이 +1씩 업데이트 됩니다.\r\n\r\n```jsx\r\n// count.js\r\nimport { useState } from \"react\"\r\n\r\nfunction Count() {\r\n  const [count, setCount] = useState(1) // 초기값이 1인 count(state) 생성\r\n  const handleClick = () => {\r\n    setCount(count + 1) // 클릭 이벤트 발생 시, count = count + 1\r\n  }\r\n  return (\r\n    <div>\r\n      <span>클릭 횟수 : {count}</span>\r\n      <button onClick={handleClick}>Update</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n## 🔎 useState 제대로 사용하기\r\n\r\n### state가 배열 or 객체일 때?\r\n\r\n`setState` 함수로 `state`의 상태를 업데이트할 때는, **콜백함수** 내부에서 스프레드 연산자(`...`)로 이전 상태값을 가져온 뒤 현재 입력값을 추가하여 덮어쓰는 방식으로 사용합니다.\r\n\r\n```jsx\r\nconst updateArray = () => {\r\n  setNames(prevState => [newName, ...prevState])\r\n}\r\n```\r\n\r\n```jsx\r\nconst updateObject = () => {\r\n  const name = \"joy\"\r\n  const job = \"developer\"\r\n  setJobs(prevState => ({\r\n    ...prevState,\r\n    [name]: job,\r\n  }))\r\n}\r\n```\r\n\r\n### useState 최적화\r\n\r\nuseState가 호출되면 컴포넌트가 다시 렌더링됩니다. state 초기값을 호출하는 루트가 복잡한 경우 컴포넌트가 렌더링될 때마다 다시 실행되서 성능이 떨어지게 됩니다. 이때, useState 내부에 **콜백함수**를 만들어 초기값을 선언하면 첫 렌더링 때만 불러오므로 불필요한 메모리 소비를 막을 수 있습니다.\r\n\r\n```jsx\r\nimport {useState} from 'react';\r\n\r\nconst heavyWork = () => {\r\n\tconsole.log('엄청 무거운 작업!!')\r\n\treturn ['Joy', 'Hana']\r\n}\r\n\r\nfunction Input() {\r\n\tconst [names, setNames] = useState(() => {\r\n\t\treturn heavyWork(); // callback으로 초기값 선언\r\n\t});\r\n\tconst [input, setInput] = useState('');\r\n\r\n\tconst handleChange = (e) => {\r\n\t\tsetInput(e.target.value);\r\n\t}\r\n\tconst handleUpload =() => {\r\n\t\tsetNames((prev) => {\r\n\t\t\treturn([input, ...prev];\r\n\t\t});\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<input type=\"text\" value={input} onChnage={handleChange} />\r\n\t\t\t<button onClick={handleUpload}>Upload</button>\r\n\t\t\t{names.map((name,i) => {\r\n\t\t\t\treturn <p key={i}>{name}</p>\r\n\t\t\t})}\r\n\t\t</div>\r\n\t);\r\n}\r\n```\r\n\r\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/07-useState.html<br/>Youtube 별코딩 https://youtu.be/G3qglTF-fFI\r\n"},{"excerpt":"🌟 Hook의 등장 배경 리액트 컴포넌트 종류 : Class Component / Functional Component Hook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없…","fields":{"slug":"/hook-about/"},"frontmatter":{"date":"December 22, 2021","title":"[React] React Hook이란?","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🌟 Hook의 등장 배경\r\n\r\n리액트 컴포넌트 종류 : **Class Component** / **Functional Component**\r\n\r\nHook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없었던 state관리나 Life Cycle Method가 가능하다는 이유로 어쩔 수 없이 Class Component를 사용해왔습니다.\r\n\r\nHook이 등장하기 전의 리액트는\r\n\r\n- 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어려웠습니다.\r\n\r\n- 생명주기 컴포넌트로 인한 복잡한 컴포넌트는 이해하기 어려웠습니다. 상태관련 로직이 모두 같은 공간에 위치하기 때문입니다.\r\n\r\n## 🧐 Hook 이란?\r\n\r\nHook은 리액트 16.8 버전 이후 함수형 컴포넌트에 추가된 기능입니다. 즉, React Hook은 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할 수 있도록 해주는 기능이며 Hook이 등장하면서 더 이상 상태를 관리하기 위해 Class Component를 쓸 필요가 없어졌습니다.\r\n\r\n기존에는 Class Component 에서만 상태를 관리 할 수 있었고, 함수형 컴포넌트에서는 상태를 관리할 수 없었습니다. 하지만 Hook이 등장하면서 함수형 컴포넌트 에서도 상태 관리를 할 수 있게 되었고, 상태 관리 뿐만 아니라 기존 클래스형 컴포넌트에서만 가능하던 여러 기능을 사용할 수 있게 되었습니다.\r\n\r\n👉 [React Hook 공식문서 바로가기](https://reactjs.org/docs/hooks-intro.html)\r\n\r\n## 🧾 Hook의 종류\r\n\r\n### useState\r\n\r\n가장 대표적인 Hook으로 상태값을 생성 및 업데이트시켜주는 Hook입니다.\r\n\r\n👉 [useState 더 알아보기](https://devjoylee.github.io/hook-useState)\r\n\r\n### useEffect\r\n\r\n컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정하는 Hook입니다.\r\n\r\n👉 [useEffect 더 알아보기](https://devjoylee.github.io/hook-useEffect)\r\n\r\n### useReducer\r\n\r\nuseState처럼 상태관리에 쓰이며 구조가 복잡한 상태관리에 적합한 Hook입니다.\r\n\r\n👉 [useReducer 더 알아보기](https://devjoylee.github.io/hook-useReducer)\r\n\r\n### useRef\r\n\r\n렌더링과 관련없는 값을 관리하거나 DOM에 접근이 필요한 경우 사용하는 Hook입니다.\r\n\r\n👉 [useRef 더 알아보기](https://devjoylee.github.io/hook-useRef)\r\n\r\n### useMemo\r\n\r\n렌더링 시 메모리에 값을 저장해두고 필요할 때 불러와서 사용할 수 있도록 하는 Hook입니다.\r\n\r\n👉 [useMemo 더 알아보기](https://devjoylee.github.io/hook-useMemo)\r\n\r\n### useCallback\r\n\r\nuseMemo와 비슷하나 값이 아닌 함수를 재사용하고자 할 때 사용하는 Hook입니다.\r\n\r\n👉 [useCallback 더 알아보기](https://devjoylee.github.io/hook-useCallback)\r\n\r\n### useContext\r\n\r\n전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 Hook입니다.\r\n\r\n👉 [useContext 더 알아보기](https://devjoylee.github.io/hook-useContext)\r\n\r\n<br />\r\n\r\n> REFERENCE<br /> React(23) 리액트 훅이란? https://devbirdfeet.tistory.com/52<br />리액트 공식 문서 https://reactjs.org/docs/hooks-intro.html<br/>[React] Hooks의 종류 https://lelana.tistory.com/146\r\n"},{"excerpt":"리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. () 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다! 리액트 시작하기 (CRA ❌) 1. 프…","fields":{"slug":"/react-scratch/"},"frontmatter":{"date":"December 21, 2021","title":"[React] 리액트 시작하기 (without CRA)","tags":["frontend","react"]},"rawMarkdownBody":"\r\n리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. (`npx create-react-app \"project-name\"`) 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다!\r\n\r\n## 리액트 시작하기 (CRA ❌)\r\n\r\n### 1. 프로젝트 폴더 생성 후 초기화\r\n\r\n원하는 경로에 프로젝트 폴더를 생성하고 프로젝트 초기화(`npm init -y`)를 진행합니다. 이때 `package.json`이라는 파일이 자동으로 생성되는데 이곳에 프로젝트 이름, 실행 명령어, 프로젝트에 필요한 라이브러리 등 관련 정보가 저장됩니다.\r\n\r\n```bash\r\nnpm init -y\r\n```\r\n\r\n### 2. 리액트 라이브러리 설치\r\n\r\n초기화가 끝나면 리액트 프로젝트에 필요한 패키지를 다운받습니다. 패키지 설치 방법은 아래와 같이 `npm install` 또는 `npm install --save-dev` 2가지 방식으로 가능합니다.\r\n\r\n✅ `npm i <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 해당 패키지 사용\r\n\r\n- package.json의 dependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i react react-dom\r\n```\r\n\r\n✅ `npm i --save-dev (or -D) <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 패키지 사용 ❌ (development mode에서만 사용)\r\n\r\n- package.json의 devDependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i -D @babel/core @babel/preset-env @babel/preset-react\r\nbabel-loader css-loader style-loader url-loader\r\nwebpack webpack-cli webpack-dev-server\r\nhtml-webpack-plugin\r\n```\r\n\r\n패키지 다운로드가 끝나면 프로젝트 폴더내부에 `node_modules` 폴더와 `package.lock.json` 파일이 새로 생성되고 (_yarn으로 설치한 경우_ `yarn.lock` _파일 생성_) `package.json`파일 내부에 아래와 같이 dependencies가 추가됩니다.\r\n\r\n![image](https://user-images.githubusercontent.com/68415905/154797755-7080fda7-541e-4ebf-a553-caa0ca4c79cc.png)\r\n\r\n### 3. `.babelrc` 파일 생성\r\n\r\n`babel` 이란 모든 브라우저에 호환이 가능하도록 최신 코드(ES6)를 구버전 코드(ES5)로 변환해주는 도구입니다. babel 설정을 위해서는 `.babelrc` 파일을 만들어 브라우저 호환에 필요한 babel 플러그인을 추가합니다. (preset : 필요한 플러그인 묶음)\r\n\r\n```bash\r\n// .babelrc\r\n{\r\n  presets: ['@babel/preset-env', '@babel/preset-react'],\r\n}\r\n```\r\n\r\n+) **webpack.config.js 파일 내부의 babel-loader의 옵션으로 추가한 경우 .babelrc 파일 생략 가능!!**\r\n\r\n### 4 . `webpack.config.js` 파일 생성\r\n\r\n`webpack`은 웹에서 사용되는 모든 자원(assets)을 묶음으로 번들링 해주는 도구입니다.\r\n\r\n웹팩을 사용하면 js 파일간의 종속성 뿐만 아니라 js 내에서 필요한 css나 img와 같은 파일(.css, .jpg)도 번들링해서 하나의 파일로 합쳐줘서 네트워크 요청을 최소화 시킬 수 있습니다.\r\n\r\n웹팩에 대해 자세히 알아보고 싶다면 링크를 참고해주세요!\r\n👉 [웹팩 포스팅 바로가기 ](https://devjoylee.github.io/dev-webpack-1)\r\n\r\n```jsx\r\n// webpack.config.js\r\nconst path = require(\"path\")\r\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: \"development\",\r\n  entry: \"./src/index.js\",\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"bundle.js\",\r\n    clean: true,\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx)$/,\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: \"babel-loader\",\r\n          options: {\r\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\r\n          },\r\n        },\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\"style-loader\", \"css-loader\"],\r\n      },\r\n      {\r\n        test: /\\.(jpg|png)$/i,\r\n        loader: \"url-loader\",\r\n        options: {\r\n          outputPath: \"images\",\r\n        },\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".js\", \".jsx\"],\r\n  },\r\n  devServer: {\r\n    static: path.join(__dirname, \"dist\"),\r\n    host: \"localhost\",\r\n    port: 3000,\r\n    open: true,\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: \"./public/index.html\",\r\n      inject: false,\r\n    }),\r\n  ],\r\n}\r\n```\r\n"},{"excerpt":"🧐 React란? React는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다. 다운로드 ✨ React의 필요성 사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 …","fields":{"slug":"/about/"},"frontmatter":{"date":"December 20, 2021","title":"[React] 리액트의 개념과 특징","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🧐 React란?\r\n\r\nReact는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다.\r\n\r\n![다운로드](https://user-images.githubusercontent.com/68415905/154801618-9bf1d698-3467-4f54-9df4-ebafce5b1e38.png)\r\n\r\n## ✨ React의 필요성\r\n\r\n사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 크고 UI 변화가 잦은 동적인 페이지라면 상태 변화 관리를 최소화 하고 DOM의 직접적인 업데이트를 막아주는 React 혹은 다른 프레임워크를 사용하는 것이 바람직합니다.\r\n\r\n## 🧾 React의 특징\r\n\r\n### 1. 단방향 데이터플로우\r\n\r\nReact는 데이터가 한방향으로만 이동하는 **단방향 데이터플로우**를 가집니다. 데이터가 UI로 이동하고 데이터가 변하면 UI도 함께 업데이트 되지만 반대로 UI쪽에서 데이터를 변화시키는 것은 불가능합니다. 단방향 데이터플로우를 사용하면 데이터 흐름이 간단해서 추적이 쉽고 예측이 가능해 유지보수가 편리하다는 장점이 있습니다.\r\n\r\n> ↔ 양방향 데이터 플로우 : 앵귤러(Angular.js) / 뷰(Vue.js)\r\n\r\n### 2. 가상돔(Virtual DOM)\r\n\r\nVirtual DOM이란 가상의 Document Object Model을 말합니다. 기존에는 javascript에서 DOM에 직접 접근하여 변화를 주는 방식을 사용하였는데 이경우 HTML,CSS,JS파일이 다시 리렌더링 되어 브라우저 내부에서 성능이슈가 발생했습니다.\r\n\r\nReact는 이런 단점을 보완하기 위해 Virtual DOM 이라는 것을 따로 만들었고 실제 DOM과 가상의 DOM을 비교하여 변화된 부분만 빠르게 업데이트 하는 방식을 사용하고 있습니다.\r\n\r\n**🔀 Virtual DOM 렌더링 순서**\r\n\r\n> JSX 수정 ➡ 가상 DOM 업데이트 ➡ 가상 DOM이 업데이트 되기 전과 비교하여 어떤 요소가 변경되었는지 확인 ➡ 가상 DOM에서 변경된 요소만 실제 DOM에서 업데이트\r\n\r\n### 3. Component 구조\r\n\r\n컴포넌트란 UI를 구성하는 개별 단위입니다. UI가 레고라면 컴포넌트는 하나의 블럭으로써 블럭을 쌓아 레고를 완성시키는 것처럼 컴포넌트를 조합하여 하나의 UI(페이지)를 만들 수 있습니다. 컴포넌트는 재사용이 가능하여 코드의 중복을 줄일 수 있고 효율적으로 유지보수를 할 수 있습니다.\r\n\r\n```js\r\nconst MainPage = () => {\r\n  return (\r\n    <Container>\r\n      <Header />\r\n      <MainContent>\r\n        <Section title=\"about\" />\r\n        <Section title=\"portfolio\" />\r\n      </MainContent>\r\n      <Footer />\r\n    </Container>\r\n  )\r\n}\r\n```\r\n\r\n### 4. JSX 문법\r\n\r\nJSX(Javascript + xml)는 Javascript에 대한 확장 구문으로서, Javascript를 좀더 편리하게 사용할 수 있도록 하는 Syntax Sugar 역할을 합니다. 이는 함수를 호출하거나 객체를 만들때 문법적인 편의를 제공하며 특히 DOM 요소를 만들 떄 `React.createElement()` 호출을 반복해야 하는 불편을 줄여줍니다. JSX는 React 엘리먼트를 생성하면서 자바스크립트의 모든 기능을 쓸 수 있도록 도와줍니다.\r\n\r\nJSX로 작성된 코드는 렌더링 시 Babel에 의해 자동으로 Javascript 코드로 컴파일됩니다.\r\n\r\n```jsx\r\n// jsx\r\n<MyButton color=\"blue\" shadowSize={2}>\r\n  Click Me\r\n</MyButton>\r\n```\r\n\r\n```jsx\r\n// javascript\r\nReact.createElement(\r\n  MyButton,\r\n  { color: \"blue\", shadowSize: 2 },\r\n  \"Click Me\"\r\n  //\r\n)\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br/>React란 무엇인가 https://firework-ham.tistory.com/5<br/>React란? https://velog.io/@jini_eun/React-React.js%EB%9E%80-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC\r\n"},{"excerpt":"✨ Webpack 등장 배경 이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게  을  태그에 추가하면 하나의  태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화) 👉 이전 포스팅 바로가기  image 하지만 안타깝게도 이런 모듈 시스템을 지원하는 브…","fields":{"slug":"/dev-webpack-1/"},"frontmatter":{"date":"November 29, 2021","title":"프론트엔드 개발환경 #3 - webpack이란?","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✨ Webpack 등장 배경\r\n\r\n이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게 `type=\"module\"` 을 `script` 태그에 추가하면 하나의 `script` 태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화)\r\n\r\n👉 [이전 포스팅 바로가기 ](https://devjoylee.github.io/dev-module)\r\n\r\n![image](https://images.velog.io/images/joyact/post/dfabe050-6ecc-4706-9e40-208164cb5621/image.png)\r\n\r\n하지만 안타깝게도 이런 모듈 시스템을 지원하는 브라우저는 한정되어 있습니다. 인터넷 익스플로러를 포함한 몇 브라우저는 여전히 모듈 시스템을 사용하지 않고있습니다. 따라서 모든 브라우저에 호환가능한 모듈링 시스템이 필요했고 이때 등장한 것이 **Webpack** 입니다.\r\n\r\n---\r\n\r\n## 🧐 Webpack이란?\r\n\r\n> Webpack : a module bundler\r\n\r\n![image](https://images.velog.io/images/joyact/post/d47c7828-ea1a-4844-bf88-d950f185899c/image.png)\r\n\r\n**웹팩(Webpack)**은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)입니다. 웹팩을 사용하면 여러개의 javascript 파일을 하나로 합쳐줌으로써 지저분한 `<script>` 태그의 반복 사용을 줄일 수 있고 효율적인 디버깅이 가능해집니다.\r\n\r\n또 다른 웹팩의 기능으로는 변환(transforming) 기능이 있습니다. ES6와 같은 모던 javascript를 ES5 형식으로 변환하고, Sass를 CSS로 변환시킴으로써 모든 브라우저가 이해할 수 있는 환경을 자체적으로 만들어냅니다.\r\n\r\n---\r\n\r\n## ➕ Webpack 설치\r\n\r\n1. npm install\r\n   `npm install webpack webpack-cli --save-dev`\r\n\r\n2. webpack.config.js 파일 생성\r\n   `module.exports` 내부에 필요한 configuration 옵션을 추가합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {}\r\n```\r\n\r\n---\r\n\r\n## 🚀 Webpack의 기능\r\n\r\n![image](https://images.velog.io/images/joyact/post/835b56bd-c22f-4fdf-b49f-57559b59a90d/Full-Stack-Introduction-to-Webpack.docx-2.jpg)\r\n\r\n모듈을 번들링하기 전, Webpack은 모듈 파일들을 그래프의 형식으로 인덱싱을 하게됩니다. 이를 **Dependency Graph**라고 하며 쉽게 말해 비슷한 형태의 파일을 하나로 묶기위해 분류하는 작업이라고 볼 수 있습니다.\r\n<br />\r\n\r\n### 기능1. The entry point\r\n\r\n![](https://images.velog.io/images/joyact/post/2afea557-9875-4a91-ac40-94117260cc6a/image.png)\r\n\r\nThe entry point는 Dependency Graph의 출발점이자 모듈 번들링을 시작하는 파일을 의미합니다. default 값은 `./src/index.js` 이며 직접 값을 지정하고 싶은경우 아래와 같이 configuration을 설정합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  entry: \"./app/index.js\",\r\n}\r\n```\r\n\r\n### 기능2. Loaders\r\n\r\n![image](https://images.velog.io/images/joyact/post/877e8797-5b3d-490e-9076-b428a968acf8/image.png)\r\n\r\nloader는 웹팩을 강력한 도구로 만들어주는 핵심 기능 중 하나입니다. 모듈에서 다루는 import, export 기능은 javascript와 json파일에만 국한되있는 것으로 css파일이나 image 파일을 다루게 되면 에러가 발생합니다. 하지만 loader를 사용하면 css, image 파일에도 접근이 가능하게 됩니다.\r\n\r\n1. 필요한 loader 설치\r\n\r\n   > **svg 파일 로더** : `npm install svg-inline-loader --save-dev` > **css 파일 로더** : `npm install style-loader css-loader --save-dev` > **js 파일 로더(es6->es5)** : `npm install babel-loader --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  rules: [\r\n    { test: /\\.svg$/, use: \"svg-inline-loader\" },\r\n    { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },\r\n    { test: /\\.(js)$/, use: \"babel-loader\" },\r\n  ],\r\n}\r\n```\r\n\r\n### 기능3. Output\r\n\r\nOutput은 번들링된 최종 파일 저장소를 뜻합니다. default 값으로 `dist/index.js` 가 설정이 되고 configuration 옵션에서 변경이 가능합니다.\r\n\r\n> **순서** : 모듈 번들링 ➡ dist 폴더 생성 ➡ dist 폴더 내부에 번들링된 최종 파일 저장\r\n> (생성된 파일 명은 옵션의 `filename`으로 지정)\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  output: {\r\n    path: path.resolve(__dirname, \"dist\"),\r\n    filename: \"index_bundle.js\",\r\n  },\r\n}\r\n```\r\n\r\n### 기능4. Plugin\r\n\r\nLoader가 각 모듈(파일)을 위한 기능이라면, Plugin은 최종 번들된 파일을 위한 기능을 수행합니다.\r\n\r\n- _**HtmlWebpackPlugin**_\r\n\r\n웹팩 번들링이 완료된 후 최종파일이 생성되면, 생성된 파일을 경로로 하는 `script` 태그가 추가된 index.html 파일을 만들어주는 플러그인입니다. 만약 output의 경로가 변경되더라도 직접 html을 수정할 필요없이 자동으로 script태그의 경로가 함께 업데이트 됩니다.\r\n\r\n1. 플러그인 설치\r\n   `npm install html-webpack-plugin --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n  // webpack.config.js\r\n\tconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\t...\r\n\tmodule.exports = {\r\n    \tplugins: [\r\n          new HtmlWebpackPlugin()\r\n        ]\r\n    }\r\n```\r\n\r\n![image](https://images.velog.io/images/joyact/post/ebea04b9-b261-4f62-911d-79da4c2a7635/image.png)\r\n\r\n> REFERENCE <br /> Youtube uidotdev Webpack Crash Course https://youtu.be/lFjinlwpcHY / <br /> 네이버 블로그 https://blog.naver.com/wlsdml1103/221333814197\r\n"},{"excerpt":"🧐 모듈(Module) 이란? Javascript를 공부하다보면 이라는 단어를 자주 접하게 됩니다.\nModule이란 코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n Module 사용 전 기존에는 html에  태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사…","fields":{"slug":"/dev-module/"},"frontmatter":{"date":"November 21, 2021","title":"프론트엔드 개발환경 #2 - 모듈 (Module)","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## 🧐 모듈(Module) 이란?\r\n\r\nJavascript를 공부하다보면 `Module`이라는 단어를 자주 접하게 됩니다.\r\nModule이란 **코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음**을 말하는데\r\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\r\n<br />\r\n\r\n### Module 사용 전\r\n\r\n```html\r\n<script src=\"./src/main.js\">\r\n<script src=\"./src/animation.js\">\r\n<script src=\"./src/banner.js\">\r\n```\r\n\r\n기존에는 html에 `<script>` 태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사용했습니다. 이 방식은 파일을 불러오는 순서가 코드에 영향을 주며, 생성한 파일의 object가 모두 전역 변수가되서 문제가 발생할 수 있다는 단점이 있습니다\r\n<br />\r\n\r\n### Module 사용 후\r\n\r\n```html\r\n<script type=\"module\" src=\"./src/main.js\">\r\n```\r\n\r\n하지만 모듈을 사용하면 하나의 `<script>` 태그만으로 모든 모듈화된 javascript 파일에 접근이 가능해져 효율적으로 코드를 관리할 수 있습니다.\r\n\r\n---\r\n\r\n## ⛓️ 파일 모듈화 하기\r\n\r\nJavascript 파일을 모듈화 하는 방식은 크게 2가지로 나뉩니다. **CommonJS**로 모듈화 하는 것과 **ES Module**로 모듈화하는 것입니다.\r\n<br />\r\n\r\n### CommonJS로 파일 내보내기/불러오기\r\n\r\nCommonJS는 NodeJS의 기본 모듈 시스템이며 모듈화가 되지 않고 표준 라이브러리가 없는 과거 javascript의 문제를 해결하기 위한 모듈화 방식입니다.\r\n\r\n주 키워드 : `module.exports`, `exports`, `require`\r\n\r\n- 파일 불러오기 : `require`\r\n- 여러 개의 객체를 내보낼 경우, `exports` 변수의 속성으로 할당\r\n- 딱 하나의 객체를 내보낼 경우, `module.exports` 변수 자체에 할당\r\n\r\n```javascript\r\n// main.js\r\nconst name = \"Joy\"\r\nconst age = 28\r\n//exports.name = name\r\n//exports.age = age\r\nmodule.exports = { name, age }\r\n\r\n// result.js\r\nconst { name, age } = require(\"./main.js\")\r\n```\r\n\r\n### ES Module로 파일 내보내기/불러오기\r\n\r\nES Module은 가장 대중적으로 사용되는 모듈 시스템입니다. 비동기 방식으로 작동하고 모듈에서 실제로 쓰이는 부분만 불러오기 때문에 성능과 메모리 부분에서 유리한 측면이 있습니다. 또한 직관적인 키워드를 사용해 가독성이 뛰어나고 `Named Parameter`와 같은 CommonJS에서는 지원하지 않는 기능들이 있습니다.\r\n\r\n주 키워드 : `import`, `export`, `from`, `default`\r\n\r\n```javascript\r\n// main.js\r\nexport const name = \"Joy\"\r\nexport const age = 28\r\nexport default function fullName(lastName) {\r\n  return name + lastName\r\n}\r\n\r\n// result.js\r\nimport fullName, { name, age } from \"./main.js\"\r\n```\r\n"},{"excerpt":"✔ npm npm : Node Package Manager(Modules) npm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다. ex)   명령어를 사용해 초기  파일을 만들고 프로젝트…","fields":{"slug":"/dev-npm/"},"frontmatter":{"date":"November 17, 2021","title":"프론트엔드 개발환경 #1 - npm / npx / yarn","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✔ npm\r\n\r\n> npm : Node Package Manager(Modules)\r\n\r\nnpm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다.\r\n\r\nex) `npm install webpack`\r\n\r\n`npm init` 명령어를 사용해 초기 `package.json` 파일을 만들고 프로젝트를 초기화합니다. npm을 통해 다운된 패키지는 `package.json`에 기록됩니다.\r\n<br />\r\n\r\n### npm의 단점\r\n\r\n- 로컬 컴퓨터에 직접 설치되어 용량 차지가 크다\r\n- 다운받은 패키지의 새 버전이 나온 경우, 업데이트를 직접 해주어야한다.\r\n\r\n---\r\n\r\n## ✔ npx\r\n\r\n> npx : Node Package Runner\r\n\r\nnpx는 npm 5.2.0 버전부터 새로 도입된 패키지 관리 도구입니다. npm 5.2.0 버전 이상을 다운받았다면 자동으로 설치되며 이는 npm을 좀더 편리하게 사용할 수 있도록 도와줍니다.\r\n\r\nex) `npx install webpack`\r\n<br />\r\n\r\n### npx의 장점\r\n\r\n- 패키지를 컴퓨터에 직접 저장하지 않고 일회성으로 패키지를 사용해 용량차지를 하지 않는다.\r\n- 매번 최신 업데이트된 패키지를 사용할 수 있다.\r\n  <br />\r\n\r\n### npx 동작방법\r\n\r\n1. 기본적으로, 실행할 패키지가 실행 가능한 경로에 있는지 확인한다. (예를 들면, 프로젝트내에서 다운된 패키지가 있는지 확인)\r\n2. 만약에 있다면, 그것을 실행한다.\r\n3. 아니라면 패키지가 설치가 되지 않았다는 것으로 판단하여, npx가 가장 최신 버전의 패키지를 설치하고 실행한다.\r\n\r\n---\r\n\r\n## ✔ yarn\r\n\r\nyarn은 npm과 같은 패키지 매니저입니다. 차이점이 있다면 Node.js 설치시에 함께 설치되지 않고 별도의 명령어를 사용해 설치합니다. yarn을 사용하면 `yarn.lock` 이라는 파일에 다운한 패키지가 기록되며 이 파일은 모든 디바이스에 같은 패키지를 설치하는 것을 보장합니다.\r\n\r\nyarn 설치 : `npm install -g yarn`\r\n\r\n```bash\r\n# npm 사용법\r\nnpm install <package>\r\nnpm uninstall <package>\r\n\r\n# yarn 사용법\r\nyarn add <package>\r\nyarn remove <package>\r\n```\r\n\r\n### yarn의 장점\r\n\r\n- 속도나 안전성은 npm과 비슷하나 npm보다 보안이 뛰어나고 의존성 관리를 강조한다.\r\n- 버전을 어디에서나 같게 만들어 버전 충돌에 의한 버그가 적다.\r\n\r\n### yarn의 단점\r\n\r\n- npm에 비해 레퍼런스가 적고 덜 보편적이다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}
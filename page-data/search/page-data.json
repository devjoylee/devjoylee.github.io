{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"🌟 Hook의 등장 배경 리액트 컴포넌트 종류 : Class Component / Functional Component Hook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없…","fields":{"slug":"/react-hook-about/"},"frontmatter":{"date":"December 22, 2021","title":"[React] React Hook이란?","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🌟 Hook의 등장 배경\r\n\r\n리액트 컴포넌트 종류 : **Class Component** / **Functional Component**\r\n\r\nHook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없었던 state관리나 Life Cycle Method가 가능하다는 이유로 어쩔 수 없이 Class Component를 사용해왔습니다.\r\n\r\nHook이 등장하기 전의 리액트는\r\n\r\n- 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어려웠습니다.\r\n\r\n- 생명주기 컴포넌트로 인한 복잡한 컴포넌트는 이해하기 어려웠습니다. 상태관련 로직이 모두 같은 공간에 위치하기 때문입니다.\r\n\r\n## 🧐 Hook 이란?\r\n\r\nHook은 리액트 16.8 버전 이후 함수형 컴포넌트에 추가된 기능입니다. 즉, React Hook은 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할 수 있도록 해주는 기능이며 Hook이 등장하면서 더 이상 상태를 관리하기 위해 Class Component를 쓸 필요가 없어졌습니다.\r\n\r\n기존에는 Class Component 에서만 상태를 관리 할 수 있었고, 함수형 컴포넌트에서는 상태를 관리할 수 없었습니다. 하지만 Hook이 등장하면서 함수형 컴포넌트 에서도 상태 관리를 할 수 있게 되었고, 상태 관리 뿐만 아니라 기존 클래스형 컴포넌트에서만 가능하던 여러 기능을 사용할 수 있게 되었습니다.\r\n\r\n👉 [React Hook 공식문서 바로가기](https://reactjs.org/docs/hooks-intro.html)\r\n\r\n## 🧾 Hook의 종류\r\n\r\n### useState\r\n\r\n가장 대표적인 Hook으로 상태값을 생성 및 업데이트시켜주는 Hook입니다.\r\n\r\n👉 [useState 더 알아보기](https://devjoylee.github.io/react-hook-useState)\r\n\r\n### useEffect\r\n\r\n컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정하는 Hook입니다.\r\n\r\n👉 [useEffect 더 알아보기](https://devjoylee.github.io/react-hook-useEffect)\r\n\r\n### useReducer\r\n\r\nuseState처럼 상태관리에 쓰이며 구조가 복잡한 상태관리에 적합한 Hook입니다.\r\n\r\n👉 [useReducer 더 알아보기](https://devjoylee.github.io/react-hook-useReducer)\r\n\r\n### useRef\r\n\r\n렌더링과 관련없는 값을 관리하거나 DOM에 접근이 필요한 경우 사용하는 Hook입니다.\r\n\r\n👉 [useRef 더 알아보기](https://devjoylee.github.io/react-hook-useRef)\r\n\r\n### useMemo\r\n\r\n렌더링 시 메모리에 값을 저장해두고 필요할 때 불러와서 사용할 수 있도록 하는 Hook입니다.\r\n\r\n👉 [useMemo 더 알아보기](https://devjoylee.github.io/react-hook-useMemo)\r\n\r\n### useCallback\r\n\r\nuseMemo와 비슷하나 값이 아닌 함수를 재사용하고자 할 때 사용하는 Hook입니다.\r\n\r\n👉 [useCallback 더 알아보기](https://devjoylee.github.io/react-hook-useCallback)\r\n\r\n### useContext\r\n\r\n전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 Hook입니다.\r\n\r\n👉 [useContext 더 알아보기](https://devjoylee.github.io/react-hook-useContext)\r\n\r\n<br />\r\n\r\n> REFERENCE<br /> React(23) 리액트 훅이란? https://devbirdfeet.tistory.com/52<br />리액트 공식 문서 https://reactjs.org/docs/hooks-intro.html<br/>[React] Hooks의 종류 https://lelana.tistory.com/146\r\n"},{"excerpt":"리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. () 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다! 리액트 시작하기 (CRA ❌) 1. 프…","fields":{"slug":"/react-scratch/"},"frontmatter":{"date":"December 21, 2021","title":"[React] 리액트 시작하기 (without CRA)","tags":["frontend","react"]},"rawMarkdownBody":"\r\n리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. (`npx create-react-app \"project-name\"`) 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다!\r\n\r\n## 리액트 시작하기 (CRA ❌)\r\n\r\n### 1. 프로젝트 폴더 생성 후 초기화\r\n\r\n원하는 경로에 프로젝트 폴더를 생성하고 프로젝트 초기화(`npm init -y`)를 진행합니다. 이때 `package.json`이라는 파일이 자동으로 생성되는데 이곳에 프로젝트 이름, 실행 명령어, 프로젝트에 필요한 라이브러리 등 관련 정보가 저장됩니다.\r\n\r\n```bash\r\nnpm init -y\r\n```\r\n\r\n### 2. 리액트 라이브러리 설치\r\n\r\n초기화가 끝나면 리액트 프로젝트에 필요한 패키지를 다운받습니다. 패키지 설치 방법은 아래와 같이 `npm install` 또는 `npm install --save-dev` 2가지 방식으로 가능합니다.\r\n\r\n✅ `npm i <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 해당 패키지 사용\r\n\r\n- package.json의 dependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i react react-dom\r\n```\r\n\r\n✅ `npm i --save-dev (or -D) <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 패키지 사용 ❌ (development mode에서만 사용)\r\n\r\n- package.json의 devDependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i -D @babel/core @babel/preset-env @babel/preset-react\r\nbabel-loader css-loader style-loader url-loader\r\nwebpack webpack-cli webpack-dev-server\r\nhtml-webpack-plugin\r\n```\r\n\r\n패키지 다운로드가 끝나면 프로젝트 폴더내부에 `node_modules` 폴더와 `package.lock.json` 파일이 새로 생성되고 (_yarn으로 설치한 경우_ `yarn.lock` _파일 생성_) `package.json`파일 내부에 아래와 같이 dependencies가 추가됩니다.\r\n\r\n![image](https://user-images.githubusercontent.com/68415905/154797755-7080fda7-541e-4ebf-a553-caa0ca4c79cc.png)\r\n\r\n### 3. `.babelrc` 파일 생성\r\n\r\n`babel` 이란 모든 브라우저에 호환이 가능하도록 최신 코드(ES6)를 구버전 코드(ES5)로 변환해주는 도구입니다. babel 설정을 위해서는 `.babelrc` 파일을 만들어 브라우저 호환에 필요한 babel 플러그인을 추가합니다. (preset : 필요한 플러그인 묶음)\r\n\r\n```bash\r\n// .babelrc\r\n{\r\n  presets: ['@babel/preset-env', '@babel/preset-react'],\r\n}\r\n```\r\n\r\n+) **webpack.config.js 파일 내부의 babel-loader의 옵션으로 추가한 경우 .babelrc 파일 생략 가능!!**\r\n\r\n### 4 . `webpack.config.js` 파일 생성\r\n\r\n`webpack`은 웹에서 사용되는 모든 자원(assets)을 묶음으로 번들링 해주는 도구입니다.\r\n\r\n웹팩을 사용하면 js 파일간의 종속성 뿐만 아니라 js 내에서 필요한 css나 img와 같은 파일(.css, .jpg)도 번들링해서 하나의 파일로 합쳐줘서 네트워크 요청을 최소화 시킬 수 있습니다.\r\n\r\n웹팩에 대해 자세히 알아보고 싶다면 링크를 참고해주세요!\r\n👉 [웹팩 포스팅 바로가기 ](https://devjoylee.github.io/dev-webpack-1)\r\n\r\n```jsx\r\n// webpack.config.js\r\nconst path = require(\"path\")\r\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: \"development\",\r\n  entry: \"./src/index.js\",\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"bundle.js\",\r\n    clean: true,\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx)$/,\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: \"babel-loader\",\r\n          options: {\r\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\r\n          },\r\n        },\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\"style-loader\", \"css-loader\"],\r\n      },\r\n      {\r\n        test: /\\.(jpg|png)$/i,\r\n        loader: \"url-loader\",\r\n        options: {\r\n          outputPath: \"images\",\r\n        },\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".js\", \".jsx\"],\r\n  },\r\n  devServer: {\r\n    static: path.join(__dirname, \"dist\"),\r\n    host: \"localhost\",\r\n    port: 3000,\r\n    open: true,\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: \"./public/index.html\",\r\n      inject: false,\r\n    }),\r\n  ],\r\n}\r\n```\r\n"},{"excerpt":"🧐 React란? React는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다. 다운로드 ✨ React의 필요성 사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 …","fields":{"slug":"/react-about/"},"frontmatter":{"date":"December 20, 2021","title":"[React] 리액트의 개념과 특징","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🧐 React란?\r\n\r\nReact는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다.\r\n\r\n![다운로드](https://user-images.githubusercontent.com/68415905/154801618-9bf1d698-3467-4f54-9df4-ebafce5b1e38.png)\r\n\r\n## ✨ React의 필요성\r\n\r\n사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 크고 UI 변화가 잦은 동적인 페이지라면 상태 변화 관리를 최소화 하고 DOM의 직접적인 업데이트를 막아주는 React 혹은 다른 프레임워크를 사용하는 것이 바람직합니다.\r\n\r\n## 🧾 React의 특징\r\n\r\n### 1. 단방향 데이터플로우\r\n\r\nReact는 데이터가 한방향으로만 이동하는 **단방향 데이터플로우**를 가집니다. 데이터가 UI로 이동하고 데이터가 변하면 UI도 함께 업데이트 되지만 반대로 UI쪽에서 데이터를 변화시키는 것은 불가능합니다. 단방향 데이터플로우를 사용하면 데이터 흐름이 간단해서 추적이 쉽고 예측이 가능해 유지보수가 편리하다는 장점이 있습니다.\r\n\r\n> ↔ 양방향 데이터 플로우 : 앵귤러(Angular.js) / 뷰(Vue.js)\r\n\r\n### 2. 가상돔(Virtual DOM)\r\n\r\nVirtual DOM이란 가상의 Document Object Model을 말합니다. 기존에는 javascript에서 DOM에 직접 접근하여 변화를 주는 방식을 사용하였는데 이경우 HTML,CSS,JS파일이 다시 리렌더링 되어 브라우저 내부에서 성능이슈가 발생했습니다.\r\n\r\nReact는 이런 단점을 보완하기 위해 Virtual DOM 이라는 것을 따로 만들었고 실제 DOM과 가상의 DOM을 비교하여 변화된 부분만 빠르게 업데이트 하는 방식을 사용하고 있습니다.\r\n\r\n**🔀 Virtual DOM 렌더링 순서**\r\n\r\n> JSX 수정 ➡ 가상 DOM 업데이트 ➡ 가상 DOM이 업데이트 되기 전과 비교하여 어떤 요소가 변경되었는지 확인 ➡ 가상 DOM에서 변경된 요소만 실제 DOM에서 업데이트\r\n\r\n### 3. Component 구조\r\n\r\n컴포넌트란 UI를 구성하는 개별 단위입니다. UI가 레고라면 컴포넌트는 하나의 블럭으로써 블럭을 쌓아 레고를 완성시키는 것처럼 컴포넌트를 조합하여 하나의 UI(페이지)를 만들 수 있습니다. 컴포넌트는 재사용이 가능하여 코드의 중복을 줄일 수 있고 효율적으로 유지보수를 할 수 있습니다.\r\n\r\n```js\r\nconst MainPage = () => {\r\n  return (\r\n    <Container>\r\n      <Header />\r\n      <MainContent>\r\n        <Section title=\"about\" />\r\n        <Section title=\"portfolio\" />\r\n      </MainContent>\r\n      <Footer />\r\n    </Container>\r\n  )\r\n}\r\n```\r\n\r\n### 4. JSX 문법\r\n\r\nJSX(Javascript + xml)는 Javascript에 대한 확장 구문으로서, Javascript를 좀더 편리하게 사용할 수 있도록 하는 Syntax Sugar 역할을 합니다. 이는 함수를 호출하거나 객체를 만들때 문법적인 편의를 제공하며 특히 DOM 요소를 만들 떄 `React.createElement()` 호출을 반복해야 하는 불편을 줄여줍니다. JSX는 React 엘리먼트를 생성하면서 자바스크립트의 모든 기능을 쓸 수 있도록 도와줍니다.\r\n\r\nJSX로 작성된 코드는 렌더링 시 Babel에 의해 자동으로 Javascript 코드로 컴파일됩니다.\r\n\r\n```jsx\r\n// jsx\r\n<MyButton color=\"blue\" shadowSize={2}>\r\n  Click Me\r\n</MyButton>\r\n```\r\n\r\n```jsx\r\n// javascript\r\nReact.createElement(\r\n  MyButton,\r\n  { color: \"blue\", shadowSize: 2 },\r\n  \"Click Me\"\r\n  //\r\n)\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br/>React란 무엇인가 https://firework-ham.tistory.com/5<br/>React란? https://velog.io/@jini_eun/React-React.js%EB%9E%80-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC\r\n"},{"excerpt":"✨ Webpack 등장 배경 이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게  을  태그에 추가하면 하나의  태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화) 👉 이전 포스팅 바로가기  image 하지만 안타깝게도 이런 모듈 시스템을 지원하는 브…","fields":{"slug":"/dev-webpack-1/"},"frontmatter":{"date":"November 29, 2021","title":"프론트엔드 개발환경 #3 - webpack이란?","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✨ Webpack 등장 배경\r\n\r\n이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게 `type=\"module\"` 을 `script` 태그에 추가하면 하나의 `script` 태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화)\r\n\r\n👉 [이전 포스팅 바로가기 ](https://devjoylee.github.io/dev-module)\r\n\r\n![image](https://images.velog.io/images/joyact/post/dfabe050-6ecc-4706-9e40-208164cb5621/image.png)\r\n\r\n하지만 안타깝게도 이런 모듈 시스템을 지원하는 브라우저는 한정되어 있습니다. 인터넷 익스플로러를 포함한 몇 브라우저는 여전히 모듈 시스템을 사용하지 않고있습니다. 따라서 모든 브라우저에 호환가능한 모듈링 시스템이 필요했고 이때 등장한 것이 **Webpack** 입니다.\r\n\r\n---\r\n\r\n## 🧐 Webpack이란?\r\n\r\n> Webpack : a module bundler\r\n\r\n![image](https://images.velog.io/images/joyact/post/d47c7828-ea1a-4844-bf88-d950f185899c/image.png)\r\n\r\n**웹팩(Webpack)**은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)입니다. 웹팩을 사용하면 여러개의 javascript 파일을 하나로 합쳐줌으로써 지저분한 `<script>` 태그의 반복 사용을 줄일 수 있고 효율적인 디버깅이 가능해집니다.\r\n\r\n또 다른 웹팩의 기능으로는 변환(transforming) 기능이 있습니다. ES6와 같은 모던 javascript를 ES5 형식으로 변환하고, Sass를 CSS로 변환시킴으로써 모든 브라우저가 이해할 수 있는 환경을 자체적으로 만들어냅니다.\r\n\r\n---\r\n\r\n## ➕ Webpack 설치\r\n\r\n1. npm install\r\n   `npm install webpack webpack-cli --save-dev`\r\n\r\n2. webpack.config.js 파일 생성\r\n   `module.exports` 내부에 필요한 configuration 옵션을 추가합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {}\r\n```\r\n\r\n---\r\n\r\n## 🚀 Webpack의 기능\r\n\r\n![image](https://images.velog.io/images/joyact/post/835b56bd-c22f-4fdf-b49f-57559b59a90d/Full-Stack-Introduction-to-Webpack.docx-2.jpg)\r\n\r\n모듈을 번들링하기 전, Webpack은 모듈 파일들을 그래프의 형식으로 인덱싱을 하게됩니다. 이를 **Dependency Graph**라고 하며 쉽게 말해 비슷한 형태의 파일을 하나로 묶기위해 분류하는 작업이라고 볼 수 있습니다.\r\n<br />\r\n\r\n### 기능1. The entry point\r\n\r\n![](https://images.velog.io/images/joyact/post/2afea557-9875-4a91-ac40-94117260cc6a/image.png)\r\n\r\nThe entry point는 Dependency Graph의 출발점이자 모듈 번들링을 시작하는 파일을 의미합니다. default 값은 `./src/index.js` 이며 직접 값을 지정하고 싶은경우 아래와 같이 configuration을 설정합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  entry: \"./app/index.js\",\r\n}\r\n```\r\n\r\n### 기능2. Loaders\r\n\r\n![image](https://images.velog.io/images/joyact/post/877e8797-5b3d-490e-9076-b428a968acf8/image.png)\r\n\r\nloader는 웹팩을 강력한 도구로 만들어주는 핵심 기능 중 하나입니다. 모듈에서 다루는 import, export 기능은 javascript와 json파일에만 국한되있는 것으로 css파일이나 image 파일을 다루게 되면 에러가 발생합니다. 하지만 loader를 사용하면 css, image 파일에도 접근이 가능하게 됩니다.\r\n\r\n1. 필요한 loader 설치\r\n\r\n   > **svg 파일 로더** : `npm install svg-inline-loader --save-dev` > **css 파일 로더** : `npm install style-loader css-loader --save-dev` > **js 파일 로더(es6->es5)** : `npm install babel-loader --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  rules: [\r\n    { test: /\\.svg$/, use: \"svg-inline-loader\" },\r\n    { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },\r\n    { test: /\\.(js)$/, use: \"babel-loader\" },\r\n  ],\r\n}\r\n```\r\n\r\n### 기능3. Output\r\n\r\nOutput은 번들링된 최종 파일 저장소를 뜻합니다. default 값으로 `dist/index.js` 가 설정이 되고 configuration 옵션에서 변경이 가능합니다.\r\n\r\n> **순서** : 모듈 번들링 ➡ dist 폴더 생성 ➡ dist 폴더 내부에 번들링된 최종 파일 저장\r\n> (생성된 파일 명은 옵션의 `filename`으로 지정)\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  output: {\r\n    path: path.resolve(__dirname, \"dist\"),\r\n    filename: \"index_bundle.js\",\r\n  },\r\n}\r\n```\r\n\r\n### 기능4. Plugin\r\n\r\nLoader가 각 모듈(파일)을 위한 기능이라면, Plugin은 최종 번들된 파일을 위한 기능을 수행합니다.\r\n\r\n- _**HtmlWebpackPlugin**_\r\n\r\n웹팩 번들링이 완료된 후 최종파일이 생성되면, 생성된 파일을 경로로 하는 `script` 태그가 추가된 index.html 파일을 만들어주는 플러그인입니다. 만약 output의 경로가 변경되더라도 직접 html을 수정할 필요없이 자동으로 script태그의 경로가 함께 업데이트 됩니다.\r\n\r\n1. 플러그인 설치\r\n   `npm install html-webpack-plugin --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n  // webpack.config.js\r\n\tconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\t...\r\n\tmodule.exports = {\r\n    \tplugins: [\r\n          new HtmlWebpackPlugin()\r\n        ]\r\n    }\r\n```\r\n\r\n![image](https://images.velog.io/images/joyact/post/ebea04b9-b261-4f62-911d-79da4c2a7635/image.png)\r\n\r\n> REFERENCE <br /> Youtube uidotdev Webpack Crash Course https://youtu.be/lFjinlwpcHY / <br /> 네이버 블로그 https://blog.naver.com/wlsdml1103/221333814197\r\n"},{"excerpt":"🧐 모듈(Module) 이란? Javascript를 공부하다보면 이라는 단어를 자주 접하게 됩니다.\nModule이란 코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n Module 사용 전 기존에는 html에  태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사…","fields":{"slug":"/dev-module/"},"frontmatter":{"date":"November 21, 2021","title":"프론트엔드 개발환경 #2 - 모듈 (Module)","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## 🧐 모듈(Module) 이란?\r\n\r\nJavascript를 공부하다보면 `Module`이라는 단어를 자주 접하게 됩니다.\r\nModule이란 **코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음**을 말하는데\r\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\r\n<br />\r\n\r\n### Module 사용 전\r\n\r\n```html\r\n<script src=\"./src/main.js\">\r\n<script src=\"./src/animation.js\">\r\n<script src=\"./src/banner.js\">\r\n```\r\n\r\n기존에는 html에 `<script>` 태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사용했습니다. 이 방식은 파일을 불러오는 순서가 코드에 영향을 주며, 생성한 파일의 object가 모두 전역 변수가되서 문제가 발생할 수 있다는 단점이 있습니다\r\n<br />\r\n\r\n### Module 사용 후\r\n\r\n```html\r\n<script type=\"module\" src=\"./src/main.js\">\r\n```\r\n\r\n하지만 모듈을 사용하면 하나의 `<script>` 태그만으로 모든 모듈화된 javascript 파일에 접근이 가능해져 효율적으로 코드를 관리할 수 있습니다.\r\n\r\n---\r\n\r\n## ⛓️ 파일 모듈화 하기\r\n\r\nJavascript 파일을 모듈화 하는 방식은 크게 2가지로 나뉩니다. **CommonJS**로 모듈화 하는 것과 **ES Module**로 모듈화하는 것입니다.\r\n<br />\r\n\r\n### CommonJS로 파일 내보내기/불러오기\r\n\r\nCommonJS는 NodeJS의 기본 모듈 시스템이며 모듈화가 되지 않고 표준 라이브러리가 없는 과거 javascript의 문제를 해결하기 위한 모듈화 방식입니다.\r\n\r\n주 키워드 : `module.exports`, `exports`, `require`\r\n\r\n- 파일 불러오기 : `require`\r\n- 여러 개의 객체를 내보낼 경우, `exports` 변수의 속성으로 할당\r\n- 딱 하나의 객체를 내보낼 경우, `module.exports` 변수 자체에 할당\r\n\r\n```javascript\r\n// main.js\r\nconst name = \"Joy\"\r\nconst age = 28\r\n//exports.name = name\r\n//exports.age = age\r\nmodule.exports = { name, age }\r\n\r\n// result.js\r\nconst { name, age } = require(\"./main.js\")\r\n```\r\n\r\n### ES Module로 파일 내보내기/불러오기\r\n\r\nES Module은 가장 대중적으로 사용되는 모듈 시스템입니다. 비동기 방식으로 작동하고 모듈에서 실제로 쓰이는 부분만 불러오기 때문에 성능과 메모리 부분에서 유리한 측면이 있습니다. 또한 직관적인 키워드를 사용해 가독성이 뛰어나고 `Named Parameter`와 같은 CommonJS에서는 지원하지 않는 기능들이 있습니다.\r\n\r\n주 키워드 : `import`, `export`, `from`, `default`\r\n\r\n```javascript\r\n// main.js\r\nexport const name = \"Joy\"\r\nexport const age = 28\r\nexport default function fullName(lastName) {\r\n  return name + lastName\r\n}\r\n\r\n// result.js\r\nimport fullName, { name, age } from \"./main.js\"\r\n```\r\n"},{"excerpt":"✔ npm npm : Node Package Manager(Modules) npm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다. ex)   명령어를 사용해 초기  파일을 만들고 프로젝트…","fields":{"slug":"/dev-npm/"},"frontmatter":{"date":"November 17, 2021","title":"프론트엔드 개발환경 #1 - npm / npx / yarn","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✔ npm\r\n\r\n> npm : Node Package Manager(Modules)\r\n\r\nnpm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다.\r\n\r\nex) `npm install webpack`\r\n\r\n`npm init` 명령어를 사용해 초기 `package.json` 파일을 만들고 프로젝트를 초기화합니다. npm을 통해 다운된 패키지는 `package.json`에 기록됩니다.\r\n<br />\r\n\r\n### npm의 단점\r\n\r\n- 로컬 컴퓨터에 직접 설치되어 용량 차지가 크다\r\n- 다운받은 패키지의 새 버전이 나온 경우, 업데이트를 직접 해주어야한다.\r\n\r\n---\r\n\r\n## ✔ npx\r\n\r\n> npx : Node Package Runner\r\n\r\nnpx는 npm 5.2.0 버전부터 새로 도입된 패키지 관리 도구입니다. npm 5.2.0 버전 이상을 다운받았다면 자동으로 설치되며 이는 npm을 좀더 편리하게 사용할 수 있도록 도와줍니다.\r\n\r\nex) `npx install webpack`\r\n<br />\r\n\r\n### npx의 장점\r\n\r\n- 패키지를 컴퓨터에 직접 저장하지 않고 일회성으로 패키지를 사용해 용량차지를 하지 않는다.\r\n- 매번 최신 업데이트된 패키지를 사용할 수 있다.\r\n  <br />\r\n\r\n### npx 동작방법\r\n\r\n1. 기본적으로, 실행할 패키지가 실행 가능한 경로에 있는지 확인한다. (예를 들면, 프로젝트내에서 다운된 패키지가 있는지 확인)\r\n2. 만약에 있다면, 그것을 실행한다.\r\n3. 아니라면 패키지가 설치가 되지 않았다는 것으로 판단하여, npx가 가장 최신 버전의 패키지를 설치하고 실행한다.\r\n\r\n---\r\n\r\n## ✔ yarn\r\n\r\nyarn은 npm과 같은 패키지 매니저입니다. 차이점이 있다면 Node.js 설치시에 함께 설치되지 않고 별도의 명령어를 사용해 설치합니다. yarn을 사용하면 `yarn.lock` 이라는 파일에 다운한 패키지가 기록되며 이 파일은 모든 디바이스에 같은 패키지를 설치하는 것을 보장합니다.\r\n\r\nyarn 설치 : `npm install -g yarn`\r\n\r\n```bash\r\n# npm 사용법\r\nnpm install <package>\r\nnpm uninstall <package>\r\n\r\n# yarn 사용법\r\nyarn add <package>\r\nyarn remove <package>\r\n```\r\n\r\n### yarn의 장점\r\n\r\n- 속도나 안전성은 npm과 비슷하나 npm보다 보안이 뛰어나고 의존성 관리를 강조한다.\r\n- 버전을 어디에서나 같게 만들어 버전 충돌에 의한 버그가 적다.\r\n\r\n### yarn의 단점\r\n\r\n- npm에 비해 레퍼런스가 적고 덜 보편적이다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}
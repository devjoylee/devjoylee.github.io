{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Chrome DevTools 디버깅 도구 Source 탭 활용하기 Chrome DevTools의 Network 탭이 데이터를 분석하고 오류의 원인을 찾기 위해 사용되었다면 Source 탭은 실제 코드를 확인하면서 디버깅하는 데 사용된다. 이때, breakpoint라는 기능을 사용하는데 이는 코드의 특정 지점에서 실행을 멈추고 상태를 점검할 수 있도록 도와…","fields":{"slug":"/debug02/"},"frontmatter":{"date":"June 27, 2024","title":"디버깅 환경 : 디버거의 Breakpoint를 활용한 문제 해결","tags":["frontend","development"]},"rawMarkdownBody":"\n## Chrome DevTools 디버깅 도구\n\n### Source 탭 활용하기\n\nChrome DevTools의 Network 탭이 데이터를 분석하고 오류의 원인을 찾기 위해 사용되었다면 Source 탭은 실제 코드를 확인하면서 디버깅하는 데 사용된다. 이때, breakpoint라는 기능을 사용하는데 이는 코드의 특정 지점에서 실행을 멈추고 상태를 점검할 수 있도록 도와준다. Breakpoint를 설정하고 활용하는 방법은 다음과 같다.\n\n### Breakpoint 설정\n\n1.  Source 탭 열기: Chrome DevTools의 상단 메뉴에서 Source 탭을 클릭한다.\n\n2.  파일 선택: 좌측 파일 탐색기에서 디버깅할 자바스크립트 파일을 선택한다.\n\n<img width=\"700\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/515eba12-cbe2-43b2-b3bf-346128bae645\" style=\"margin-left: 0\">\n\n<br/>\n\n3.  라인 번호 클릭: 디버깅하고 싶은 코드 라인의 번호를 클릭하면 파란색으로 표시되며 Breakpoint가 설정된다.\n\n<img width=\"590\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/fe04fc21-7f0f-4097-bdab-eccdb89005ae\" style=\"margin-left: 0\">\n\n### Breakpoint 활용\n\n1. breakpoint가 설정된 상태에서 페이지를 새로고침하면 코드가 해당 라인에서 멈춘다.\n\n2. 변수 확인: 하단의 Scope 섹션에서 breakpoint 기준으로 멈춘 시점의 모든 변수 상태를 확인할 수 있다.\n\n- `header` 변수는 breakpoint 이전에 있으므로 데이터가 들어온 상태\n- `response` 변수는 breakpoint로 실행이 멈춘 상태이므로 데이터 undefined.\n\n- `data` 변수는 breakpoint 이후에 있으므로 실행전이라 데이터 undefined.\n\n<img width=\"800\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/c6ec7d57-1b6f-4f5d-9c5d-9e6ade0461f0\" style=\"margin-left: 0\">\n\n<br/>\n\n3. 실행 제어: 컨트롤 바 <img width=\"150\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/81e02b97-1f11-4932-b627-89cb60cc74f0\" style=\"display: inline; margin-bottom: -8px;\">를 사용해 코드 실행을 제어할 수 있다.\n\n4. breakpoint 삭제 : 라인 번호를 다시 클릭하면 breakpoint가 삭제된다. <br/> 삭제하지않고 잠시 꺼두고 싶은 경우에는 아래처럼 체크를 해제하면 일시적으로 비활성화를 해둘 수 있다.\n\n<img width=\"438\" alt=\"Screenshot 2024-06-28 at 11 53 28 AM\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/44508bb1-8c0d-49f0-bca2-e93ab280eef0\" style=\"margin-left: 0\">\n\n### Control tool 종류\n\n1. Continue <img width=\"30\" alt=\"1\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/9c346029-88aa-404d-b0ec-e9a358d080e4\" style=\"display: inline; margin-bottom: -8px;\"> <br/> breakpoint에서 에러가 없을 경우 다음 breakpoint로 이동한다. 에러가 있으면 디버깅 모드를 멈추고 에러를 출력한다.\n\n2. Step Over <img width=\"30\" alt=\"2\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/10a45292-8c89-4a15-b174-c9b2c37bad36\" style=\"display: inline; margin-bottom: -8px;\"><br/> 현재 줄을 실행하고 다음 줄로 넘어간다. 함수를 만나면 실행만 하고 함수 내부 탐색없이 다음 줄로 이동한다. <br/> 함수의 동작을 전체적으로 보고 싶지만 함수 내부를 자세히 조사할 필요가 없을 때 사용한다.\n\n```js\nfunction main() {\n  // breakpoint\n  let result = math(5, 3) // step 1\n  console.log(\"결과는\" + result) // step 2\n}\n\nfunction math(a, b) {\n  console.log(a + b)\n  console.log(a - b)\n  console.log(a / b)\n}\n```\n\n3. Step Into (함수 내부) <img width=\"30\" alt=\"3\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/f06b2cbf-ba3d-49da-bcbd-c3ece979d0e7\" style=\"display: inline; margin-bottom: -8px;\"> <br/> 현재 줄을 실행하고 다음 줄로 넘어간다. 함수를 만나면 함수 내부로 들어가서 해당 함수의 첫번째 줄에서 멈춘다. <br/> 함수의 내부 동작을 자세히 조사하고 싶을 때 사용한다.\n\n```js\nfunction main() {\n  // breakpoint\n  let result = math(5, 3) // step 1\n  console.log(\"결과는\" + result) // step 5\n}\n\nfunction math(a, b) {\n  console.log(a + b) // step 2\n  console.log(a - b) // step 3\n  console.log(a / b) // step 4\n}\n```\n\n4. Step Out (함수 밖으로) <img width=\"30\" alt=\"4\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/74155ea7-0157-406f-a01d-7df6c8cfd1a3\" style=\"display: inline; margin-bottom: -8px;\"><br/>현재 디버깅 중인 함수의 나머지 코드를 한꺼번에 실행하고 함수를 빠져나온다. <br/>현재 함수에서 나와 함수 호출 지점으로 돌아가고 싶을 때 사용한다.\n\n5. Step (다시 시작) <img width=\"30\" alt=\"5\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/efc4399f-fcaf-45af-8d71-20a9c029f32f\" style=\"display: inline; margin-bottom: -8px;\"><br/> 실행을 중단한 후 다시 실행을 시작한다. 다음 breakpoint나 예외가 발생할 때까지 코드를 계속 실행한다.\n\n### Breakpoint 조건 추가\n\n1. 라인 번호를 우클릭하고 Add conditional breakpoint를 선택한다.\n\n2. Breakpoint가 활성화될 조건을 입력한다. 예를 들어, `i === 5`와 같이 특정 조건에서만 멈추도록 설정할 수 있다.\n\n<br />\n<br />\n<br />\n\n> REFERENCE<br /> 아직도 console.log써서 디버깅 한다고? | 브라우저 디버깅하는 법 https://www.youtube.com/watch?v=C4poqiG8ulM\n"},{"excerpt":"디버깅이란? (Debugging) 디버깅은 코드가 예상대로 동작하지 않을 때 오류가 나는 부분을 찾아 원인을 파악하고 해결하는 전체적인 과정을 뜻한다. 디버깅하는 방법  는 대표적인 디버깅 방법이다. console.log()로 코드의 동작을 확인하고 데이터 흐름을 추적할 수 있다. 하지만 무분별한 console.log()의 사용은 코드의 가독성을 떨어트리…","fields":{"slug":"/debug01/"},"frontmatter":{"date":"June 26, 2024","title":"디버깅 환경 : Chrome DevTools로 에러 발생 원인 파악하기","tags":["frontend","development"]},"rawMarkdownBody":"\n## 디버깅이란? (Debugging)\n\n> 디버깅은 코드가 예상대로 동작하지 않을 때 오류가 나는 부분을 찾아 원인을 파악하고 해결하는 전체적인 과정을 뜻한다.\n\n## 디버깅하는 방법\n\n### `console.log()`\n\n`console.log()`는 대표적인 디버깅 방법이다. console.log()로 코드의 동작을 확인하고 데이터 흐름을 추적할 수 있다.\n\n```js\n// 👇 console.log() 지옥\nconst example = async () => {\n  try {\n    console.log(\"작동 중\")\n    let header = new Headers({})\n    let response = await fetch(url, { headers: header })\n    console.log(\"response는 뭐지?\", response)\n\n    let data = await response.json()\n    console.log(\"받는 데이터가 뭐지?\", data)\n  } catch (error) {\n    console.log(\"에러 발생!\", error.message)\n  }\n}\n```\n\n<br/>\n\n하지만 무분별한 console.log()의 사용은 코드의 가독성을 떨어트리고 브라우저의 콘솔창에 그대로 노출되어 보안유지에 취약하다.\n\n<img width=\"500\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/6dedf002-23f8-4114-864e-e3cc20686af3\" style=\"margin-left: 0\">\n\n### Chrome DevTools\n\n대부분의 브라우저는 강력한 디버깅 도구를 제공한다. 그 중에도 가장 보편적으로 쓰이는 것이 Chrome의 DevTools이다. <br/> 브라우저에서 `F12` (Windows) 또는 `Option + Command + J` (Mac) 키를 누르면 도구창이 열린다.\n\nDevTools의 Network 탭을 이용하면 console.log를 사용하지 않아도 네트워크 요청과 응답 데이터를 자세히 확인할 수 있다. 이를 통해 어떤 데이터가 주고받는지, 요청이 성공했는지 또는 실패했는지를 쉽게 알 수 있다. 에러가 발생했을 때 Network 탭을 활용하면 요청의 상태 코드, 헤더, 페이로드, 응답 내용을 확인할 수 있어 문제의 원인을 보다 정확하게 분석하고 신속하게 해결할 수 있다.\n\n## Devtools 네트워킹 분석 도구\n\n### Network 탭 활용하기\n\n1. 먼저 Network 탭으로 이동하고 페이지를 새로고침하면 브라우저가 내려받은 파일이 순서대로 출력된다. <br/>각 파일의 Status를 통해 정상 작동 여부(200)나 에러 발생 여부(404)를 확인할 수 있다.\n\n2. 파일을 클릭하면 해당 파일이 가진 데이터를 자세히 살펴볼 수 있다.\n\n3. 데이터를 확인하며 발생한 에러의 원인을 분석한다.\n\n<img width=\"700\" alt=\"\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/1af48878-d83d-47e7-9848-f1d15973b077\" style=\"margin-left: 0\">\n\n### Network 탭 상세 설명\n\n- Headers 탭 : 서버에 요청한 데이터의 Header 값 ex) URL, 상태 코드\n  <img width=\"828\" alt=\"Screenshot 2024-06-27 at 2 32 21 PM\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/dcb9d9d7-d148-43d6-bd6e-65f9bd6b2286\" style=\"margin-left: 0\">\n\n- Payload : 서버에 요청한 쿼리 데이터 정보 확인\n  <img width=\"745\" alt=\"Screenshot 2024-06-27 at 2 33 17 PM\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/ce96e777-239a-432e-b250-ef2669123e4f\" style=\"margin-left: 0\">\n\n- Preview / Response : 서버에서 반환한 데이터 정보. 에러가 있는 경우 에러메세지 반환\n  <img width=\"750\" alt=\"Screenshot 2024-06-27 at 2 33 42 PM\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/02c138d4-a758-4dfd-b408-d33ee31e4357\" style=\"margin-left: 0\">\n\n  <img width=\"750\" alt=\"Screenshot 2024-06-27 at 2 33 32 PM\" src=\"https://github.com/devjoylee/toyota_display_ads/assets/68415905/9a4aaac5-2d05-481c-9c09-56a4be29770c\" style=\"margin-left: 0\">\n\n<br />\n<br />\n<br />\n\n> REFERENCE<br /> 아직도 console.log써서 디버깅 한다고? | 브라우저 디버깅하는 법 https://www.youtube.com/watch?v=C4poqiG8ulM\n"},{"excerpt":"1. lint-staged : 에러 판독기 git에서 staged된 상태 파일들에 한해 lint를 실행하여 커밋 전에 코드 스타일을 검사하고 수정하는 도구 협업 환경에서는 모든 개발자가 일관된 코드 품질을 유지하는 것이 중요하다. 하지만 개발 환경이 모두 다르기때문에 코드 스타일 규칙이 지켜지지 않는 경우가 종종 발생한다. 이러한 문제를 해결하기 위해 l…","fields":{"slug":"/husky/"},"frontmatter":{"date":"May 21, 2024","title":"협업을 위한 프로젝트 설정 - husky + lint-staged","tags":["frontend","development"]},"rawMarkdownBody":"\n## 1. lint-staged : 에러 판독기\n\n> git에서 staged된 상태 파일들에 한해 lint를 실행하여 커밋 전에 코드 스타일을 검사하고 수정하는 도구\n\n협업 환경에서는 모든 개발자가 일관된 코드 품질을 유지하는 것이 중요하다. 하지만 개발 환경이 모두 다르기때문에 코드 스타일 규칙이 지켜지지 않는 경우가 종종 발생한다. 이러한 문제를 해결하기 위해 lint-staged와 husky를 함께 사용하여 프로젝트에 자동화된 linting 프로세스를 설정할 수 있다.\n\n### 설치 및 설정\n\n1. lint-staged 를 설치한다.\n\n```bash\nnpm i -D lint-staged\n```\n\n2. package.json에 아래와 같이 lint-staged 설정을 추가한다.<br/>\n   (src 디렉토리 내의 js 및 ts 파일에 대해 eslint와 prettier를 순차적으로 실행하여 코드 포맷팅 및 스타일 검사를 수행)\n\n```json\n\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix --max-warnings=0\", // warn, error가 둘다 없을때만 통과\n      // \"eslint --fix\",  // error가 없으면 통과 (warn은 패스)\n      \"prettier --write\"\n    ]\n  }\n```\n\n3. 아래 명령어로 lint-staged를 실행한다. (staged 상태인 파일만 검사)\n\n```bash\nnpx lint-staged\n```\n\n<br/>\n\n## 2. husky : pre-commit 실행도구\n\nhusky는 git hook을 관리하고 설정하는 도구로 코드가 커밋되기 전에 필요한 작업을 자동으로 실행한다 (pre-commit). <br/> 즉, husky를 사용하여 커밋 할 때마다 자동으로 lint-staged를 실행시켜 코드를 검사할 수 있다. <br/>\n\n### 설치 및 설정\n\n1. husky를 설치한다.\n\n```bash\n# husky 초기화 (.husky 폴더 생성)\nnpx husky-init && npm install\n\n# husky - Git hooks install\nnpx husky install\n```\n\n</br>\n\n2. package.json에 아래 명령어가 추가된 것을 확인한다.\n\n```json\n\"scripts\": {\n    \"prepare\": \"husky install\"\n},\n```\n\n</br>\n\n3. `.husky > pre-commit` 파일을 아래 내용처럼 작성한다.\n\n```bash\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n```\n\n### 작동 방식\n\n1. staged 상태의 코드를 커밋한다.\n2. Husky가 pre-commit 훅을 실행시킨다.\n3. pre-commit에 저장된 lint-staged 명령어가 실행된다\n4. lint-staged가 실행되어 스테이지 상태의 파일들에 대해 eslint와 prettier 검사를 수행한다.\n5. 에러 혹은 경고가 발견되면 커밋이 취소되고 오류 메시지가 출력된다.\n\n<img width=\"870\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/ea0d4b38-80b6-41bd-986f-8d919b5411b2\">\n\n<br/>\n<br/>\n\n> REFERENCE<br /> How to Install Commitlint & Husky [2024] https://medium.com/@abpeter14/how-to-install-commitlint-husky-2024-f1157f14006f > <br/>ESLint with VSCode, Prettier, Husky and React https://www.youtube.com/watch?v=ZXW6Jn6or1w&t=159s\n"},{"excerpt":"prettier Prettier는 코드를 정해진 스타일로 교정해주는 도구이다. 주로 ESLint와 함께 사용되며 ESLint를 통해 에러를 최소화하여 코드 품질을 높이고 prettier를 통해 코드 스타일을 자동 포맷팅하여 코드의 가독성과 일관성을 높인다. prettier 설치 prettier config 추가  파일을 생성하고 다음과 같은 규칙을 추가한…","fields":{"slug":"/prettier/"},"frontmatter":{"date":"May 12, 2024","title":"협업을 위한 프로젝트 설정 - Prettier","tags":["frontend","development"]},"rawMarkdownBody":"\n## prettier\n\nPrettier는 코드를 정해진 스타일로 교정해주는 도구이다. 주로 ESLint와 함께 사용되며 ESLint를 통해 에러를 최소화하여 코드 품질을 높이고 prettier를 통해 코드 스타일을 자동 포맷팅하여 코드의 가독성과 일관성을 높인다.\n\n### prettier 설치\n\n```bash\nnpm i prettier --save-dev\n```\n\n### prettier config 추가\n\n`.prettierrc` 파일을 생성하고 다음과 같은 규칙을 추가한다. (관련 문서 : https://prettier.io/docs/en/options.html)\n\n```json\n{\n  \"singleQuote\": true,\n  \"semi\": false,\n  \"tabWidth\": 2,\n  \"printWidth\": 80,\n  \"endOfLine\": \"auto\"\n}\n```\n\n### ESLint와 Prettier의 차이점\n\n- **ESLint**: 주로 코드 품질을 개선하고 오류를 방지하기 위해 사용된다. 문법 오류, 잠재적 버그, 스타일 등을 검사하여 알려준다.\n- **Prettier**: 코드 스타일과 관련된 들여쓰기, 공백, 따옴표 사용 등을 규칙에 맞게 자동으로 수정해준다.\n\n### ESLint 충돌 방지 설정하기\n\nESLint와 prettier의 설정 중에는 스타일과 관련된 비슷한 규칙이 있어서 종종 두가지 규칙이 충돌하는 일이 생긴다.<br/> 이를 방지하기 위해 아래와 같은 플러그인을 추가해서 충돌을 막아준다.\n\n1. `eslint-config-prettier`: prettier를 ESLint plugin에 추가. prettier가 인식한 에러를 ESLint 에러로 출력시켜준다.\n2. `eslint-plugin-prettier`: ESLint rule 중에서 prettier와 충돌하는 부분을 비활성화할 수 있다.\n\n<br/>\n\n- 플러그인 설치하기\n\n```bash\nnpm i -D eslint-config-prettier eslint-plugin-prettier @types/eslint-config-prettier\n```\n\n- `eslint.config.js`에 prettier 설정 추가하기 (주의! prettier 규칙은 eslint 규칙 마지막부분에 작성한다)\n\n```js\nimport prettierConfig from \"eslint-config-prettier\"\nimport pluginPrettier from \"eslint-plugin-prettier\"\n\nexport default [\n  // ...\n  {\n    plugins: {\n      prettier: pluginPrettier, // 'prettier' 플러그인 추가\n    },\n  },\n  {\n    rules: {\n      // ...\n      // 가장 아래에 작성\n      ...prettierConfig.rules, // prettier와 eslint 규칙 병합\n      \"prettier/prettier\": \"error\", // prettier 규칙에 어긋나면 eslint 에러발생\n    },\n  },\n]\n```\n\n### VSCode formatter 설정\n\n1. VSCode Extension에서 'Prettier - Code formatter' 플러그인 설치\n2. VSCode setting → Defalut Formatter 검색 → 'Prettier - Code formatter' 선택\n\n<img width=\"800\" alt=\"Screenshot 2024-06-21 at 6 03 03 PM\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/b3bb3d93-d6eb-4f41-9aa0-15e522a24c7e\">\n\n3. VSCode setting → `formatOnSave` 검색 후 체크 <br/>(formatOnSave 를 설정해두면 파일을 저장할 때마다 prettier 포맷이 실행되어 코드 가독성을 올려준다.)\n\n<img width=\"800\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/b9cf8e4b-5358-4973-9c21-6d2f6e9ba7ff\">\n"},{"excerpt":"ESLint ESLint는 JavaScript/Typescript 코드에서 문법 오류를 검사하고 코드 최적화를 도와주는 도구이다.  ESLint를 사용하면 코드 품질을 높이고 일관된 코드를 작성할 수 있어 협업 환경에서 주로 사용된다. Lint란? 소스코드를 분석하여 문법적인 오류나 스타일적인 오류, 적절하지 않은 구조 등에 표시를 달아주는 행위. ESL…","fields":{"slug":"/eslint/"},"frontmatter":{"date":"May 10, 2024","title":"협업을 위한 프로젝트 설정 - ESLint","tags":["frontend","development"]},"rawMarkdownBody":"\n## ESLint\n\nESLint는 JavaScript/Typescript 코드에서 문법 오류를 검사하고 코드 최적화를 도와주는 도구이다. <br/> ESLint를 사용하면 코드 품질을 높이고 일관된 코드를 작성할 수 있어 협업 환경에서 주로 사용된다.\n\n> Lint란? 소스코드를 분석하여 문법적인 오류나 스타일적인 오류, 적절하지 않은 구조 등에 표시를 달아주는 행위.\n\n### ESLint 사용 예시\n\n```jsx\n// 예시 1: 일관된 코드 스타일 유지 (따옴표, 들여쓰기, 세미콜론 등)\nconst obj = {\n  firstname: \"Joy\", // single 따옴표가 아니면 에러\n  lastname: 'Lee'\n}\n\n// 예시 2: 문법 오류 감지\nconst x = 10\nx = 5 // const 변수는 재할당 불가능 (Error)\n\n// 예시 3: 사용하지 않는 변수 경고\nfunction add(a, b) {\n  const result = a + b // result 변수가 사용되지 않음 (warning)\n  return a + b\n}\n\n// 예시 4: 코드 최적화\nif (isAvailable === true) {..} // ❌\nif (isAvailable) {..} // ⭕️\n\n// 예시 5: React prop-types 검사\n// prop의 name 타입 명시하지 않음 (warning)\nexport const MyComponent = ({ name }) => {\n  return <div>Hello, {name}</div>\n}\n```\n\n### ESLint 설치 및 실행\n\n- 설치하기\n\n```bash\nnpm init @eslint/config\n```\n\n- 실행하기 : package.json 파일의 scripts란에 아래 명령어를 추가한 후, 터미널에서 `npm run lint` 로 실행시킨다.\n\n```bash\n  \"scripts\": {\n    // ...\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint --fix .\"\n  },\n```\n\n### ESLint config 파일\n\nESLint 관련 규칙은 config 파일을 사용하여 자유롭게 설정할 수 있다. <br/> ESLint ver7 까지는 config 파일로 `.eslintrc` 를 사용했으나 ver.8부터는 `eslint.config.js` 파일에서 config를 작성한다.<br/> (참고 : https://github.com/jsx-eslint/eslint-plugin-react#configuration)\n\n```jsx\n// eslint.config.mjs\nimport globals from \"globals\"\nimport pluginJs from \"@eslint/js\"\nimport tseslint from \"typescript-eslint\"\nimport pluginReactConfig from \"eslint-plugin-react/configs/recommended.js\"\nimport { fixupConfigRules } from \"@eslint/compat\"\n\nexport default [\n  // 모든 JavaScript, TypeScript 및 JSX/TSX 파일에 대해 설정 적용\n  { files: [\"**/*.{js,mjs,cjs,ts,jsx,tsx}\"] },\n  {\n    languageOptions: {\n      parserOptions: {\n        // JSX 구문 분석을 위한 파서 옵션 설정\n        ecmaFeatures: { jsx: true },\n        ecmaVersion: 2021,\n        sourceType: \"module\",\n      },\n      globals: globals.browser, // 브라우저 전역 변수 추가\n    },\n  },\n\n  pluginJs.configs.recommended, // ESLint 기본 규칙 적용\n  ...tseslint.configs.recommended, // TypeScript 관련 규칙 적용\n  ...fixupConfigRules(pluginReactConfig), // React 관련 규칙 적용\n\n  {\n    settings: {\n      react: { version: \"detect\" }, // React 버전을 자동으로 감지\n    },\n  },\n  {\n    // 추가 규칙 설정 (custom 가능)\n    rules: {\n      \"no-console\": \"warn\", // console.log 사용 경고\n      semi: [\"error\", \"always\"], // 세미콜론 필수\n      quotes: [\"error\", \"single\"], // 작은따옴표 사용\n      indent: [\"error\", 2], // 들여쓰기 2칸\n      \"no-unused-vars\": \"warn\", // 사용하지 않는 변수 경고\n      \"react/prop-types\": \"off\", // React prop-types 사용 안함\n      \"@typescript-eslint/no-unused-vars\": [\"warn\"], // TypeScript 사용하지 않는 변수 경고\n    },\n  },\n]\n```\n"},{"excerpt":"리스트 (List) List는 sequence라고도 불리며 \"순서\"를 가지고 원소를 저장하는 자료구조이다.\nList 구현은 크게 2가지로 나뉘는데 Array List와 Linked List가 있다. python에서 사용하는  자료구조는 Array List 형태이다. Array List Array List는 말 그대로 배열을 기반으로 만들어진 자료구조이다.…","fields":{"slug":"/data-structure04/"},"frontmatter":{"date":"February 16, 2024","title":"[Data Structure] List - Array & Dynamic Array ","tags":["datastructure"]},"rawMarkdownBody":"\n## 리스트 (List)\n\nList는 sequence라고도 불리며 \"순서\"를 가지고 원소를 저장하는 자료구조이다.\nList 구현은 크게 2가지로 나뉘는데 Array List와 Linked List가 있다. python에서 사용하는 `list` 자료구조는 Array List 형태이다.\n\n<img width=\"600\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee/assets/68415905/f52de651-75d7-495d-b3cd-0c17ea8f35d7\">\n\n## Array List\n\nArray List는 말 그대로 배열을 기반으로 만들어진 자료구조이다. <br/> 크기가 고정된 static array와 크기 변화를 줄 수 있는 dynamic array가 있다.\n\n## 1. Static Array\n\n> **정적 배열 (Static Array)** : 정해진 size만큼 **연속된 메모리**를 할당 받아 data를 순차적으로 저장하는 자료구조\n\n### 배열의 특성\n\n1. 고정된 저장 공간(fixed-size)\n2. 순차적인 데이터 저장(order)\n\n예시)\n\n```c\nint arr[5] = {3, 7, 4, 2, 6} // size가 5인 int형 배열 선언\n```\n\n배열이 선언되면 데이터를 저장할 메모리 공간을 먼저 확보한다.<br/> \n→ int형 데이터 5개를 가진 배열을 만들기 위해서는 총 20 byte의 공간이 필요하다. `4byte(int형 데이터) * 5(size) = 20 byte`<br/> \n→ 첫 번째 값부터 순차적으로 메모리에 저장한다.\n\n<img width=\"1000\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee/assets/68415905/4030bf8d-0d9f-4672-9eb3-400578d18288\">\n\n\n### Random Access\n\n**Random Access**는 자료 구조에서 특정 데이터에 직접 접근할 수 있는 능력을 의미한다.\n\n배열(Array)은 대표적인 random access 가능한 데이터 구조이다. 일반적으로 데이터에 접근하려면 해당 데이터의 메모리 주소값을 알아야 한다. 배열에 저장된 값은 메모리에 연속적으로 할당되기 때문에 배열의 첫 주소값만 알면 어떤 index에도 바로 접근할 수 있다. `(첫 주소값 + index)` \n\n즉 O(1)의 시간복잡도로 접근이 가능하다.\n\n<br/> \n\n## 2. Dynamic Array\n\n> 동적 배열 (Dynamic Array) : 배열의 크기(size)를 변경(resizing)할 수 있는 배열\n\n데이터의 갯수가 정해져 있을 때는 static array를 사용하는 것이 매우 효율적이다. 하지만 배열 크기보다 더 많은 데이터를 저장해야 하는 경우에는 공간 부족으로 문제가 발생할 수 있다. 이런 문제를 보안하기 위해서 Dynamic Array 방식이 사용된다.\n\n### Resizing 과정\n\n기존 배열의 할당된 크기를 초과하여 데이터가 생성된 경우 배열을 resize하는 과정은 다음과 같다:\n\n1. **데이터 추가 요청**: 동적 배열에 새로운 데이터를 추가하려고 합니다.\n2. **배열 size 초과 확인**: 현재 배열의 크기가 새로운 데이터를 추가하기에 충분한지 확인합니다.\n3. **다른 위치에 새로운 배열 생성 (더블링)**: 기존 배열의 크기의 2배인 새로운 배열을 메모리에 생성합니다.\n4. **기존 데이터 복사**: 기존 배열의 모든 데이터를 새로운 배열로 복사합니다.\n5. **새로운 배열에 데이터 추가**: 새로운 배열의 적절한 위치에 새로운 데이터를 추가합니다.\n6. **기존 배열 삭제 (free)**: 메모리에서 기존 배열을 해제(free)합니다.\n\n### 배열 연산과 시간복잡도\n\n배열 크기를 명시하지 않아도 되는 dynamic array는 코딩테스트에서 자주 사용된다. 그 예로 Python에는 dynamic array로 구현된 `list` 자료형이 있다. `list`의 연산과 해당하는 시간복잡도는 아래와 같다.\n\n|  | Static array | Dynamic array |\n| --- | --- | --- |\n| access / update | $O(1)$ | $O(1)$ |\n| insert_back | $O(1)$ | amortized $O(1)$ |\n| delete_back | $O(1)$ | $O(1)$ |\n| insert_at | $O(n)$ | $O(n)$ |\n| delete_at | $O(n)$ | $O(n)$ |\n\n**리스트의 선언** : `a = [1, 2, 3]`\n\n**리스트 접근하기**\n\n- 0번째 원소 접근 하기 : `a[0]` → $O(1)$\n- 0번째 원소 업데이트 하기 : `a[0] = 3` → $O(1)$\n\n**리스트의 원소 추가**\n\n- 마지막에 원소 추가 : `a.append(1)` → $O(1)$\n- 중간에 원소 추가 : `a.insert(2,10)` → $O(n)$\n    \n    ⇒ 2번째 index에 10을 추가한다\n    \n\n**리스트 원소 삭제**\n\n- 마지막 원소 삭제 : `a.pop()` → $O(1)$\n- 중간 원소 삭제 : `a.pop(2)` / `a.remove(2)` → $O(n)$\n    \n    ⇒ `pop(2)` : 2번째 index에 있는 값을 삭제\n    \n    ⇒ `remove(2)` : 값 ‘2’를 찾아서 삭제. 없으면 error\n"},{"excerpt":"메모리 구조란? 메모리는 데이터를 저장하는 공간으로, 프로그램의 성능을 최적화하기 위해 메모리 구조를 잘 이해하고 적절한 자료구조를 사용하는 것이 중요하다. 메모리: 데이터를 저장하는 곳으로, 전기신호를 0과 1로 저장하는 트랜지스터로 이루어져 있다. RAM 메모리: 휘발성 메모리로, 0과 1로 이루어진 이진수(bit)를 저장한다. 메모리 단위와 자료형 …","fields":{"slug":"/data-structure03/"},"frontmatter":{"date":"January 21, 2024","title":"[Data Structure] 메모리 구조와 Node의 주소값","tags":["datastructure"]},"rawMarkdownBody":"\n## 메모리 구조란?\n\n메모리는 데이터를 저장하는 공간으로, 프로그램의 성능을 최적화하기 위해 메모리 구조를 잘 이해하고 적절한 자료구조를 사용하는 것이 중요하다.\n\n- **메모리**: 데이터를 저장하는 곳으로, 전기신호를 0과 1로 저장하는 트랜지스터로 이루어져 있다.\n- **RAM 메모리**: 휘발성 메모리로, 0과 1로 이루어진 이진수(bit)를 저장한다.\n\n### 메모리 단위와 자료형 크기\n\n- **비트(bit)**: 메모리의 가장 작은 단위로, 0 또는 1을 나타낸다.\n- **바이트(byte)**: 8비트로 이루어진 단위이다.\n    - **int**: 4 bytes\n    - **char**: 1 byte\n\n### 메모리 단위 변환\n\n- 1 byte = 8 bits\n- 1 KB = 1024 bytes\n- 1 MB = 1024 KB\n- 1 GB = 1024 MB\n\n### 2진수와 16진수\n\n이진수는 16진수로 변환할 수 있으며, 2진수 4자리는 16진수 1자리로 표현된다.\n\n예) 2진수 `1010` = 16진수 `A`\n\n## Node란?\n\n<img width=\"600\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/5ef66f19-e3d0-40b9-8e0a-7d6b5416a49a\">\n\nNode는 데이터를 저장하는 데 사용되는 기본적인 구조체이다. 다음 데이터의 주소값을 함께 저장하여 연결 리스트 등 다양한 자료구조를 구현하는 데 사용된다.\n\n### Node의 구조\n\nNode는 보통 다음과 같은 구조를 가진다. `value`는 해당 노드의 데이터를, `next`는 다음 노드의 주소를 가리킨다. 이때, 주소값은 16진수로 저장한다.\n\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value  # 데이터 값\n        self.next = None    # 다음 노드를 가리키는 포인터\n```\n\n### Node의 활용 예시\n\n- 연결 리스트(Linked List): 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성되어 있다.\n- 트리(Tree): 각 노드는 자식 노드들과의 연결을 나타내기 위해 사용된다.\n- 그래프(Graph): 각 노드는 그래프의 정점을 나타내며, 인접한 노드들과의 관계를 링크 필드를 통해 저장한다.\n"},{"excerpt":"시간 복잡도란? 시간 복잡도는 알고리즘이 처리하는 입력 크기 n에 따라 소요되는 시간을 \"Big-O 표기법\"으로 나타낸 것이다. 이를 통해 알고리즘의 성능을 분석하고 비교할 수 있으며, 특히 대용량 데이터를 다룰 때 어떤 알고리즘이 더 효율적인지 판단하는 데 중요한 기준이 된다. 시간 복잡도 cases Best Case: 가장 이상적인 입력의 시간 복잡도…","fields":{"slug":"/data-structure02/"},"frontmatter":{"date":"January 10, 2024","title":"[Data Structure] 시간 복잡도와 Big-O 표기법","tags":["datastructure"]},"rawMarkdownBody":"\n## 시간 복잡도란?\n\n시간 복잡도는 알고리즘이 처리하는 입력 크기 n에 따라 소요되는 시간을 \"Big-O 표기법\"으로 나타낸 것이다. 이를 통해 알고리즘의 성능을 분석하고 비교할 수 있으며, 특히 대용량 데이터를 다룰 때 어떤 알고리즘이 더 효율적인지 판단하는 데 중요한 기준이 된다.\n\n### 시간 복잡도 cases\n\n- **Best Case**: 가장 이상적인 입력의 시간 복잡도. 예) 정렬 알고리즘에서 이미 정렬된 배열을 입력으로 받는 경우\n- **Average Case**: 모든 입력 값에 대한 평균 수행 시간.\n- **Worst Case**: 가장 느리게 동작하는 입력의 시간 복잡도. 알고리즘 평가에 주로 사용된다.\n\n### Big-O 표기법 종류 및 순서\n\n- O(1): 상수 시간 복잡도. 입력 크기에 관계없이 실행 시간이 일정.\n- O(log n): 로그 시간 복잡도. 입력 크기의 로그에 비례하는 시간이 소요된다.\n- O(n): 선형 시간 복잡도. 입력 크기에 비례하는 실행 시간이 소요된다.\n- O(n^2): 제곱 시간 복잡도. 입력 크기의 제곱에 비례하는 실행 시간이 소요된다.\n- O(2^n): 지수 시간 복잡도. 입력 크기의 지수에 비례하는 실행 시간이 소요된다.\n- O(n!): 팩토리얼 시간 복잡도. 입력 크기의 팩토리얼에 비례하는 실행 시간이 소요된다.\n\n<br/>\n\n> 시간복잡도 순서 : O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n) < O(n!)\n\n<img width=\"800\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/b3b2f47f-6875-42d1-9e0c-d967cf770ab7\">\n\n### 코드 예시\n\n1. **O(1)**: 입력 크기에 상관없이 항상 동일한 시간이 걸린다.\n\n   ```python\n   def get_first_element(arr):\n       return arr[0]\n\n   ```\n\n2. **O(log n)**: 이진 탐색 등이 해당된다.\n\n   ```python\n   def binary_search(arr, target):\n       left, right = 0, len(arr) - 1\n       while left <= right:\n           mid = (left + right) // 2\n           if arr[mid] == target:\n               return mid\n           elif arr[mid] < target:\n               left = mid + 1\n           else:\n               right = mid - 1\n       return -1\n   ```\n\n3. **O(n)**: 배열에서 최대값을 찾는 경우 등이 해당된다.\n\n   ```python\n   def find_max(arr):\n       max_val = arr[0]\n       for num in arr:\n           if num > max_val:\n               max_val = num\n       return max_val\n   ```\n\n4. **O(n log n)**: Merge Sort, Heap Sort 등이 해당된다.\n\n   ```python\n   def merge_sort(arr):\n       if len(arr) > 1:\n           mid = len(arr) // 2\n           left_half = arr[:mid]\n           right_half = arr[mid:]\n           merge_sort(left_half)\n           merge_sort(right_half)\n           i = j = k = 0\n           while i < len(left_half) and j < len(right_half):\n               if left_half[i] < right_half[j]:\n                   arr[k] = left_half[i]\n                   i += 1\n               else:\n                   arr[k] = right_half[j]\n                   j += 1\n               k += 1\n           while i < len(left_half):\n               arr[k] = left_half[i]\n               i += 1\n               k += 1\n           while j < len(right_half):\n               arr[k] = right_half[j]\n               j += 1\n               k += 1\n   ```\n\n5. **O(n²)**: 삽입 정렬, 선택 정렬 등이 해당된다.\n\n   ```python\n   def bubble_sort(arr):\n       n = len(arr)\n       for i in range(n):\n           for j in range(0, n-i-1):\n               if arr[j] > arr[j+1]:\n                   arr[j], arr[j+1] = arr[j+1], arr[j]\n   ```\n\n6. **O(2^n)**: 피보나치 수열 재귀 호출 등이 해당된다.\n\n   ```python\n   def fibonacci(n):\n       if n <= 1:\n           return n\n       else:\n           return fibonacci(n-1) + fibonacci(n-2)\n   ```\n\n7. **O(n!)**: 순열 생성 등이 해당된다.\n\n   ```python\n   def permutations(arr):\n       if len(arr) == 0:\n           return [[]]\n       result = []\n       for i in range(len(arr)):\n           rest = arr[:i] + arr[i+1:]\n           for p in permutations(rest):\n               result.append([arr[i]] + p)\n       return result\n   ```\n\n## 시간복잡도와 제약조건\n\n코딩테스트에서 시간복잡도를 결정하기 위해서는 제약조건을 잘 확인해야한다. 제약조건의 최댓값을 시간복잡도 n에 대입했을 때, 10⁸ (100,000,000)이 넘으면 시간이 초과될 가능성이 높다.\n\n- 예시1) 제약조건이 1≤ n ≤ 10⁵ 일 때 : 시간복잡도가 O(n²) 인 자료구조 사용 ❌  → 총 크기 10¹⁰ 으로 시간 초과.<br/>\n  O(n)이나 O(log n) 으로 풀 수 있는 다른 방법을 생각해야한다.\n\n- 예시2) 제약조건이 1 ≤ n ≤ 10³ 일 때 : 시간복잡도가 O(n²) 인 자료구조 사용 ⭕️ → 총 크기 10⁶ 으로 통과 가능\n\n- 예시3) 제약조건이 1 ≤ n ≤ 7 일 때 : O(n!) 같은 복잡한 자료구조를 사용해도 데이터가 적기때문에 통과 가능\n"},{"excerpt":"자료구조란? 자료구조 (Data Structure) : 데이터를 저장하고 관리하는 방식. 데이터를 체계적으로 저장하여 메모리를 효율적으로 사용하면서 빠르고 안정적으로 데이터를 처리할 수 있다. 자료구조의 종류 선형 자료구조: Array, Dynamic Array, Linked List, Queue, Stack, Hash Table 비선형 자료구조: Tre…","fields":{"slug":"/data-structure01/"},"frontmatter":{"date":"January 08, 2024","title":"[Data Structure] 자료구조와 알고리즘","tags":["datastructure"]},"rawMarkdownBody":"\n## 자료구조란?\n\n> 자료구조 (Data Structure) : 데이터를 저장하고 관리하는 방식. 데이터를 체계적으로 저장하여 메모리를 효율적으로 사용하면서 빠르고 안정적으로 데이터를 처리할 수 있다.\n\n### 자료구조의 종류\n\n- 선형 자료구조: Array, Dynamic Array, Linked List, Queue, Stack, Hash Table\n- 비선형 자료구조: Tree, Graph\n\n<img width=\"1220\" alt=\"\" src=\"https://github.com/devjoylee/devjoylee.github.io/assets/68415905/66df3636-a7fe-4573-a59a-8e2a419e49e5\">\n\n## 알고리즘이란?\n\n> 알고리즘 (Algorithm) : 문제 해결 방법; 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법.\n\n- 자주 쓰이는 문제 해결 방법(알고리즘)은 패턴화되어 있다. (예: BFS, DFS, Binary Search, Dijkstra …)\n- 한 문제를 해결하기 위한 다양한 알고리즘이 존재하며, 어떤 알고리즘이 적합한지 평가할 수 있어야 한다.\n\n### 알고리즘 평가 기준\n\n1. 시간 복잡도 (Time Complexity)\n2. 공간 복잡도 (Space Complexity)\n3. 구현 복잡도\n\n여기서 시간 복잡도와 공간 복잡도는 보통 상반된 관계이다. 실행 시간을 줄이기 위해서는 메모리를 더 사용해야 하고, 메모리 사용량을 줄이려면 실행 시간이 늘어난다. 코딩 테스트에서는 주로 시간 복잡도를 우선으로 하여 실행 시간을 줄이는 것을 중점적으로 보고 있다.\n\n### 자료구조와 알고리즘의 관계\n\n자료구조에 따라 사용할 수 있는 알고리즘과 시간 복잡도가 달라질 수 있다. \n\n**사용 예시**\n\n| 자료구조       | 사용 예시                    |\n|--------------|---------------------------|\n| Array        | 이진 탐색 (Binary Search)  |\n| Linked List  | 선형 탐색 (Linear Search)  |\n| Queue        | BFS (너비 우선 탐색, Breadth-First Search) |\n| Stack        | DFS (깊이 우선 탐색, Depth-First Search)   |\n| Hash Table   | 해시 함수를 이용한 빠른 검색 및 삽입          |"},{"excerpt":"NextJS 14 주요 업데이트 Next.js 14 버전에서는 서버 컴포넌트(Server Components)와 서버 액션(Server Actions)이라는 두 가지 기능이 업데이트되었다. 14 버전의 주요 개선점 개발자 환경 및 생산성 향상 유저가 다운로드하는 자바스크립트 코드 감소 많은 코드와 라이브러리 삭제 가능 1. 서버 컴포넌트 서버 컴포넌트는 …","fields":{"slug":"/next-tutorial-05/"},"frontmatter":{"date":"October 10, 2023","title":"NextJS ver.14: 서버 컴포넌트와 서버 액션","tags":["NextJS","react"]},"rawMarkdownBody":"\n## NextJS 14 주요 업데이트\n\nNext.js 14 버전에서는 서버 컴포넌트(Server Components)와 서버 액션(Server Actions)이라는 두 가지 기능이 업데이트되었다.\n\n### 14 버전의 주요 개선점\n\n- 개발자 환경 및 생산성 향상\n- 유저가 다운로드하는 자바스크립트 코드 감소\n- 많은 코드와 라이브러리 삭제 가능\n\n## 1. 서버 컴포넌트\n\n서버 컴포넌트는 컴포넌트를 서버에서 렌더링하여 클라이언트로 전송하는 방식이다. 이를 통해 클라이언트는 자바스크립트 코드를 제외한 최종 렌더링된 HTML를 전송받는다.\n\n### 서버 컴포넌트의 장점\n- 향상된 성능: 클라이언트로 전송되는 자바스크립트 양이 줄어들어 초기 로드 시간이 단축되므로 사용자 경험이 향상된다.\n- 보안 강화: 서버에서만 데이터를 처리함으로 클라이언트에 민감한 데이터가 노출되지 않는다.\n- 간편한 데이터 페칭: 서버에서 직접 데이터베이스나 API에 접근하여 데이터를 가져오기 때문에 클라이언트 측에서 복잡한 데이터 페칭 로직을 작성할 필요가 없다.\n\n### 이전 버전과의 비교\n\n**이전 버전 :**\n\n```javascript\nfunction Posts() {\n  const [posts, setPosts] = useState([])\n\n  useEffect(() => {\n    const fetchPosts = async () => {\n      const data = await (await fetch(\"/api/posts\")).json()\n      setPosts(data)\n    }\n    fetchPosts()\n  }, [])\n\n  return (\n    <ul>\n      {posts.map(post => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n**Next.js 14 버전 :**\n\n```js\nexport default async function Posts() {\n  const data = await (await fetch(\"/api/posts\")).json()\n\n  return (\n    <ul>\n      {data.map(post => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n## 2. 서버 액션\n\n서버 액션(Server Actions)은 서버에서 비동기 작업을 수행하고 결과를 클라이언트로 반환하는 새로운 패턴이다. 이를 통해 클라이언트에서 복잡한 상태 관리 없이 서버와의 상호작용을 단순화할 수 있다.\n\n### 사용 예제\n\n```js\n'use server'; // 서버 컴포넌트 모드 활성화\n\nimport { useState } from 'react'; // useState 훅을 React로부터 가져옴\n\nexport default function LikeButton() {\n  const [likes, setLikes] = useState(0); \n\n  async function handleLike() {\n    'use server'; // 서버에서 실행되는 함수임을 명시\n\n    // 서버에 /api/like 엔드포인트로 POST 요청을 보내고, 새로운 좋아요 수를 받아옴\n    const newLikes = await (await fetch('/api/like', { method: 'POST' })).json(); \n\n    setLikes(newLikes); // 새로운 좋아요 수로 상태 업데이트\n  }\n\n  return (\n    <button onClick={handleLike}> \n      Like ({likes})\n    </button>\n  );\n}\n```\n\n### 서버 액션의 장점\n- 간결한 코드: 클라이언트와 서버 간의 상호작용을 간소화하여 클라이언트에서의 상태 관리 코드가 줄어든다.\n- 향상된 성능: 서버에서 직접 작업을 처리하므로 클라이언트에서의 부담이 줄어들어 전체적인 성능이 향상된다.\n- 안정성 및 보안: 서버에서 비동기 작업을 처리하므로 클라이언트에서의 보안 취약점을 줄일 수 있다.\n\n### 서버 액션 사용 시 고려사항\n- 서버 액션은 서버에서 실행되므로 네트워크 지연에 대한 고려가 필요하다.\n- 비동기 작업의 결과가 클라이언트에 즉시 반영되지 않을 수 있으므로 사용자 경험을 고려한 디자인이 필요하다.\n- 서버에서의 작업이 실패할 경우 이를 처리할 적절한 에러 핸들링이 필요하다."},{"excerpt":"tRPC 소개 tRPC는 풀스택 타입스크립트 환경에서 타입 안전한 백엔드 API를 작성할 수 있도록 돕는 라이브러리이다.  tRPC를 사용하면 백엔드와 프론트엔드 간의 통신을 단순화하여 풀스택 타입스크립트 개발의 생산성을 크게 향상시킬 수 있다. 기존 HTTP 호출방식의 문제점 과거에는 Swagger를 사용해 .yaml 파일을 기반으로 스키마를 생성하는 …","fields":{"slug":"/trpc/"},"frontmatter":{"date":"September 11, 2023","title":"타입 안정성을 위한 최적의 선택: tRPC API 개발 가이드","tags":["fullstack"]},"rawMarkdownBody":"\n## tRPC 소개\n\ntRPC는 풀스택 타입스크립트 환경에서 타입 안전한 백엔드 API를 작성할 수 있도록 돕는 라이브러리이다. <br/> tRPC를 사용하면 백엔드와 프론트엔드 간의 통신을 단순화하여 풀스택 타입스크립트 개발의 생산성을 크게 향상시킬 수 있다. \n\n## 기존 HTTP 호출방식의 문제점\n\n과거에는 Swagger를 사용해 .yaml 파일을 기반으로 스키마를 생성하는 경우가 많았다. GraphQL에서도 마찬가지로, API를 설명하기 위해 GraphQL 언어를 배워야 하고, 변경이 있을 때마다 API 정의/스키마를 다시 생성해야 했다.\n\n### 문제 1: 프론트엔드에서 요청을 보낼 때\n\n프론트엔드에서 백엔드로 HTTP 요청을 보낼 때, 보내는 데이터의 타입이 백엔드에서 요구하는 타입과 일치하는지 타입스크립트 레벨에서 확인할 수 없다. 예를 들어, 잘못된 필드명을 가진 데이터를 보내더라도 타입스크립트 컴파일 시점이나 런타임에서 에러가 발생하지 않는다.\n\n```tsx\nconst input = { name: \"Hello\", content: \"World\" }; // 잘못된 필드명\nconst response = await fetch(\"/api/post\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: JSON.stringify(input),\n});\nconst data = await response.json();\n```\n\n### 문제 2: 백엔드에서 요청을 받을 때\n\n백엔드에서 받은 데이터의 타입이 실제로 기대하는 타입과 같은지 확인할 수 없다. 예를 들어, 아래와 같이 req.body를 사용할 때 런타임에 타입 검증이 이루어지지 않는다.\n\n```tsx\nconst input: PostInput = req.body;\n```\n\n### 문제 3: 백엔드에서 프론트엔드로 응답을 전달할 때\n\n백엔드에서 프론트엔드로 응답을 전달할 때, 백엔드의 응답 타입을 프론트엔드에서 바로 확인할 수 없다. 프론트엔드에서는 여전히 any 타입을 가진 데이터를 받게 된다.\n\n```tsx\n// 백엔드 코드:\nres.status(200).json(post);\n\n// 프론트엔드 코드:\nconst data = await response.json(); // 하지만 프론트엔드에서는 `any`를 받음\n```\n\n\n## tRPC의 주요 특징\n\n1. **타입 안전성:** 타입스크립트를 활용하여 백엔드와 프론트엔드 간의 타입 안전성을 보장한다.\n2. **코드 생성 없음:** 별도의 스키마나 코드 생성 없이 타입 안전성을 유지한다.\n3. **간편한 통신 :** RPC 방식을 사용하여 함수형식으로 백엔드 API를 호출함으로써 REST API나 GraphQL에 비해 더 직관적이고 사용하기 쉬운 통신 방식을 제공한다.\n4. **빠른 개발 속도:** 백엔드의 API 코드와 프론트엔드의 호출 코드 간에 빠르게 이동할 수 있다. \n\n## tRPC 작동 원리\n\ntRPC는 다음과 같은 방식으로 서버와 클라이언트 간에 타입 안전한 API 호출을 가능하게 한다. \n\n### **Server 측 설정**\n서버에서 API 라우터를 정의하고, 각 라우터에 대해 입력 스키마와 출력 스키마를 지정한다. 이를 통해 서버는 입력 데이터의 유효성을 검사하고, 올바른 출력 데이터를 반환할 수 있다.\n\n```tsx\nimport { z } from \"zod\"; // 입력 데이터의 유효성 검사에 필요한 라이브러리\nimport { createTRPCRouter, publicProcedure } from \"~/server/api/trpc\"; \n\n// title과 content를 입력받아 새로운 게시물을 생성하고 생성된 게시물의 정보를 반환하는 프로시저\nexport const postRouter = createTRPCRouter({\n  createPost: publicProcedure  // createPost라는 프로시저를 정의\n    .input(z.object({\n      title: z.string(), // title : 문자열\n      content: z.string(), // content : 문자열\n    }))\n    .mutation(({ input }) => {  \n\t    // mutation 함수 : 데이터 처리 후 결과를 반환\n      return {\n        id: \"1\", // 생성된 게시물의 고유 ID\n        title: input.title, // 입력 받은 title을 그대로 반환\n        content: input.content, // 입력 받은 content를 그대로 반환\n        createdAt: new Date(), // 생성 시간 반환\n      };\n    }),\n});\n\n```\n\n### **Client 측 호출**\n클라이언트에서는 서버에서 정의한 API 라우터를 사용하여 함수를 호출한다. 이 때, 타입스크립트는 입력 데이터가 올바른지 검사하고, 서버에서 반환되는 데이터의 타입을 추론함으로써 타입 안전성을 보장한다.\n\n```tsx\nimport { api } from \"~/utils/api\"; // tRPC 클라이언트를 가져온다\n\n// useMutation 훅을 이용해 createPostMutation을 정의\nconst createPostMutation = api.post.createPost.useMutation();\n\n// createPost 함수 생성\nconst createPost = async () => {\n  // mutateAsync 함수를 사용해 서버에 createPost 요청 전송\n  const result = await createPostMutation.mutateAsync({\n    title: \"Hello\", // 서버에 전달할 title 값\n    content: \"World\", // 서버에 전달할 content 값\n  });\n\n  console.log(result);  // 서버에서 반환된 결과를 출력\n};\n```\n\n## tRPC vs GraphQL\n\ntRPC와 GraphQL은 모두 API를 구축하는 데 사용되는 기술이지만, 몇 가지 중요한 차이점이 있다. \n\n**타입 시스템과 안정성**\n\n- tRPC: TypeScript 기반으로 API의 입력과 출력 데이터를 타입화하여 안전성을 제공한다.\n- GraphQL: 서버가 제공하는 스키마를 기반으로 클라이언트가 원하는 데이터를 요청하고 서버는 해당 스키마에 따라 데이터를 반환한다. 타입 안정성은 tRPC에 비해 상대적으로 낮다.\n\n**데이터 흐름과 API 디자인**\n\n- tRPC: RPC 스타일로 서버에서 정의한 API 메서드를 클라이언트에서 직접 호출할 수 있다.\n- GraphQL: 클라이언트는 쿼리를 작성하여 원하는 데이터를 명시적으로 요청하고 서버는 해당 쿼리에 맞게 데이터를 반환한다. \n\n**통신 프로토콜과 환경**\n\n- tRPC: HTTP/2를 기반으로 하며 gRPC와 유사한 방식으로 작동한다.\n- GraphQL: HTTP나 WebSockets와 같은 다양한 통신 프로토콜을 지원하여 다양한 환경에서 사용할 수 있다. 특히 실시간으로 데이터 통신이 가능하다.\n\n**도구 지원과 생태계:**\n\n- tRPC: TypeScript와의 호환성은 뛰어나지만 GraphQL에 비해 도구의 활용도가 떨어진다.\n- GraphQL: Apollo, Relay 등의 클라이언트 라이브러리와 함께 사용할 수 있고 다양한 도구를 지원한다.\n"},{"excerpt":"🔥 React Native 튜토리얼 React Native는 웹브라우저가 아닌, IOS와 안드로이드 같은 운영체제와 소통하기 위한 도구(인터페이스)이다! 1. No DIV, Use View React Native는 웹사이트가 아니기 때문에 html 태그 (div, section, p..)를 쓸 수 없다. 대신 컨테이너로  대신  를 사용한다. 모든 Vie…","fields":{"slug":"/reactnative-rules/"},"frontmatter":{"date":"February 20, 2023","title":"React Native 꼭 알아야할 주요 특징","tags":["react-native"]},"rawMarkdownBody":"\n## 🔥 React Native 튜토리얼\n\n> React Native는 웹브라우저가 아닌, IOS와 안드로이드 같은 운영체제와 소통하기 위한 도구(인터페이스)이다!\n\n### 1. No DIV, Use View\n\n- React Native는 웹사이트가 아니기 때문에 html 태그 (div, section, p..)를 쓸 수 없다.\n- 대신 컨테이너로 `div` 대신 `View` 를 사용한다.\n- 모든 View 컨테이너는 `flex` **레이아웃을 default로** 가지고 있으며, 기본 flex direction은 **COLUMN** 이다.\n- `flex: 숫자` : pixel이 아닌 전체 스크린(또는 부모 크기)에 대한 **비율**을 설정해서 크기를 지정함<br/>\n  → ❗ 모바일 스크린 사이즈가 다양하기 때문에 width와 height는 거의 사용하지 않는다.\n\n```jsx\n<View style={{ flex: 1 }}>\n  <View style={{ flex: 1 }}></View> // height 1/5 차지\n  <View style={{ flex: 3 }}></View> // height 3/5 차지\n  <View style={{ flex: 1 }}></View> // height 1/5 차지\n</View>\n```\n\n### 2. 모든 텍스트는 `<Text></Text>` 컴포넌트 안에서 작성해야한다\n\n<img src=\"https://user-images.githubusercontent.com/68415905/221510862-08db2f01-62ad-48ec-b5db-cc62eb978271.JPG\" alt=\"img\" width=\"400\"/>\n\n### 3. 스타일은 객체 형식과 CamelCase로 작성하며 사용할 수 없는 스타일도 있다.\n\nex) `border: \"1px solid #000\"` ❌ 사용할 수 없음\n\n스타일을 적용시키는 방식은 크게 3가지로 나뉜다.\n\n- 인라인 스타일\n\n```jsx\n<View\n  style={{\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  }}\n>\n  <Text style={{ fontSize: 28 }}>Hello</Text>\n</View>\n```\n\n- 스타일 객체 생성 (자동완성 지원 X)\n\n```jsx\n;<View style={styles.container}>\n  <Text style={styles.text}>Hello</Text>\n</View>\n\nconst styles = {\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  text: { fontSize: 28 },\n}\n```\n\n- `StyleSheet.create({})` : 자동완성을 사용할 수 있다.\n\n```jsx\n;<View style={styles.container}>\n  <Text style={styles.text}>Hello</Text>\n</View>\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  text: { fontSize: 28 },\n})\n```\n\n### 4. 위 모든 규칙에는 Import 필수 !\n\n```jsx\nimport { View, Text, StyleSheet } from \"react-native\"\n```\n\n### 5. Component vs API\n\n- Component : 화면에 렌더링할 항목 (View, Text …)\n- APIs : 운영체제와 소통하기 위해 만들어 놓은 자바스크립코드\n\n```jsx\n<Button onPress={()=> Vibration.vibrate(~~)} />\n// Component -> <Button />\n// API -> Vibration.vibrate()\n```\n\n### 6. Third Party Packages\n\n- 리액트 네이티브 Docs [https://reactnative.dev/docs/components-and-apis](https://reactnative.dev/docs/components-and-apis)\n\nReact Native의 이전버전에서는 다양한 컴포넌트와 API가 제공되었는데 업데이트 되면서 많은 기능들이 사라졌다. (AsyncStorage, Navigation..)\n\n- React Native 커뮤니티 [https://reactnative.directory/](https://reactnative.directory/)\n\n그래서 React Native 커뮤니티에서 Third Parth 패키지(컴포넌트, API)를 제공하고 있다. 하지만 사용자들이 오픈소스처럼 추가하기 때문에 종류가 매우 많고 업데이트가 불분명하다는 단점이 있다.\n\n- Expo SDK [https://docs.expo.dev/versions/latest/](https://docs.expo.dev/versions/latest/)\n\n이런 모든 단점을 보완하기 위해 ‘Expo’ 라는 플랫폼에서 React-Native 에서 사용할 수 있는 모든 컴포넌트와 API를 자체적으로 만들었다. (Expo SDK) 아래 처럼 필요한 기능을 설치하고 import해서 사용할 수 있다.\n\n```jsx\nexpo install expo-document-picker\n```\n\n<br/><br/>\n\n> REFERENCE <br/> Nomad Coder https://nomadcoders.co/react-native-for-beginners/lobby\n"},{"excerpt":"1️⃣ MongoDB 프로젝트 생성 https://www.mongodb.com/ 홈페이지에서 회원가입 후, 프로젝트를 생성 한다. 생성한 프로젝트에 데이터 베이스를 추가한다. Free 버전 선택!\n Security > Database Access에서 사용자를 추가한다. 이때 패스워드는 나중에 쓰이므로 저장해둘 것!\n Security > Network Acce…","fields":{"slug":"/next-tutorial-04/"},"frontmatter":{"date":"December 05, 2022","title":"Next-Auth + MongoDB 로그인 유저값 저장하기","tags":["NextJS","react"]},"rawMarkdownBody":"\n## 1️⃣ MongoDB 프로젝트 생성\n\n1. https://www.mongodb.com/ 홈페이지에서 회원가입 후, 프로젝트를 생성 한다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/221728163-0a33eb92-aab6-4bc8-a38d-946a5fbec98a.JPG\" alt=\"img\" width=\"800\"  >\n\n2. 생성한 프로젝트에 데이터 베이스를 추가한다. Free 버전 선택!\n   <img src=\"https://user-images.githubusercontent.com/68415905/221728166-1675d8c6-c27a-431a-96c2-159272f32a22.JPG\" alt=\"\" width=\"700\" />\n\n3. Security > Database Access에서 사용자를 추가한다. 이때 패스워드는 나중에 쓰이므로 저장해둘 것!\n   <img src=\"https://user-images.githubusercontent.com/68415905/221728172-cee90bf9-2d0f-4bac-bfee-3a449844f92d.JPG\" alt=\"\" />\n\n4. Security > Network Access에서 IP주소를 추가한다\n   <img src=\"https://user-images.githubusercontent.com/68415905/221731897-6db80b63-2c1a-4d10-b28d-432a1dbc6f17.JPG\" alt=\"\" width=\"550\" style=\"margin:0\"/>\n\n## 2️⃣ 로컬에 MongoDB 환경 설정하기\n\n[📝 Go to Next Auth + MongoDB Docs](https://next-auth.js.org/adapters/mongodb)\n\n1. MongoDB Installation\n\n```bash\nnpm install next-auth @next-auth/mongodb-adapter mongodb\n```\n\n2. `lib/mongodb.ts` 경로에 아래 코드를 추가한다.\n\n```js\n// This approach is taken from https://github.com/vercel/next.js/tree/canary/examples/with-mongodb\nimport { MongoClient } from \"mongodb\"\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Invalid/Missing environment variable: \"MONGODB_URI\"')\n}\n\nconst uri = process.env.MONGODB_URI\nconst options = {}\n\nlet client\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  if (!global._mongoClientPromise) {\n    client = new MongoClient(uri, options)\n    global._mongoClientPromise = client.connect()\n  }\n  clientPromise = global._mongoClientPromise\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options)\n  clientPromise = client.connect()\n}\n\n// Export a module-scoped MongoClient promise. By doing this in a\n// separate module, the client can be shared across functions.\nexport default clientPromise\n```\n\n3. 만들어둔 next auth API에 MongoDB 어댑터를 추가한다 (경로 : `pages/api/auth/[...nextauth].js`) <br/>\n   `adapter`를 사용할 때는 session strategy를 jwt로 설정해준다. [👉 jwt 인증방식 더 알아보기](https://devjoylee.github.io/node-tutorial-04/)\n\n```js\nimport NextAuth from \"next-auth\"\nimport { MongoDBAdapter } from \"@next-auth/mongodb-adapter\"\nimport clientPromise from \"lib/mongodb\"\n\n// For more information on each option (and a full list of options) go to\n// https://next-auth.js.org/configuration/options\nexport default NextAuth({\n  adapter: MongoDBAdapter(clientPromise),\n  session: {\n    strategy: 'jwt',\n  }\n  ...\n})\n```\n\n## 3️⃣ JWT Secret 발급 받기\n\n1. generate-secret.vercel.app 에서 JWT 코드를 발급 받는다. (코드 복사)\n2. `.env.local` 파일에 복사한 코드를 저장한다\n\n```\nJWT_SECRET=0b7001621f33~~~\n```\n\n3. 만들어둔 next auth API에 secret 코드를 추가한다 (경로 : `pages/api/auth/[...nextauth].js`)\n\n```js\nexport default NextAuth({\n  adapter: MongoDBAdapter(clientPromise),\n  secret: process.env.JWT_SECRET\n  ...\n})\n```\n\n## 4️⃣ 데이터베이스 연결하기\n\n1. MongoDB 데이터베이스가 만들어 지면 `Connect` 버튼을 눌러 아래와 같은 코드를 발급받는다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/221734881-6eb6dcee-b437-44c7-9de1-97f3bfdf9391.JPG\" alt=\"\" width=\"700\"/>\n\n2. `.env.local` 에 발급받은 코드를 추가한다 (경로 : `pages/api/auth/[...nextauth].js`) <br/>\n   여기서 `<password>`는 처음에 사용자 추가할 때 발급받은 비밀번호로 바꿔주고 `myFirstDatabase`는 앱이름으로 교체\n\n```\nMONGODB_URI=mongodb+srv://admin:<password>@cluster0.upmnolv.mongodb.net/myFirstDatabase?retryWrites=true&w=majority\n```\n\n## 5️⃣ 미들웨어 추가하기\n\n미들웨어(Middleware)는 요청이 완료되기 전에 코드를 호출할 수 있는 기능을 제공한다.<br/>\n덕분에 응답을 수정하고, 리다이렉트하고, 헤더를 추가하고, 심지어 HTML을 스트리밍할 수 있다. <br/>\n[👉 NextJS 미들웨어 Docs 보러가기](https://nextjs.org/docs/advanced-features/middleware)\n\n<img src=\"https://miro.medium.com/v2/resize:fit:720/format:webp/1*iO3GXX2ofuOF6CQUcG9u-g.png\" alt=\"\">\n\n```js\nimport { getToken } from \"next-auth/jwt\"\nimport { NextRequest, NextResponse } from \"next/server\"\n\nexport const middleware = async (req: NextRequest) => {\n  const { pathname, origin } = req.nextUrl\n\n  if (req.nextUrl.pathname === \"/\") {\n    const session = await getToken({\n      req,\n      secret: process.env.JWT_SECRET,\n      secureCookie: process.env.NODE_ENV === \"production\",\n    })\n\n    // login 유저가 없으면 /home\n    if (!session) return NextResponse.redirect(`${origin}/home`)\n    // login 유저가 있으면 /feed\n    else return NextResponse.redirect(`${origin}/feed`)\n  }\n}\n```\n\n## 6️⃣ 로그인 버튼과 provider 연결\n\n`getServerSideProps` 를 사용해서 추가한 provider를 가져온 후, 로그인 요청 시 유저값을 전송한다.\n\n```ts\nimport { getProviders } from \"next-auth/react\"\nimport type {\n  GetServerSideProps,\n  InferGetServerSidePropsType,\n  NextPage,\n} from \"next\"\n\n// access to the google provider by props\nconst Home: NextPage = ({ providers }: ProviderType) => {\n  return Object.values(providers).map((provider: any) => (\n    <div key={provider.name}>\n      <div className=\"pl-4\">\n        <button onClick={() => signIn(provider.id, { callbackUrl: \"/\" })}>\n          Sign In\n        </button>\n      </div>\n    </div>\n  ))\n}\n\n// server side rendering\nexport const getServerSideProps: GetServerSideProps = async context => {\n  const providers = await getProviders()\n  return { props: { providers } }\n}\n```\n\n<br />\n<br />\n\n> REFERENCE<br /> NextAuth 공식문서 https://next-auth.js.org/<br/> NextJS Middleware https://nextjs.org/docs/advanced-features/middleware\n"},{"excerpt":"🅰 서버 기반 인증 시스템 (Session / Cookie) 서버 기반 인증 시스템은 로그인 시 세션 ID를 클라이언트에게 발급해주고 클라이언트는 요청 시마다 세션 ID가 담긴 쿠키를 헤더에 담아 보내는 방식이다. 상태를 유지해야 하므로 Stateful한 구조를 가지고 있다. 인증방식 사용자가 로그인하면 올바른 사용자임을 확인하고 고유한 세션 ID 값을 …","fields":{"slug":"/node-tutorial-04/"},"frontmatter":{"date":"November 25, 2022","title":"[Node] Server Authentication (Session vs JWT)","tags":["nodejs"]},"rawMarkdownBody":"\n## 🅰 서버 기반 인증 시스템 (Session / Cookie)\n\n서버 기반 인증 시스템은 로그인 시 **세션 ID를 클라이언트에게 발급**해주고 클라이언트는 요청 시마다 **세션 ID가 담긴 쿠키를 헤더에 담아** 보내는 방식이다. 상태를 유지해야 하므로 Stateful한 구조를 가지고 있다.\n\n### 인증방식\n\n1. 사용자가 로그인하면 올바른 사용자임을 확인하고 고유한 세션 ID 값을 생성한다.\n\n2. 생성된 ID 값은 세션 저장소에 저장 후 클라이언트에게 발급해준다.\n\n3. 클라이언트는 세션 ID를 받아 쿠키에 저장하고, 인증이 필요한 요청마다 쿠키에 세션 ID를 담아 헤더에 실어 보낸다.\n\n4. 서버에서는 쿠키를 받아 세션 저장소와 비교해 올바른 요청인지 확인한다.\n\n5. 인증이 완료되고 서버는 요청에 응답한다.\n\n### 장점\n\n중요한 정보는 서버에 있기 때문에 쿠키 자체(세션 ID)는 유의미한 값을 가지고 있지 않다.\n\n### 단점\n\n- 쿠키값 자체가 의미가 없다는 것은 안전해 보일 수 있으나, 해커가 훔친 쿠키를 이용해 HTTP 요청을 보내면 서버에서는 올바른 사용자가 보낸 요청인지 알 수 없다.(세션 하이재킹 공격)\n  → 세션에 유효시간을 넣어줘야 한다. / B 방식도 마찬가지.\n\n- 세션을 저장해야 하므로 사용자가 늘어날 경우 서버의 RAM에 부하가 걸리게 된다. 이를 피하기 위해 데이터베이스에 저장하기도 하는데 이 역시 데이터베이스에 부하를 줄 수 있다.\n\n- 시스템 확장이 어렵다. 단순한 사양 업그레이드가 아닌 더 많은 트래픽을 감당하기 위해 여러 프로세스를 돌리거나, 여러 대의 서버 컴퓨터를 추가하는 것을 의미한다.\n\n## 🅱 토큰 기반 인증 시스템(JWT)\n\n토큰 기반 인증 시스템은 로그인 시 토큰을 발급해주고, 서버에 요청을 할 때 HTTP 헤더에 토큰을 함께 보내도록 하여 유효성 검사를 하는 방식이다. 사용자의 인증 정보를 더 이상 서버에 저장하지 않고 클라이언트의 요청으로만 인가를 처리할 수 있으므로 Stateless 한 구조를 가진다.\n\nJWT는 **Json Web Token**의 약자로 **인증에 필요한 정보를 암호화시킨 토큰**을 뜻한다.\n\n세션/쿠키 방식과 유사하게 클라이언트는 **Access Token(JWT)을 HTTP 헤더**에 실어 서버로 보낸다. A 방식과 가장 큰 차이점은 세션 저장소에 유저의 정보를 넣는 반면에 B 방식은 토큰 안에 유저의 정보를 넣는다는 점이다. 서버 측에서는 인증을 위해 암호화를 하느냐, 별도의 저장소를 이용하냐는 차이가 발생한다.\n\n### 인증방식\n\n1. 사용자가 로그인 시 올바른 사용자임을 확인하고, 클라이언트에게 Access Token(JWT)을 발급해준다.\n\n2. 클라이언트는 전달받은 토큰을 저장해 두고, 인증이 필요한 요청마다 토큰을 HTTP 헤더에 담아 보낸다.\n\n3. 서버에서는 암호화된 토큰을 복호화 해 올바른 요청인지 확인한다.\n\n4. 인증이 완료되고 서버는 요청에 응답한다.\n\n### 장점\n\n- 간편하다. A 방식은 저장소의 관리가 필요하지만 Access Token을 발급해준 후 요청이 들어오면 검증만 해주면 되기 때문에 추가 저장소가 필요 없다. 즉 Stateless 하다.\n\n- 쿠키를 사용함으로 인해 발생하는 취약점이 사라진다. 하지만, 토큰을 사용하는 환경에서의 취약점에 대비해야 한다.\n\n- 확장성이 뛰어나다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다. Ex) facebook, Google..\n\n### 단점\n\n- 이미 발급된 JWT를 돌이킬 수 없다. A 방식처럼 세션 저장소를 사용하는 경우에는 해당 세션이 악의적으로 사용될 경우 지워버리면 되지만, JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능하다. 즉 유효기간이 지나기 전까지 실컷 털릴 수 있다\n\n- JWT의 길이가 길다. 인증이 필요한 요청이 많아질수록 서버의 자원 낭비가 발생한다.\n\n## 결론\n\n서버 기반 인증 방식은 과거에 사용하던 방식이다. 서버 기반 인증 방식을 대체하기 위하여 등장한 것이 토큰 기반 인증 방식이지만 토큰을 사용한다고 해서 무조건 해킹의 위험에서 벗어난 것이 아니다.\n\n<!--\n## 🔎 모듈 이란?\n\n노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와 다릅니다. 모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있습니다. 자바스크립트에서 코드를 재사용하기 위해 함수로 만드는 것과 비슷하며 노드에서는 보통 파일 하나가 모듈 하나가 됩니다. 파일별로 코드를 모듈화할 수 있어 관리하기 편합니다.\n\n> 모듈 : 특정한 기능을 하는 함수나 변수들의 집합\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183278114-3116e3ab-b132-4086-b009-36462369999e.jpg\" width=\"450\" />\n\n3-3 ~ 3-6\n3-7 ~ 3-11 -->\n\n<br /><br /><br />\n\n> REFERENCE <br /> 쉽게 알아보는 서버 인증 1편 - https://tansfil.tistory.com/58?category=255594<br />[JWT] 토큰(Token) 기반 인증에 대한 소개 - velopert.com/2350\n"},{"excerpt":"✨ Next-Auth란? Next.js에서 소셜 로그인 기능을 쉽게 추가하고 관리할 수 있는 Node.js 라이브러리 (Authentication)📝 Next-Auth Docs 바로가기 Installation 🔎 Next Auth 설정하기 1. Google OAuth 인증 정보 발급 Next Auth를 설정하기에 앞서 사용하고자 하는 API의 Client…","fields":{"slug":"/next-tutorial-03/"},"frontmatter":{"date":"November 19, 2022","title":"Next-Auth로 Google 로그인 기능 구현","tags":["NextJS","react"]},"rawMarkdownBody":"\n## ✨ Next-Auth란?\n\n> Next.js에서 소셜 로그인 기능을 쉽게 추가하고 관리할 수 있는 Node.js 라이브러리 (Authentication)<br/>📝 [Next-Auth Docs 바로가기](https://next-auth.js.org/getting-started/example)\n\n### Installation\n\n```bash\nnpm install next-auth\n```\n\n## 🔎 Next Auth 설정하기\n\n### 1. Google OAuth 인증 정보 발급\n\nNext Auth를 설정하기에 앞서 사용하고자 하는 API의 Client ID와 Key를 발급받는다. 👉[Google OAuth Client ID 발급 방법](https://devjoylee.github.io/google-auth-clientid/)\n\n### 2. 환경 변수 설정\n\n발급받은 Google OAuth 클라이언트 정보를 `.env.local` 파일에 아래와 같이 추가한다.\n\n```\nGOOGLE_CLIENT_ID=7800994348....\nGOOGLE_CLIENT_SECRET=GOCSPX....\n```\n\n### 3. Next Auth API 만들기\n\npage 폴더 내에 `api/auth/[...nextauth].js` 파일을 만들고 아래 코드를 추가한다. <br/>이 파일은 `/api/auth/*` 의 경로로 요청되는 모든 request를 처리한다.\n\n```js\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\n\nexport default NextAuth({\n  // Configure one or more authentication providers\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    }),\n    // add more providers here\n  ],\n});\n```\n\n### 4. Next.js에 nextauth 연결하기\n\n아래와 같이 next-auth가 제공하는 Provider로 컴포넌트를 감싸주면 next.js 내 모든 컴포넌트에서 useSession hooks를 활용하여 session 정보에 접근할 수 있게 된다.\n\n```js\n//_app.js\nimport { SessionProvider } from \"next-auth/react\"\n\nfunction MyApp({ Component, pageProps: { session, ...pageProps } }) {\n  return (\n    <SessionProvider session={session}>\n      <Component {...pageProps} />\n    </SessionProvider>\n  )\n}\n```\n\n### 5. 컴포넌트에 nextAuth 추가하기\n\n- useSession Hook\n\n로그인 여부를 알려주는 hook으로 로그인 여부에 따라 배열의 **첫번째 인자는 유저 정보, 두번쨰 인자로는 loading 상태**를 return 한다. 아래 코드는 session 변수로 로그인 상태를 확인하고 로그인/로그아웃 버튼을 출력한다.\n\n- signIn, signOut 함수\n\nsignIn, signOut 함수는 next auth에서 제공해주는 함수로 해당 함수를 실행하면 next-auth가 만들어 놓은 로그인 페이지 혹은 로그아웃 페이지로 이동한다. 👉 [signIn & signOut 링크설정하기](https://next-auth.js.org/configuration/pages)\n\n```js\n// index.js\nimport { signIn, signOut, useSession } from 'next-auth/client'\n\nexport default function Page() {\n  const [ session, loading ] = useSession();\n  if (loading) return <div>loading...</div>;\n\n  return <>\n    {!session &&\n      Not signed in <br/>\n      <button onClick={() => signIn()}>Sign in</button>\n    }\n    {\n      session &&\n      Signed in as {session.user.name} <br/>\n      <button onClick={() => signOut()}>Sign out</button>\n    }</>\n  }\n```\n\n<br />\n<br />\n\n> REFERENCE<br /> NextAuth 공식문서 https://next-auth.js.org/\n"},{"excerpt":"😎 프로젝트 소개 NextJS와 GraphQL로 빌드한 싸이월드 클론 프로젝트 제작 기간 : 2022.10.14 - 2022.11.03 Github Repo 프로젝트 배포 링크 🚀 프로젝트를 시작하기 전에.. 1. NextJS & GraphQL 설치 2. 폴더 구조 3. 절대 경로 설정 파일 import 시,  와 같은 상대경로를  와 같은 절대경로로 바…","fields":{"slug":"/cyworld-clone/"},"frontmatter":{"date":"November 10, 2022","title":"싸이월드 클론 built in NextJS","tags":["typescript","react"]},"rawMarkdownBody":"\n<img src=\"https://user-images.githubusercontent.com/68415905/201012943-51174d9b-43fa-4103-80da-1469f2aed925.png\" alt=\"\" width=\"800\" align=\"center\" />\n\n## 😎 프로젝트 소개\n\n> NextJS와 GraphQL로 빌드한 싸이월드 클론 프로젝트\n\n- 제작 기간 : 2022.10.14 - 2022.11.03\n- [Github Repo](https://github.com/devjoylee/cyworld)\n- [프로젝트 배포 링크](https://cyworld-nb.vercel.app/)\n\n## 🚀 프로젝트를 시작하기 전에..\n\n### 1. NextJS & GraphQL 설치\n\n```bash\nnpx create-next-app cyworld --typescript\nnpm install @apollo/client graphql\n```\n\n### 2. 폴더 구조\n\n```bash\npublic\n ├── images\n └── icons\n\npages\n ├── diary\n │ ├── [id]\n │ │   ├── edit.tsx     // diary/12030/edit\n │ │   └── index.tsx    // diary/12030\n │ ├── new.tsx          // diary/new\n │ └── index.tsx        // diary\n ├── game\n │     └── index.tsx    // game\n ├── \\_app.tsx\n ├── \\_document.tsx\n └── index.tsx          // home\n\nsrc\n ├── components\n ├── styles\n ├── hooks\n ├── queries\n ├── types\n └── utils\n```\n\n### 3. 절대 경로 설정\n\n파일 import 시, `../../../components/Common` 와 같은 상대경로를 `@components/Common` 와 같은 절대경로로 바꿔준다. <br/>\n(tsconfig.json 파일에 baseUrl, paths key추가)\n\n```json\n// tsconfig.json\n\"compilerOptions\": {\n  \"baseUrl\": \".\",\n  \"paths\": {\n    \"@*\": [\"./src/*\"]\n  }\n}\n```\n\n### 4. SCSS-modules 사용\n\n- scss를 사용하려면 `npm i sass` 라이브러리 설치를 해야한다.\n- `.module.scss` 파일을 만들어 필요한 scss를 추가하고 import해서 사용.\n- 작성한 scss는 아래와 같이 className에 `styles.클래스명`을 추가해서 적용시킨다.\n\n```jsx\n// SectionTitle.tsx\nimport styles from \"./SectionTitle.module.scss\"\n\nexport const SectionTitle = () => {\n  return <h2 className={styles.section_title}>{title}</h2>\n}\n```\n\n```jsx\n// SectionTitle.module.scss\n@import '@styles/variables.scss';\n\n.section_title {\n  display: flex;\n  align-items: center;\n  color: $main-color-1;\n}\n\n```\n\n### 5. 레이아웃 만들기\n\n<img src=\"https://user-images.githubusercontent.com/68415905/201014999-8fb3eb43-4039-4c85-b4cd-98a473ae0945.png\" alt=\"\" width=\"650\" />\n\n```jsx\ninterface Props {\n  children: React.ReactNode;\n}\n\nexport const AppLayout = ({ children }: Props) => {\n  return (\n    <div className={styles.bg}>\n      <div className={styles.innerbox}>\n        <Header />\n        <div className={styles.app_container}>\n          <Profile />\n          <ContentWrap>{children}</ContentWrap>\n          <Navbar />\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n- ⭐ `children` props의 타입 → React.ReactNode\n- Navbar의 각 메뉴를 클릭하면 ContentWrap에 해당하는 UI가 바뀐다 (`children`으로 전달되는 것 들)\n\n## ✨ 프로젝트 주요 기능\n\n### 1. checkbox selectAll\n\n```js\nexport const BGMs = () => {\n  const [checkedList, setCheckedList] = useState<string[]>([])\n  const [isSelectedAll, setIsSelectedAll] = useState(false)\n\n  const handleSelectAll = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { checked } = e.target\n\n    setIsSelectedAll((prev) => !prev)\n    if (checked) {\n      setCheckedList(BGMList.map((item) => item.id + ''))\n    } else {\n      setCheckedList([])\n    }\n  }\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { id, checked } = e.target\n\n    if (checked) {\n      setCheckedList([...checkedList, id])\n    } else {\n      setCheckedList(checkedList.filter((item) => item !== id))\n      setIsSelectedAll(false)\n    }\n  }\n\n  return (\n    <section className={styles.bgm_list}>\n      <SectionTitle title='추억의 BGM' subtitle='TODAY MUSIC' />\n      <table className={styles.table}>\n        <thead>\n          <tr>\n            <th className={styles.checkbox}>\n              <input\n                type='checkbox'\n                id='selectAll'\n                checked={isSelectedAll}\n                onChange={handleSelectAll}\n              />\n            </th>\n            <th className={styles.num}>번호</th>\n            <th className={styles.title}>곡명</th>\n            <th className={styles.artist}>아티스트</th>\n          </tr>\n        </thead>\n        <tbody>\n          {BGMList.map(({ id, title, artist }) => (\n            <tr key={id}>\n              <td className={styles.checkbox}>\n                <input\n                  type='checkbox'\n                  id={id + ''}\n                  onChange={handleChange}\n                  checked={checkedList.includes(id + '')}\n                />\n              </td>\n              <td className={styles.num}>{id}</td>\n              <td className={styles.title}>{title}</td>\n              <td className={styles.artist}>{artist}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </section>\n  )\n}\n\nconst BGMList = [\n  { id: 1, title: 'After LIKE', artist: 'IVE (아이브)' },\n  { id: 2, title: '사랑스러워', artist: '김종국' },\n  { id: 3, title: 'Attention', artist: 'NewJeans' },\n  { id: 4, title: 'Love Love Love', artist: '에픽하이' },\n  { id: 5, title: 'Pink Venom', artist: 'BLACKPINK' },\n  { id: 6, title: '눈의꽃', artist: '박효신' },\n  { id: 7, title: 'Hype boy', artist: 'NewJeans' },\n  { id: 8, title: 'FOREVER 1', artist: '소녀시대' },\n  { id: 9, title: '그때 그 순간 그대로', artist: 'WSG워너비' },\n  { id: 10, title: '애인있어요', artist: '이은미' },\n]\n```\n\n<br />\n"},{"excerpt":"app/ Directory app/ 디렉토리 구조는 beta버전이기 때문에 실제 프로덕션 레벨에서는 권장되지 않는다. 기존에는 pages 디렉토리 안에 파일을 생성하여 Automating Routing을 실행했지만, 13버전부터는 app/이라는 새로운 디렉토리가 등장하였다. 파일 시스템 기반에서 디렉터리 기반 라우팅 시스템으로 전환하였다. 현재는 page…","fields":{"slug":"/next-tutorial-02/"},"frontmatter":{"date":"November 10, 2022","title":"NextJS ver.13 특징 살펴보기","tags":["NextJS","react"]},"rawMarkdownBody":"\n## app/ Directory\n\n**app/ 디렉토리 구조는 beta버전이기 때문에 실제 프로덕션 레벨에서는 권장되지 않는다.**\n\n<img src=\"https://velog.velcdn.com/images/hwangyena/post/0e40f528-e985-4164-a017-ae67cd6ff3e2/image.png\" alt=\"pic\" witdh=\"800\">\n\n기존에는 pages 디렉토리 안에 파일을 생성하여 Automating Routing을 실행했지만, 13버전부터는 app/이라는 새로운 디렉토리가 등장하였다. 파일 시스템 기반에서 디렉터리 기반 라우팅 시스템으로 전환하였다. 현재는 pages와 app 디렉토리가 공존하는 베타 버전으로 제공된다. app 디렉토리 안에는 layout.js, page.js, head.js파일이 존재한다. \\*dev server를 돌리면 자동적으로 head.js와 layout.js를 생성해준다.\n\n- page.js : 고유한 ui를 정의하는데 사용(index.js같은 느낌)\n- layout.js : 여러 경로에서 공유되는 ui를 정의하는데 사용(nav, footer 컴포넌트)\n\n## Data Fetching\n\n- 이제 getStaticProps, getServerSideProps 사용 대신, 간편하게 `use` hooks 사용으로 SSR을 대체할 수 있어졌다.\n- `use` hook을 사용하면 fetch, cache, 데이터 재검증을 컴포넌트 레벨에서 가능해진다.\n- 즉, Static Site Generation (SSG), Server-Side Rendering (SSR), 그리고 Incremental Static Regeneration (ISR)의 모든 이점을 하나의 API를 통해 사용할 수 있다.\n\n<img src=\"https://velog.velcdn.com/images/hwangyena/post/cce5ed30-39be-466c-9e44-ddc7233ca369/image.png\" />\n<img src=\"https://velog.velcdn.com/images/hwangyena/post/536b971e-9433-4167-9dcc-9f079d769fab/image.png\" width=\"500\" />\n\n## @next/font\n\n새로 등장한 `next/font`! 브라우저에서 Google로 폰트 import 요청없이 폰트 사용이 가능하다.<br/>\n\n[next/font Docs 보러가기](https://nextjs.org/docs/api-reference/next/font)\n\n- CSS와 font는 빌드 타임에 정적 자원으로 불러와지기 때문에 실제 브라우저에서는 google로 요청을 보낼일이 없다\n- 개인 정보 보호 및 성능 향상을 위한 외부 네트워크 요청 제거\n- 모든 폰트 파일에 대한 자동 self-hosting 내장\n- CSS의 size-adjust 속성을 자동으로 적용 -> Layout shift 요소 제거\n- 다양한 weight와 styles 사용 시 배열을 사용\n\n```js\nimport { Inter, Roboto } from '@next/font/google';\n\nconst inter = Inter();\n<html className={inter.className}>\n\nconst roboto = Roboto({\n  weight: [\"400\", \"700\"],\n  style: [\"normal\", \"italic\"],\n  subsets: [\"latin\"],\n})\n```\n\n커스텀 폰트(local)도 자동 self-hosting, 캐싱, pre-loading 기능과 함께 제공된다.\n\n```js\nimport localFont from '@next/font/local';\n\nconst myFont = localFont({ src: './my-font.woff2' });\n<html className={myFont.className}>\n```\n\n## next/image\n\n레이아웃 변경 없이 쉽게 이미지를 표시하고 성능 향상을 위해 필요에 따라 파일을 최적화할 수 있게 되었다. 기존에는 width height값을 적용하지 않으면 레이아웃이 깨지는 Layout shift가 발생하곤 했는데 Next.js 13에서는 이를 자동으로 처리해준다.\n\n- client-side JavaScript에서 image shift 현상 최소화\n- 웹 플랫폼에 맞게 조정\n- 스타일링과 설정이 더 편해짐\n- 기본적으로 `alt` 태그를 내장하여 접근성을 향상시킴 (필수)\n- 네이티브한 lazy 로딩은 hydartion이 필요없기 때문에 더 빠름\n- ⚠️ 기존에 사용되던 next/image 는 next/legacy/image path로 import 할 것.\n\n### CLS 방지\n\n> Next.js will automatically determine the width and height of your image based on the imported file. These values are used to prevent Cumulative Layout Shift while your image is loading.\n\n자동으로 width 랑 height 정보를 받아와서, CLS 를 막아준다. 하지만, 로컬 이미지 파일이 아닌 remote URL 기반이라면, 반드시 width와 height을 명시해주어야 한다.\n\n### Priority\n\nNext JS Image에는 priority 속성이 있는데 LCP(Largest Contentful Paint)를 줄일 수 있게 도와주는 기능이다. 쉽게 말하자면, 사용자 화면에 모든 UI 렌더링되는 최종 시간을 줄일 수 있다는 뜻이다. 이미지 용량이 커서, 렌더링 저하를 유발시킬 것 같은 이미지 컴퍼넌트에 아래와 같이 priority 속성을 줌으로서, next js 가 화면을 로딩할 때 해당 이미지 렌더링에 우선순위를 줘고 최종적으로 LCP를 줄일 수 있다고 한다.\n\n```js\nimport Image from \"next/image\"\n\nexport default function Home() {\n  return <Image src=\"/me.png\" alt=\"photo\" width={500} height={500} priority />\n}\n```\n\n## next/link\n\n- Link Component 안에 더이상 `<a>` 태그를 사용하지 않아도 된다.\n- Link 태그에도 props나 함수를 사용할 수 있다.\n\n```js\n// before\n<Link href=\"/about\">\n  <a onclick={()=>console.log('clicked')}>About</a>\n</Link>\n\n// after\n<Link href=\"/about\" onclick={()=>console.log('clicked')}>\n  About\n</Link>\n```\n"},{"excerpt":"🧐 NextJS란? NextJS : React에서 서버 사이드 렌더링을 간편하게 해주는 프레임워크 작동 원리 Next.js는, 기본적으로 서버측에서 React코드를 실행한다. React.js를 서버측에서 pre-rendering하여 html을 생성하고, 브라우저로 보내준다. 그 후, 브라우저에서 React를 사용해 웹페이지를 완성한다. ➡ 결과 : 속도가…","fields":{"slug":"/next-tutorial-01/"},"frontmatter":{"date":"November 05, 2022","title":"NextJS 작동 원리와 파일 구조","tags":["nextjs"]},"rawMarkdownBody":"\n## 🧐 NextJS란?\n\n> NextJS : React에서 서버 사이드 렌더링을 간편하게 해주는 프레임워크\n\n### 작동 원리\n\n1. Next.js는, 기본적으로 서버측에서 React코드를 실행한다.\n2. React.js를 서버측에서 pre-rendering하여 html을 생성하고, 브라우저로 보내준다.\n3. 그 후, 브라우저에서 React를 사용해 웹페이지를 완성한다. ➡ 결과 : 속도가 빠르고 SEO에 유리하다\n\n### 주요 기능\n\n- 직관적인 페이지 기반 라우팅 시스템( 동적 경로 지원 포함 )\n- 사전 렌더링, 정적 생성(SSG) 및 서버 측 렌더링(SSR) 모두 페이지 단위로 지원된다.\n- 자동 코드 분할! ( 빠른 로딩 )\n- 최적화된 프리페치를 통한 클라이언트 측 라우팅\n- 내장 CSS 및 Sass 지원 및 모든 CSS-in-JS 라이브러리 지원\n- Fast Refresh를 지원한다. ( 빠른 리프레쉬 )\n- Serverless Functions로 API 엔드포인트를 빌드하기 위한 API 경로\n\n## 🔎 React와 NextJs의 차이점\n\n### 1. library vs framework\n\n- React (library) : 필요할 때 불러와서 사용. 라우팅, 폴더 구조 등을 사용자가 직접 정해서 사용한다.\n\n- NextJS (framework) : 정해진 규칙에 맞춰 코드를 작성하면 앱이 실행됨. 라우팅, 폴더 구조를 커스텀할 수 없다.\n\n### 2. CSR vs SSR\n\n- React (CSR) : 브라우저가 javascript 파일에서 UI를 모두 다운받은 후 페이지가 출력된다.\n\n- NextJS (SSR) : 페이지가 먼저 렌더링된 후 (pre-rendering) API 등 필요한 javascript는 나중에 가져온다\n\n## 📚 File Structure\n\n```js\npublic  // 어플리케이션에 사용되는 정적 파일들\n└── assets\n     ├── images\n     └── icons\n\npages   // 페이지 라우팅 (파일/폴더명으로 url 결정)\n  ├── api\n  ├── product\n  │     └── [id].tsx\n  ├── _app.tsx\n  ├── _document.tsx\n  └── index.tsx\n\nsrc     // 그 외 필요한 sources 모음\n  ├── components\n  │   ├── common\n  │   └── layout\n  ├── styles\n  │   └── globals.css\n  ├── hooks\n  ├── types\n  └── utils\n```\n\n### \\_app.tsx\n\n- NextJS 실행 시 가장 먼저 실행되는 파일\n- 모든 페이지에서 쓰는 스타일, 레이아웃을 적용시키는 곳 (ex global.css)\n- google analytics , 검색엔진, 스크립트 분석 등에 사용\n\n```js\nimport type { AppProps } from \"next/app\"\nimport { AppLayout } from \"@components\"\nimport \"@styles/globals.scss\"\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <AppLayout>\n      <Component {...pageProps} />\n    </AppLayout>\n  )\n}\n```\n\n### \\_document.tsx\n\n- \\_app.js 다음으로 실행되는 파일\n- index.html 파일과 같은 역할 (`<meta>` 태그 & `<link>` 태그 추가)\n- html, body와 같은 기본 태그들의 속성을 지정하여 어플리케이션의 구조를 만들어 주는 파일\n\n```js\nimport { Html, Head, Main, NextScript } from \"next/document\"\n\nexport default function Document() {\n  return (\n    <Html>\n      <Head>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      <body>\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  )\n}\n```\n\n### pages\n\nReact에서는 react-router-dom을 설치하고 라우터를 직접 만들어야하지만 NextJS는 그렇지 않다.\n<br/> pages폴더 안에 파일이나 폴더를 만들면 라우팅 설정이 자동으로 이루어진다.\n\n- index.tsx 파일 : 메인 페이지 (localhost:3000)\n- 파일/폴더명 = URL 주소 ➡ 파일/폴더명에 해당하는 주소로 페이지가 라우팅된다.\n- 컴포넌트의 이름은 중요하지 않으나 반드시 `export default` 로 컴포넌트 작성 ❗❗.\n\n```js\npages\n  ├── about\n  │     ├── index.tsx        // localhost:3000/about\n  │     └── new.tsx          // localhost:3000/about/new\n  ├── product\n  │     └── [id]\n  │          ├── index.tsx   // localhost:3000/product/25\n  │          └── edit.tsx    // localhost:3000/product/25/edit\n  └── index.tsx              // localhost:3000\n```\n"},{"excerpt":"💻 CSR (Client Side Rendering) CSR은 JavaScript를 사용하여 직접 웹브라우저에서 페이지를 렌더링하는 것을 의미한다. \n모든 로직 및 데이터 가져오기, 템플릿 및 라우팅은 서버가 아닌 클라이언트(브라우저)에서 처리된다. 동작 순서 클라이언트 ➡ 서버 : 사이트 접속을 알림 서버 ➡ 클라이언트 : index.html 전송 \n처…","fields":{"slug":"/csr-ssr/"},"frontmatter":{"date":"August 12, 2022","title":"브라우저의 렌더링 종류 CSR vs SSR vs PR","tags":["webbrowser"]},"rawMarkdownBody":"\n## 💻 CSR (Client Side Rendering)\n\nCSR은 JavaScript를 사용하여 직접 웹브라우저에서 페이지를 렌더링하는 것을 의미한다. <br/>\n모든 로직 및 데이터 가져오기, 템플릿 및 라우팅은 서버가 아닌 클라이언트(브라우저)에서 처리된다.\n\n### 동작 순서\n\n<img src=\"https://user-images.githubusercontent.com/68415905/197331301-53b2d667-c03d-436f-8c3b-eb04c52ea7a1.png\" width=\"800\" />\n\n1. 클라이언트 ➡ 서버 : 사이트 접속을 알림\n2. 서버 ➡ 클라이언트 : index.html 전송 <br/>\n   처음 접속하면 다음과 같은 html을 내려받는다. 컨텐츠가 없는 텅 빈 html이기때문에 첫 화면은 빈 화면만 보인다.\n\n   > ```html\n   > <html>\n   >   <head>\n   >     ...\n   >   </head>\n   >   <body>\n   >     <div id=\"root\"></div>\n   >     <script src=\"app.js\"></script>\n   >   </body>\n   > </html>\n   > ```\n\n3. 클라이언트 ➡ 서버 : Javascript 파일 요청\n4. 서버 ➡ 클라이언트 : `app.js` 파일 전송 (용량이 커서 초기 로딩시간이 길다.) <br/>\n   Javascript 로직 뿐 아니라 이를 구동시키는 프레임워크, 라이브러리의 코드도 모두 포함해서 전송한다 <br/>\n\n### 장점\n\n- 페이지가 로드된 후, 리렌더링할 때는 필요한 리소스만 교체하므로 로딩이 빠르다.\n- 서버로 데이터를 요청하는 횟수가 적다.\n\n### 단점\n\n- 사용자가 첫 화면을 보기까지 **초기 로딩시간(Time To View)이 길다.**\n- **낮은 SEO (Search Engine Optimization)** : 네이버나 구글 등의 검색엔진은 서버에 등록된 사이트를 돌아다니며 html문서를 분석해서 사용자가 검색을 빠르게 할 수 있도록 도와준다. 하지만 CSR은 html이 텅 비어있기 때문에 SEO 분석에 취약하다.\n\n<br/>\n\n## 📲 SSR (Server Side Rendering)\n\nSSR은 CSR와 다르게 웹사이트에 접속하면 서버측에서 필요한 데이터를 모두 가져와 html파일을 생성하여 클라이언트로 보내준다. 처음부터 서버에서 컨텐츠가 포함된 html을 가져오기때문에 로딩속도가 빠르고 효율적인 SEO가 가능하다. SSR을 사용하면 클라이언트(사용자 기기)의 사양에 의존하지 않고, 고사양 서버에서 HTML을 구축할 수 있다.\n\n### 동작 순서\n\n<img src=\"https://user-images.githubusercontent.com/68415905/197331299-9de64557-829a-412e-a3c1-7ce786d847b2.png\" width=\"800\" />\n\n1. 클라이언트 ➡ 서버 : 사이트 접속을 알림\n2. 서버 ➡ 클라이언트 : index.html 전송<br/>\n   로딩 시, 서버에서 필요한 데이터를 모두 가져와 잘 짜여진 html파일을 전송한다.\n3. 클라이언트 ➡ 서버 : Javascript 파일 요청\n4. 서버 ➡ 클라이언트 : app.js 전송\n\n### 장점\n\n- 검색엔진 최적화 (SEO)에 유리하다.\n- 페이지가 보여지는 시간이 빠르다.\n\n### 단점\n\n- 페이지 이동 시, 매번 새로운 html파일을 요청해서 가져오기때문에, 페이지 깜박임현상이 발생한다.\n- 브라우저가 해야 할 일을 서버가 대신 처리하므로 서버 렌더링에 따른 부하가 발생한다.\n- html가 로드된 이후에 js를 요청하기때문에, js가 완전히 로드되지 않은경우 페이지가 제대로 작동을 하지 않을 수 있다.\n\n## 📱 Progressive Rendering\n\nServer Side Rendering 기술 중 하나. 예시로 구글 검색 페이지가 있다. 검색을 하면 상단의 검색창과 메뉴 버튼은 빠르게 뜨고 조금 기다리면 검색 결과가 출력된다.\n또 다른 예시는 네이버 메인페이지다. 정보량이 많지만 빠르게 출력된다.\n\n### 동작순서\n\n1. HTML 요청\n2. 중요도가 높은 HTML 문서를 먼저 렌더링하고 클라이언트로 전달\n3. 클라이언트에서 페인팅\n4. 다음 중요도인 HTML 문서를 렌더링하고 클라이언트로 전달\n5. 클라이언트에서 페인팅\n\n<br /><br />\n\n> REFERENCE <br /> 네이버 블로그 https://blog.naver.com/jasonrewriter/222220034926 <br /> Youtube DreamCoding https://www.youtube.com/watch?v=iZ9csAfU5Os&t=277s\n"},{"excerpt":"Brower Rendering 1. 주소 입력 클라이언트측에서 URL을 통해 서버로 요청을 보낸다. 2. HTML 파일 다운로드 서버는 클라이언트가 요청한 URL에 따라 결과물을 만들어서 응답한다. 이때, 리턴값은 HTML 파일일 수도 있고, JSON일 수도 있고, 이미지 등의 파일일 수도 있다. 아래의 경우에는 HTML 파일을 반환하며, 브라우저가 가장…","fields":{"slug":"/rendering/"},"frontmatter":{"date":"August 11, 2022","title":"브라우저의 렌더링 과정","tags":["webbrowser"]},"rawMarkdownBody":"\n## Brower Rendering\n\n### 1. 주소 입력\n\n클라이언트측에서 URL을 통해 서버로 요청을 보낸다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/a9db8eaf-7c20-431d-872b-c8342c99ed41/Untitled%201.png\" width=\"600\" align=\"left\" />\n\n### 2. HTML 파일 다운로드\n\n서버는 클라이언트가 요청한 URL에 따라 결과물을 만들어서 응답한다. 이때, 리턴값은 HTML 파일일 수도 있고, JSON일 수도 있고, 이미지 등의 파일일 수도 있다.\n\n아래의 경우에는 HTML 파일을 반환하며, 브라우저가 가장 첫번째로 다운로드 받는 것이 HTML이다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/b2e69eaa-2f6d-4567-a1c9-d4c28a2a47f1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-09-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.42.31.png\" width=\"900\" />\n\n### 3. CSS, JS 다운로드\n\nHTML 파일을 파싱하는 과정에서 만나는 CSS, JS 등의 모듈들을 다운로드 한다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/23eea083-3978-4860-a7e8-3c6c435ae12f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-09-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.47.45.png\" width=\"950\" />\n\n### 4. 네트워크 연결 제한 (HTTP 1.1)\n\n브라우저마다 한번에 다운로드할 수 있는 모듈의 개수가 정해져 있다. 아래 표는 Max Connection per Domain으로 하나의 도메인으로부터 다운로드 받을 수 있는 모듈의 개수이다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/b0b9c1c2-99b5-4887-b3f7-d0ff9c17dadf/Untitled%202.png\" width=\"300\"  />\n\n브라우저는 보통 한번에 6개의 모듈을 하나의 도메인으로부터 다운로드 받을 수 있다. 이는 HTTP 1.1에 해당하며 HTTP2는 제한 사항이 다르며 6개 이상도 동시 요청할 수 있다. 아래에 조금 더 상세히 설명한다.\n\n여러 도메인으로부터 다운로드 받으면 6개 이상의 모듈을 동시에 다운로드 받을 수 있고, 몇백~몇천개의 모듈을 동시에 다운로드 받을 수 있어서 제한이 거의 없다고 봐도 된다. 따라서 동시 연결 제한을 우회하는 방법으로 여러 서브 도메인으로부터 모듈을 다운로드 받는 방법이 있다. (도메인 샤딩)\n\n### 5. DOM Tree, CSSOM Tree 생성\n\nHTML, CSS 파일을 다운로드한 뒤 구문 분석과정을 거쳐 DOM 트리와 CSSOM 트리를 만든다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/140a2a67-040d-4167-80ab-5dae6dfcf81e/Untitled%207.png\" width=\"470\" align=\"left\"/>\n<img src=\"https://images.velog.io/images/bumsu0211/post/c75189bb-3613-4dfa-be71-7404fb6ba480/Untitled%208.png\" width=\"470\" align=\"left\" />\n\n### 6. Render Tree 생성\n\nDOM 트리와 CSSOM 트리를 기반으로 실제로 화면에 표시하는 객체들로 구성된 Render 트리를 만든다.\n\nRender 트리의 각 노드는 DOM 객체에 스타일이 붙어있는 형태이며, display: none 스타일을 갖는 DOM 객체는 Render 트리에서 탈락한다.\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/0c3bd724-a2b3-45bc-bbdc-5a14b9fb9994/Untitled%209.png\" width=\"900\" />\n\n### 7. Layout\n\nRender 트리를 기반으로 DOM 객체의 위치를 잡는 레이아웃 과정을 진행한다. 브라우저 화면에서 어디에 위치하며, 크기는 얼마로 해야하는지 계산하는 단계이다\n\n<img src=\"https://images.velog.io/images/bumsu0211/post/5a539af6-1d12-4b8d-b118-a98a4c789869/Untitled%2010.png\" width=\"600\" />\n\n### 8. Paint\n\n레이아웃 과정 후에 실제로 요소들을 그리는 과정\n\n### 9. JS 실행\n\n자바스크립트 파일도 다운로드 후 자바스크립트 엔진에 의해 실행된다. 반복되는 코드는 JIT 컴파일러에 의해 컴파일 된다. JIT 컴파일러의 동작과정은 아래 링크에서 확인할 수 있다.\n\n자바스크립트까지 실행되면 비로소 개발자가 의도한 화면이 브라우저에 표시된다.\n\n<br /><br />\n\n> REFERENCE <br /> 벨로그 https://velog.io/@bumsu0211/\n"},{"excerpt":"📚 노드의 주요 특성 1. 이벤트 기반 노드는 이벤트 발생 시 미리 지정해둔 작업을 수행하는 이벤트 기반으로 작동합니다. 이벤트가 생기면 해당 이벤트에 대한 함수를 Event Listener에서 찾아 Callback 함수를 호출합니다. 이벤트의 예: 클릭, 네트워크 요청, 타이머 등 Event Listener : 이벤트를 등록하는 함수 Callback 함…","fields":{"slug":"/node-tutorial-03/"},"frontmatter":{"date":"August 02, 2022","title":"[Node] 노드의 주요 특성 Non Blocking / Single Thread","tags":["nodejs"]},"rawMarkdownBody":"\n## 📚 노드의 주요 특성\n\n### 1. 이벤트 기반\n\n노드는 이벤트 발생 시 미리 지정해둔 작업을 수행하는 **이벤트 기반**으로 작동합니다. 이벤트가 생기면 해당 이벤트에 대한 함수를 Event Listener에서 찾아 Callback 함수를 호출합니다.\n\n- 이벤트의 예: 클릭, 네트워크 요청, 타이머 등\n- Event Listener : 이벤트를 등록하는 함수\n- Callback 함수 : 이벤트가 발생했을 때 실행될 함수\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183243780-a2bba588-6e90-4c0b-a704-ea1d9498d882.JPG\" width=\"430\" />\n\n### 2. Non Blocking I/O\n\n> Non Blocking : 오래 걸리는 함수를 백그라운드로 보낸 후 다음 코드를 먼저 실행하고 나중에 오래 걸리는 함수를 실행하는 방식\n\n블로킹은 이전 작업이 끝난 후 다음 작업을 실행 하는 순차적인 방식이며 논블로킹은 대기없이 모든 작업에 대한 요청을 먼저 받고 동시적으로 실행하는 방식을 뜻합니다. 주로 I/O 작업 (파일 시스템 접근, 네트워크 요청), 압축, 암호화 등이 논블로킹 방식으로 백그라운드에서 병렬로 동시 실행되며 그 외에는 블로킹 방식을 사용합니다. I/O 작업이 많을 때 노드 활용성이 극대화됩니다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183245019-0fa3173a-136f-4790-8c80-b5e4eb05a9a6.JPG\" width=\"1000\" />\n\n### 3. Single Thread\n\n### - 프로세스 & 스레드\n\n기본적으로 프로그램 1개당 프로세스가 1개 실행됩니다. 실행된 프로세스에서 1개의 작업만 가능하면 싱글 스레드, 다양한 작업을 할 수 있으면 멀티 스레드라고 합니다. 노드 프로세스는 멀티 스레드처럼 보이지만 직접 다룰 수 있는 스레드는 하나이기 때문에 싱글 스레드라고 표현합니다. 노드 버전 14부터는 멀티 스레드도 사용 가능하나 멀티 스레드 대신 멀티 프로세스를 주로 사용합니다.\n\n- 프로세스 : 운영체제에서 할당하는 작업의 단위, 프로세스 간 자원 공유 X\n- 스레드 : 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스 자원 공유\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183243737-c55bd301-75e5-4343-8d92-f706022ecbbf.JPG\" width=\"550\" />\n\n### - 싱글 스레드란?\n\n싱글 스레드는 요청에 대한 작업을 1개씩 처리하는 방식입니다. 그래서 블로킹이 발생하면 나머지 작업은 모두 대기해야해서 효율이 떨어지는 단점이 있습니다. Node는 이런 단점을 보완하기 위해 논블로킹 모델을 채택하여 일부 코드(I/O)를 백그라운드 (다른 프로세스) 에서 실행 가능하도록 만들었습니다.\n\n- 장점 : 프로그래밍 난이도가 쉽고 CPU, 메모리 자원을 적게 사용\n- 단점 : 에러 발생 시, 프로그램이 멈춤\n\n### - 멀티 스레드와 비교\n\n노드 14버전에서는 멀티 스테드를 사용할 수 있도록 worker_threads 모듈을 도입했습니다. CPU를 많이 사용하는 작업에 활용에 적합합니다. 하지만 프로그래밍이 어렵고 자원의 사용이 많다는 문제점으로 멀티 스레드 대신 멀티 프로세스를 더 선호합니다.\n\n- 장점 : 에러 발생 시, 새로운 스레드를 생성하고 극복 가능\n- 단점 : 새로운 스레드 생성 혹은 동작하지 않는 스레드에 대한 비용이 발생, 프로그래밍 난이도가 어려움, 스레드 개수만큼 자원을 많이 사용함\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183243734-4e24dab8-e7f4-4be4-b64b-5832856d5bad.JPG\" width=\"650\" />\n\n<br /><br /><br />\n\n> REFERENCE <br /> Node.js 교과서 개정 2판 https://thebook.io/080229/ch01/01/\n"},{"excerpt":"🚀 호출스택과 이벤트 루프 1. 호출 스택 (call stack) 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견하면 호출한 함수를 호출 스택에 넣고, 함수가 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 호출 스택에서 지워집니다. (Last In First Out) 함수는 호출 순서대로 스택에 쌓인 후, 역순…","fields":{"slug":"/node-tutorial-02/"},"frontmatter":{"date":"July 31, 2022","title":"[Node] 호출스택과 이벤트 루프","tags":["nodejs"]},"rawMarkdownBody":"\n## 🚀 호출스택과 이벤트 루프\n\n### 1. 호출 스택 (call stack)\n\n노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견하면 호출한 함수를 호출 스택에 넣고, 함수가 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 호출 스택에서 지워집니다. (Last In First Out)\n\n```js\nfunction first() {\n  second()\n  console.log(\"첫번째\")\n}\nfunction second() {\n  third()\n  console.log(\"두번째\")\n}\nfunction third() {\n  console.log(\"세번째\")\n}\n```\n\n함수는 호출 순서대로 스택에 쌓인 후, 역순으로 실행됩니다. 이때, 스택 가장 아래에 쌓이는 anonymous는 파일이 실행되면 만들어지는 가상의 실행 환경 (global context)를 의미합니다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183275903-67f4f44d-2a1a-4009-b384-2a20c7003456.JPG\" alt='' width=\"500\" />\n\n### 2. 이벤트 루프\n\n호출 스택 내부의 함수는 순차적, 동기적으로 실행됩니다. 그래서 setTimeout과 같은 비동기 함수는 호출 스택만으로는 정의하기가 어렵습니다. 이를 파악하기 위해서는 이벤트 루프, 태스크 큐(task queue), 백그라운드(background)를 알아야 합니다.\n\n```js\nfunction run() {\n  console.log(\"3초 후 실행\")\n}\nconsole.log(\"시작\")\nsetTimeout(run, 3000)\nconsole.log(\"끝\")\n```\n\n- 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부릅니다.\n\n- 백그라운드: setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳입니다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 됩니다. 여러 작업이 동시에 실행될 수 있습니다.\n\n- 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보냅니다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부릅니다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 합니다.\n\n<br>\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183276969-638c31c2-cdf0-4afa-9ae9-649e9151c6de.jpg\" alt='' width=\"550\" />\n\n<hr>\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183276970-efde2d93-ddd2-4014-bc53-da8343168547.jpg\" alt='' width=\"550\" />\n\n<hr>\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183276971-006e63b0-c613-41de-8be3-01779662b58b.jpg\" alt='' width=\"550\" />\n\n<hr>\n<br /><br /><br />\n\n> REFERENCE <br /> Node.js 교과서 개정 2판 https://thebook.io/080229/ch01/01/\n"},{"excerpt":"🔎 Node란? Nodejs : Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임 공식문서에서의 노드는 Javascript 런타임이라고 표현되어 있습니다. 하지만 대부분은 Node를 서버 실행을 위해 사용합니다. 여기서 '서버'와 '런타임'은 무엇이고 어떤 차이가 있을까요? 서버로서의 노드 네트워크는 요청과 응답을 주고받으며…","fields":{"slug":"/node-tutorial-01/"},"frontmatter":{"date":"July 27, 2022","title":"[Node] 서버와 런타임 개념 이해하기","tags":["nodejs"]},"rawMarkdownBody":"\n## 🔎 Node란?\n\n> Nodejs : Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임\n\n[공식문서에서의 노드](https://nodejs.org/ko/)는 Javascript 런타임이라고 표현되어 있습니다. 하지만 대부분은 Node를 서버 실행을 위해 사용합니다. 여기서 '서버'와 '런타임'은 무엇이고 어떤 차이가 있을까요?\n\n### 서버로서의 노드\n\n네트워크는 요청과 응답을 주고받으며 끊임없이 통신합니다. 이때, 요청을 보내는 주체를 클라이언트, 요청에 응답하는 주체를 서버라고 합니다. 다시말해 서버란 네트워크 상에서 클라이언트에게 요청에 대한 정보 및 서비스를 제공하는 프로그램을 뜻합니다.<br>\n예) Client : 주소창에 홈페이지 URL을 입력 (요청) ➡ Server : 해당 URL에 대한 정보를 브라우저에 출력 (응답)\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183243977-9994702a-5372-4a94-bbf0-5498bab69847.JPG\" width=\"500\" />\n\n그리고 Node의 가장 큰 특징 중 하나가 Node에서 서버를 만들 수 있는 모듈(ex http)을 제공한 다는 것입니다. Node 자체는 서버가 아니지만 Node가 제공하는 서버 구성 모듈을 사용해서 Javascript로 작성된 서버를 만들고 실행할 수 있습니다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/183244730-41d34478-3464-45b7-92e5-aedc28233c88.JPG\" width=\"750\" />\n\n### 런타임으로서의 노드\n\n- 대표적인 Javascript 런타임 : **웹 브라우저(크롬, 사파리 등)**\n\n런타임은 프로그래밍 언어가 실행되는 환경을 뜻합니다. 그렇다면 Javascript 런타임이란 Javascript를 실행하는 환경을 뜻합니다.\nNode.js 가 나오기 전에는 Javascript를 인터넷 브라우저에서만 실행할 수 있었습니다. 하지만 node.js라는 새로운 Javascript 런타임의 등장으로 브라우저 외부에서도 Javascript를 실행할 수 있게 되었습니다. (ex 웹 프레임 워크 : Angular, React, Vue 등..)\n\n<br />\n\n> REFERENCE <br /> Node.js 교과서 개정 2판 https://thebook.io/080229/ch01/01/\n"},{"excerpt":"✨ StompJS 란? stomp : 단순 <또는 스트리밍) 텍스트 지향 메시징 프로토콜. spring에 종속적. StompJS Docs stomp 설치 최근 브라우저는 모두 socket을 지원하지만 IE 9 이하에서는 사용이 불가능합니다. 브라우저 대응이 필요한 경우, 를 추가로 설치하여 사용합니다.  (@types 패키지는 typescript를 사용하…","fields":{"slug":"/sockjs/"},"frontmatter":{"date":"May 10, 2022","title":"Stomp.JS 로 채팅방 구현하기","tags":["sockjs"]},"rawMarkdownBody":"\n## ✨ StompJS 란?\n\n> stomp : 단순 <또는 스트리밍) 텍스트 지향 메시징 프로토콜. spring에 종속적.<br/> [StompJS Docs](https://stomp-js.github.io/guide/stompjs/upgrading-stompjs.html)\n\n### stomp 설치\n\n최근 브라우저는 모두 socket을 지원하지만 IE 9 이하에서는 사용이 불가능합니다. 브라우저 대응이 필요한 경우, `socketjs-client`를 추가로 설치하여 사용합니다.\n\n- `stompjs` (@types 패키지는 typescript를 사용하는 경우에만 설치)\n\n```bash\nnpm i @stomp/stompjs, @types/stompjs\n```\n\n- `socketjs-client` : 브라우저 대응이 필요한 경우 추가 설치\n\n```bash\nnpm i socketjs-client, @types/socketjs-client\n```\n\n### stomp flow\n\n1. 서버와 연결할 클라이언트 객체 생성\n\n2. 서버와 연결할 클라이언트 Connection\n\n3. 메세지 전송 전 Subscriber와 Publisher를 지정\n\n4. Subscribe를 하면 해당 URL로 나에게 메세지를 보낼 수 있는 경로가 생긴다\n\n5. Publisher를 하면 Publish한 URL로 메세지가 이동한다\n\n## 🔎 StompJS 사용하기\n\n### 새 클라이언트 생성\n\n설치한 패키지를 import한 후 client 객체를 생성합니다. [properties 더보기](https://stomp-js.github.io/api-docs/latest/classes/Client.html#connectHeaders)\n\n```js\nimport SockJS from \"sockjs-client\"\nimport StompJs from \"@stomp/stompjs\"\n```\n\n```js\nconst client = new StompJs.Client({\n  brokerURL: \"ws://localhost:8888/ws\", // server 주소 (or endpoint)\n  connectHeaders: {\n    login: \"user\",\n    passcode: \"password\",\n  }, // optional\n  debug: function (str) {\n    console.log(str) // optional\n  },\n  reconnectDelay: 5000, // optional\n  heartbeatIncoming: 4000, // optional\n  heartbeatOutgoing: 4000, // optional\n})\n```\n\n- `brokerURL` : 서버 API 주소. http주소는 ws로, https주소는 wss로 변경합니다.\n- `connectHeaders` : stomp 연결 시, 서버에서 식별자로 사용됨 (HTTP 연결 헤더 ❌)\n- `debug` : 각 동작에 대한 정보를 console로 확인 가능\n- `reconnectDelay` : stomp 서버 자동 연결 간격\n- `heartbeatIncoming` & `heartbeatOutgoing` : socket 연결 상태 확인 주기\n\n### 소켓 connection\n\n연결됐을때 실행할 함수와 에러처리를 담당하는 함수를 생성하고 클라이언트를 활성화 시켜줍니다.\n\n```js\nclient.onConnect = function (frame) {\n  // Do something, all subscribes must be done is this callback\n  // This is needed because this will be executed after a (re)connect\n}\n\nclient.onStompError = function (frame) {\n  // Will be invoked in case of error encountered at Broker\n  // Bad login/passcode typically will cause an error\n  // Complaint brokers will set `message` header with a brief message. Body may contain details.\n  // Compliant brokers will terminate the connection after any error\n  console.log(\"Broker reported error: \" + frame.headers[\"message\"])\n  console.log(\"Additional details: \" + frame.body)\n}\n\nclient.activate()\n```\n\n- 소켓 미지원 브라우저 대응\n\n```js\nif (typeof WebSocket !== \"function\") {\n  client.webSocketFactory = function () {\n    return new SockJS(\"http://localhost:8080/stomp\")\n  }\n}\n```\n\n### 소켓 disconnection\n\n```js\nconst disConnect = () => {\n  if (client != null) {\n    if (client.connected) client.deactivate()\n  }\n}\n\nuseEffect(() => {\n  connect()\n  return () => disConnect()\n}, [])\n```\n\n### 메세지 보내기\n\n클라이언트와 서버가 연결 되면 publish 메서드를 사용하여 메세지를 보낼 수 있습니다. destination는 목적지라는 뜻입니다 어디로 메세지를 보낼지를 결정합니다.\n\nbody는 보낼 내용입니다.\n\n```js\nconst sendMessage = (text: string) => {\n  if (client != null) {\n    if (!client.connected) return\n    const message = { userId: 36, message: text }\n    client.publish({\n      destination: SEND_MESSAGE_API(room?.id),\n      body: JSON.stringify(message),\n    })\n  }\n}\n```\n\nv5부턴 바이너리 메세지 전송도 지원된다고 하네요! (header에 'content-type': 'application/octet-stream')로 contentType을 써줍니다.)\n\n```js\nconst binaryData = generateBinaryData()\nclient.publish({\n  destination: \"/topic/special\",\n  binaryBody: binaryData,\n  headers: { \"content-type\": \"application/octet-stream\" },\n})\n```\n\n### 메세지 받기\n\n```js\nconst getMessage = () => {\n    if (client != null && client.connected) {\n      client.subscribe(GET_MESSAGE_API(room?.id), () => {\n        const newMessage: string = JSON.parse(data.body).message as string;\n        addContent(newMessage);\n      });\n    }\n  };\n```\n\n<br /><br />\n\n> REFERENCE<br /> WebSoket (stompJS+React) 채팅 https://velog.io/@cksal5911/WebSoket-stompJSReact-%EC%B1%84%ED%8C%85-1 <br/> react stomp.js으로 소켓 통신과정 https://okky.kr/article/1152048\n"},{"excerpt":"🔎 Socket.io 란? Socket.io 👉 Websocket 기반으로 웹 클라이언트와 서버 간의 실시간 양방향 통신을 가능하게 해주는 Cross-platform WebSocket API Socket.io는 WebSocket을 편리하게 쓸 수 있도록 하는 라이브러리입니다. 브라우저간의 호환성을 높이고 이라는 기능을 이용해 일부 Client에만 데이터를…","fields":{"slug":"/socketio/"},"frontmatter":{"date":"April 27, 2022","title":"Socket.io 기능 알아보기","tags":["websocket"]},"rawMarkdownBody":"\n## 🔎 Socket.io 란?\n\n> **Socket.io** 👉 Websocket 기반으로 웹 클라이언트와 서버 간의 실시간 양방향 통신을 가능하게 해주는 Cross-platform WebSocket API\n\nSocket.io는 WebSocket을 편리하게 쓸 수 있도록 하는 라이브러리입니다. 브라우저간의 호환성을 높이고 `room`이라는 기능을 이용해 일부 Client에만 데이터를 전송하는 브로드캐스팅이 가능합니다. 아래 구현 예시를 통해 더 자세히 알아보겠습니다.\n\n### 서버 Socket 구현\n\n1. Socket 패키지를 설치합니다\n\n```bash\nnpm i socket.io\n```\n\n2.  app서버 생성 후 소켓IO에 생성한 서버를 전달하고 동작시킨다\n\n```js\nconst app = require(\"express\")()\nconst SocketIO = require(\"socket.io\")\n\nconst server = app.listen(8005, () => {})\nconst io = SocketIO(server, { path: \"/socket.io\" })\n// 서버 연결, path는 프론트와 일치시켜준다.\n// path: 이 경로를 통해 통신을 수행하며, 생략시 디폴트 값은 /socket.io 로 지정된다.\n```\n\n3. 소켓 연결에 성공하면 각 이벤트에 대한 코드를 작성합니다.\n\n   (`addEventListener` 방식을 사용)\n\n```js\n// 웹소켓 연결 시\nio.on('connection', (socket) => {\n  // 연결 종료 Event\n  socket.on('disconnect', () => {\n    console.log('클라이언트 접속 해제', ip, socket.id);\n  }\n\n  // 에러 발생 Event\n  socket.on('error', (error) => {\n    console.error(error);\n  });\n}\n```\n\n### 클라이언트 Socket 구현\n\n1. Socket 패키지를 설치합니다 (client버전)\n\n```bash\nnpm i socket.io-client\n```\n\n2. Socket을 불러와서 Server로 데이터를 전송하는 코드를 작성합니다.\n\n```js\nimport { io } from \"socket.io-client\"\nconst socket = io(\"http://localhost:3000\") // server url 전달\n\nsocket.on(\"connect\", () => {\n  displayMessage(`You connected with id : ${socket.id}`)\n})\n```\n\n<br/>\n\n## 🔀 데이터 교환 방식 (emit & on)\n\n- 데이터 전송 : `emit`\n\n```js\nsocket.emit(\"event-name\", data)\n```\n\n- 데이터 수신 : `on`\n\n```js\nsocket.on(\"event-name\", data => {\n  console.log(data)\n})\n```\n\n### 예시\n\n1. Client에서 데이터를 전송한다.\n\n```js\nconst message = messageInput.value\nsocket.emit(\"send-message\", message)\n```\n\n2. Server는 Client로부터 데이터를 받은 후 다시 Client에 전달한다.\n   - `io.emit` : Client가 가진 모든 소켓에 데이터 전송\n\n```js\nio.on(\"connection\", socket => {\n  socket.on(\"send-message\", message => {\n    io.emit(\"receive-message\", message)\n  })\n})\n```\n\n3. Client에서 데이터를 출력한다.\n\n```js\nsocket.on(\"receive-message\", message => {\n  displayMessage(message)\n})\n```\n\n<br/>\n\n## 📝 그외 Socket.io 기능들\n\n### broadcast\n\n`socket.broadcast.emit` : 데이터를 전송한 socket을 제외한 모든 socket에 데이터 전달\n<br/> ex) A가 보낸 메세지는 A를 제외한 B,C에 전달됨\n\n```js\nio.on(\"connection\", socket => {\n  socket.on(\"send-message\", message => {\n    socket.broadcast.emit(\"receive-message\", message)\n  })\n})\n```\n\n### room\n\n`socket.to(room).emit` : 특정한 socket에만 데이터를 전송해야하는 경우 room을 생성하여 room에 속한 socket에만 데이터를 보낼 수 있는 기능입니다.\n\n1. Client에서 room을 생성한 후 Server에 전달합니다.\n\n```js\njoinRoomButton.addEventListener(\"click\", () => {\n  const room = roomInput.value\n  socket.emit(\"join-room\", room)\n})\n```\n\n2. Client로부터 전달받은 room값을 Server에 저장합니다.\n\n```js\nio.on(\"connection\", socket => {\n  socket.on(\"join-room\", room => {\n    socket.join(room)\n  })\n})\n```\n\n3. 특정 room에 데이터를 보내는 경우, Client에서 데이터와 room 정보를 함께 전송합니다\n\n```js\nconst message = messageInput.value\nconst room = roomInput.value\nsocket.emit(\"send-message\", message, room)\n```\n\n4. Server에서 특정 room으로 데이터를 전송합니다. `socket.to(room)`\n\n```js\nio.on(\"connection\", socket => {\n  socket.on(\"send-message\", (message, room) => {\n    if (room) {\n      socket.to(room).emit(\"receive-message\", message)\n      // to(room)은 broadcast 특징을 함께 가짐\n    }\n  })\n})\n```\n\n<br /><br />\n\n> REFERENCE<br /> Learn Socket.io In 30 Minutes https://youtu.be/ZKEqqIO7n-k <br/> Socket.io란 https://nesoy.github.io/articles/2017-04/Socket.io<br/>Dev Scroll https://inpa.tistory.com/entry/SOCKET-📚-SocketIO-사용-해보기\n"},{"excerpt":"✨ Socket 이란? 네트워트 상에서 Socket은 프로토콜, IP 주소, 포트 넘버 등으로 해석됩니다. 떨어져 있는 두 호스트를 연결해주는 도구로 사용되며 Socket을 통해 데이터를 내보내거나 받아올 수 있는 데이터 통로가 만들어 집니다. 소켓의 역할에 따라 클라이언트 소켓, 서버소켓으로 구분됩니다. WebSocket 사용자의 브라우저와 서버 사이의…","fields":{"slug":"/about-socket/"},"frontmatter":{"date":"April 20, 2022","title":"Socket 통신의 특징 및 프로토콜의 종류","tags":["websocket"]},"rawMarkdownBody":"\n## ✨ Socket 이란?\n\n네트워트 상에서 Socket은 프로토콜, IP 주소, 포트 넘버 등으로 해석됩니다. 떨어져 있는 두 호스트를 연결해주는 도구로 사용되며 Socket을 통해 데이터를 내보내거나 받아올 수 있는 데이터 통로가 만들어 집니다. 소켓의 역할에 따라 클라이언트 소켓, 서버소켓으로 구분됩니다.\n\n### WebSocket\n\n> 사용자의 브라우저와 서버 사이의 양방향 연결 채널을 구성하는 HTML5 프로토콜\n\nWebSocket은 HTML5 웹 표준 기술로써 HTTP 통신의 단점을 보완하여 양방향 통신을 지원하고 또 서버와의 연결이 유지가 된 상태에서 데이터가 이동하기 때문에 실시간 데이터 전송이 가능합니다.\n\n데이터를 주고 받는것 이외의 다른 기능은 없으나 동작 속도가 매우 빠르며 통신할 때 아주 적은 데이터를 이용합니다. 그래서 주로 가상화폐 거래소나 규모가 큰 데이터 이동이 많은 프로젝트에서 사용합니다. Websocket은 오래된 브라우저와 호환이 되지 않는 단점이 있습니다.\n\n## 🤔 HTTP 통신과 Socket 통신 비교\n\n### HTTP 통신 (stateless)\n\n> Client의 요청(Request)이 있을 때만 Server가 응답(Response)하여 정보를 전송한 후 연결을 종료하는 통신\n\nHTTP통신은 실시간 연결보다는 필요할 때 Server로 요청을 보내는 상황에 유리합니다.\n\n- 단방향 통신 : Client가 요청을 보내는 경우에만 Server가 응답합니다.\n- 일회성 통신 : Server로부터 응답을 받은 후에는 연결이 바로 종료됩니다.\n\n### Socket 통신 (statefull)\n\n> Server와 Client가 특정 Socket(Port)를 통해 실시간으로 양방향 통신을 하는 방식\n\nSocket 통신은 동영상 스트리밍이나 채팅창 등 실시간으로 데이터를 주고받을 때 사용됩니다.\n\n- 양방향 통신 : Client에서 Server로, Server에서 Client로 데이터 전달이 가능합니다.\n- 지속성 통신 : 연결이 끊이지 않고 실시간으로 계속 유지됩니다.\n\n## 💡 WebSocket 통신의 특징\n\nSocket 통신은 hand-shake 방식으로 Client와 Server 접속을 유지한 채 데이터를 주고 받기때문에 양방향 통신이 가능합니다.\n\n> handshake란? 송신자와 수신자간에 암호화된 데이터를 교환할 때 필요한 협상과정\n\nClient에서 랜덤하게 생성된 키값을 전송하고, Server는 이 키값을 바탕으로 토큰을 생성하여 Client에 Response를 보내어 Client와 Server간의 handShaking이 이루어 집니다. 채팅, 실시간 화상통화 등 양방향 통신에 아주 유용하게 쓰이고 있습니다.\n\n## ✅ WebSocket 프로토콜의 종류\n\n일반적으로 Node.js 를 이용할땐 socket.io 를,<br/>\nSpring을 사용할땐 socket.js, stomp.js를 사용합니다.\n\n### socket.io\n\n인터넷 익스플로러 구버전의 사용자는 websocket으로 작성된 웹페이지를 볼 수 없습니다. 이를 해결하기위해 socket.io는 웹페이지가 열리는 브라우저가 websocket을 지원하면 일반 websocket방식으로 동작하고 지원하지 않는 브라우저라면 http를 이용해 websocket을 흉내내는 방식으로 통신을 지원합니다. socket.io는 nodeJS에 종속적 입니다.\n\n### sock.js\n\n위와 같은 브라우저 문제를 해결하기 위한 방법으로 Spring에서는 sockJS를 솔루션으로 제공합니다. 서버 개발시 일반 websocket으로 통신할지 sockJS 호환으로 통신할지 결정할 수 있습니다. 그리고 클라이언트는 sockJS client를 통해 서버와 통신합니다.\n\n### stomp.js\n\nstomp는 단순 (또는 스트리밍) 텍스트 지향 메시징 프로토콜입니다. spring에 종속적이며, 구독방식으로 사용하고 있습니다. 가벼워서 sockJs와 주로 함께 사용합니다.\n\n<br /><br />\n\n> REFERENCE<br /> Learn Socket.io In 30 Minutes https://youtu.be/ZKEqqIO7n-k <br/> 소켓(Socket) 통신이란? https://helloworld-88.tistory.com/215\n"},{"excerpt":"🎉 firebase 프로젝트 생성 Firebase 에 접속하여 새로운 프로젝트를 생성합니다. 👉 Firebase 바로가기 프로젝트 이름을 입력합니다. Analytics가 필요하지 않으면 OFF 프로젝트에 해당하는 앱을 추가합니다. (ios / android / web) 먼저 1)앱 이름을 정하고 2)생성되는 config 코드를 복사합니다. (프로젝트 배포…","fields":{"slug":"/google-auth-firebase/"},"frontmatter":{"date":"March 17, 2022","title":"구글 로그인 기능 with Firebase","tags":["firebase","auth"]},"rawMarkdownBody":"\n## 🎉 firebase 프로젝트 생성\n\n1. Firebase 에 접속하여 새로운 프로젝트를 생성합니다. 👉 [Firebase 바로가기](https://console.firebase.google.com/u/1/)\n\n<img src=\"https://user-images.githubusercontent.com/68415905/158337784-a2053611-e4c2-47f1-9ea8-6a6a3f9d6448.jpg\" width=\"600\" />\n\n2. 프로젝트 이름을 입력합니다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/158343612-0438483d-57db-400e-9d7c-eec6deb1c908.JPG\" width=\"600\" />\n\n3. Analytics가 필요하지 않으면 OFF\n\n<img src=\"https://user-images.githubusercontent.com/68415905/158343614-06dea897-3dbf-41f7-b94f-179b828739e1.JPG\" width=\"600\" />\n\n4. 프로젝트에 해당하는 앱을 추가합니다. (ios / android / web)\n\n<img src=\"https://user-images.githubusercontent.com/68415905/158344954-bbac48bd-a10e-4c39-bf5f-d5722dcd9752.JPG\" width=\"600\" />\n\n5. 먼저 1)앱 이름을 정하고 2)생성되는 config 코드를 복사합니다. <br/>(프로젝트 배포도 함께 원하는 경우 옵션 체크)\n\n<img src=\"https://user-images.githubusercontent.com/68415905/158344599-8465cce0-43dc-454c-bf16-f2a296469b28.JPG\" width=\"600\" />\n\n## 🙍 Authentication 설정\n\n1. Authentication 섹션에 접속하여 로그인 방법(sign-in method)을 선택합니다.\n\n![fb4](https://user-images.githubusercontent.com/68415905/158357869-3d4ee65a-19c2-4cab-819b-0fdbb46eb859.JPG)\n![fb5](https://user-images.githubusercontent.com/68415905/158358729-9deccf70-342f-4d05-a9d0-d86e2354ebdc.JPG)\n\n2. 로그인 방법으로 **Google**을 선택한 후 이메일을 추가합니다.\n\n![fb3](https://user-images.githubusercontent.com/68415905/158359051-be6288b6-151d-4319-a31b-3b6acae3788a.JPG)\n\n![fb1](https://user-images.githubusercontent.com/68415905/158359382-7092d37f-5e43-465c-879a-1ce5f99af612.JPG)\n\n## 🔀 firebase 프로젝트 연동\n\n1. firebase 설치합니다\n\n```bash\nnpm install firebase\n```\n\n2. `firebase.js` 파일을 생성한 후 복사한 config 코드를 붙여넣기 합니다.\n\n```js\nimport firebase from \"firebase/app\"\nimport \"firebase/auth\"\n\nconst firebaseConfig = {\n  // copy and paste\n}\n\nconst app = firebase.initializeApp(firebaseConfig)\n\nexport default app.auth()\n```\n\n3. login 컴포넌트에 provider를 추가합니다.\n\n```jsx\n// LoginPage.js\nimport firebase from \"firebase/app\"\nimport auth from \"../../firebase\"\n\nconst provider = new GoogleAuthProvider()\nexport const LoginButton = () => {\n  return <button onClick={signInWithPopup(auth, provider)}>로그인</button>\n}\n```\n\n4. 로그인 실행 시 아래와 같은 로그인 popup창이 생깁니다.\n\n![fb1](https://user-images.githubusercontent.com/68415905/158363860-38723771-32ae-4637-a856-887180b118c5.JPG)\n![fb](https://user-images.githubusercontent.com/68415905/158363958-b206f96f-f441-46d6-b9b8-b4ca8d82bd6e.jpg)\n\n5. 로그인에 성공하면 firebase > Authentication > Users에 이메일이 추가됩니다.\n\n<br />\n<br />\n\n> REFERENCE<br /> React에서 Firebase Auth를 사용한 로그인 구글 로그인 구현 https://koras02.tistory.com/58\n"},{"excerpt":"👨‍💼 Google 사용자 인증 정보 생성 외부 사이트에서 구글 로그인과 같은 구글 API를 사용하기 위해서는 사용자 인증 정보(OAuth 클라이언트 ID)를 발급받아야 한다.  발급 절차는 아래와 같다. Google Cloud Platform에 접속하여 새 프로젝트를 생성한다. 👉 Google Cloud 바로가기 프로젝트 이름을 입력하고 만들기버튼을 클릭한…","fields":{"slug":"/google-auth-clientid/"},"frontmatter":{"date":"March 12, 2022","title":"Google OAuth Client ID 만들기","tags":["firebase","auth"]},"rawMarkdownBody":"\n## 👨‍💼 Google 사용자 인증 정보 생성\n\n외부 사이트에서 **구글 로그인**과 같은 구글 API를 사용하기 위해서는 사용자 인증 정보(OAuth 클라이언트 ID)를 발급받아야 한다. <br/> 발급 절차는 아래와 같다.\n\n1. Google Cloud Platform에 접속하여 새 프로젝트를 생성한다. 👉 [Google Cloud 바로가기](https://console.cloud.google.com/)\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpqhCs%2FbtqEfqOwE4m%2FGkOTrLn4NbAfeiAjsxoGv0%2Fimg.png\" />\n\n2. 프로젝트 이름을 입력하고 만들기버튼을 클릭한다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcOsekD%2FbtqEh7fFWxR%2FXsuWZeC0Lk7SKbyNH3109k%2Fimg.png\" />\n\n3. 상단 헤더에서 프로젝트를 선택한 후, **OAuth 동의 화면(Consent Screen)** 페이지로 이동한다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnmxM8%2FbtqEgRxTvum%2FZCKCxA5unhivyyONHgkLOK%2Fimg.png\" />\n\n4. User Type을 **\"외부(External)\"**로 설정한 후 만들기 클릭.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeehnBK%2FbtqEeYLskR2%2FnNyZdt539SquPkYSOXnMuk%2Fimg.png\" />\n\n5. 앱이름과 이메일을 추가하고, 이 단계에서 사진 우측과 같은 OAuth 동의 화면을 커스텀 할 수 있다.\n\n<img src=\"https://medipress.co.kr/wp-content/uploads/2020/12/05-google-developer-info-1.png\" />\n\n6. 사용자 인증 정보 (Credentials) 탭으로 이동한 후, **사용자 인증 정보 만들기 > OAuth 클라이언트 ID**를 차례로 클릭한다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkK3SP%2FbtqEhPM33Ea%2FRx5N4x4eAjK2jQitCXmKQK%2Fimg.png\" />\n\n6. 애플리케이션 유형으로 \"웹 애플리케이션\" 선택하고, 애플리케이션 이름을 입력한다. 구글 로그인을 적용할 사이트의 주소를 승인된 자바스크립트 원본과 승인된 리다이렉션 URI에 입력한다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb7aIi4%2FbtqEfYjVyGX%2FERXAsc5YeP7euAdO4ke7X0%2Fimg.png\" />\n\n6. 가장 아래 '생성' 버튼을 클릭하면, 클라이언트 ID와 비밀번호를 확인할 수 있다!\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdvMtfd%2FbtqEfYxtVps%2F98p6Wj9U72bZDKdaBcthG0%2Fimg.png\" />\n\n<br />\n<br />\n\n> REFERENCE<br /> 구글 로그인 Client ID와 Client Secret Key 설정방법 https://medipress.co.kr/archives/2147\n"},{"excerpt":"✔ 등록 (Register) Resource Server에 새로운 Client를 등록합니다. Client ID : 애플리케이션 식별 ID (노출 가능) Client Secret : 식별 비밀번호 (노출 X) Authorized Redirect URLs : server로부터 데이터를 받을 주소 ✔ Resource Owner의 승인 Server의 데이터를 C…","fields":{"slug":"/auth-flow/"},"frontmatter":{"date":"March 10, 2022","title":"OAuth 2.0 흐름 파악하기","tags":["auth"]},"rawMarkdownBody":"\n## ✔ 등록 (Register)\n\nResource Server에 새로운 Client를 등록합니다.\n\n- Client ID : 애플리케이션 식별 ID (노출 가능)\n- Client Secret : 식별 비밀번호 (노출 X)\n- Authorized **Redirect URLs** : server로부터 데이터를 받을 주소\n\n<img src='https://user-images.githubusercontent.com/68415905/164886171-79ae9fd7-b11d-4316-902c-69bd31dc4d0e.png' alt='auth' width='300px' />\n\n## ✔ **Resource Owner의 승인**\n\nServer의 데이터를 Client에서 사용하는 것에 동의하는 사용자의 권한 승인이 필요합니다.\n\n1. Owner → Client : 특정 작업 요청\n2. Client → Owner : Server요청을 위한 화면 전송 <br/><br/>\n\n   > 서버 요청 버튼의 링크 (ex Google/Naver Login 버튼) <br/> _https//resource.server?client-id=1&scope=B,C&redirect-uri=http//~_\n\n   - `client_id` : 요청을 보내는 클라이언트 ID\n\n   - `scope` : server에 요청할 작업 목록(ex, username가져오기.. 등)\n\n   - `redirect_uri` : 요청 완료 시 이동할 주소 (서버에 저장된 주소와 다르면 이동 x) <br/><br/>\n\n3. Owner → Server : 버튼 클릭 시, 위 주소로 서버에 접속 요청\n4. Server → Owner : 로그인 여부 확인 후, 로그인 창 전송\n\n   <img src='https://user-images.githubusercontent.com/68415905/164886170-389cb7b0-9933-4cd1-ba1f-7c2e4cf76700.png' alt='auth' width='300px' />\n\n5. Owner → Server : 로그인\n6. Server → Owner :\n\n   1). `client_id` **값이 있는지 확인**\n\n   2). 요청받은 `redirect_uri` 값과 저장된 `redirect_uri`값이 같은지 확인 (다르면 종료)\n\n   3). 1,2 가 일치하면 `scope`에 해당되는 권한을 client가 사용하는 것에 대한 동의창 전송\n\n   <img src='https://user-images.githubusercontent.com/68415905/164886168-04fd1365-9074-4156-b4b0-1617612bb38f.png' alt='auth' width='300px' />\n\n7. Owner → Server : 권한에 동의하면 Server에 `userId` 와 `scope`에 해당하는 데이터가 저장됨\n\n   (`userId` 에 해당하는 Owner는 `scope` 데이터에 대한 권한을 동의하였음을 뜻합니다)\n\n## ✔ Resource Server의 승인\n\nServer에서 accessToken을 발급하기 전, Resource Owner가 요청한 Client 정보가 일치하는지 확인합니다.\n\n1. **Server → Owner → Client** : authorization code 전송\n\n   Client에 authorization code값이 저장됨 (`Location`: https//client/~~?code=3 )\n\n   <img src='https://user-images.githubusercontent.com/68415905/164886167-7b1e1d0f-3767-4ddf-9617-dfed32b4e7ee.png' alt='auth' width='650px' />\n\n2. Client → Server : Server에 직접 접속하여 전송. <br/><br/>\n\n   > _https//resource.server/token?**grant-type**=authorization-code&**code**=3&**redirect-uri**=http//client/callback&**client-id**=1&**client-secret**=2_\n\n   - `grant_type` : 3자 인증 방식 (authorization_code)\n\n   - `code` : authorization_code 값\n\n   - `redirect_uri` / `client_id` / `client_secret` : Client 정보\n\n   <img src='https://user-images.githubusercontent.com/68415905/164886165-5295697f-928c-4125-9cd5-dda925e3eaa9.png' alt='auth' width='300px' />\n\n3. Server : 요청 받은 authorization_code 에 해당하는 정보의\n\n   `redirect_uri` `client_id` / `client_secret` 값이 일치 하는 지 확인\n\n## ✔ Access Token 발급\n\n1. Server에서 Client의 요청이 승인되면 저장된 authorization_code를 삭제합니다.\n2. **Authentication Server**에서 Access Token을 발급한 후 Client에 전달합니다.\n\n   → Client는 발급받은 Access Token으로 **Resource Server**에 데이터 요청을 할 수 있습니다.\n\n  <img src='https://user-images.githubusercontent.com/68415905/164978655-fd212862-161c-4386-b05e-ec1c5714099e.JPG' alt='auth' width='400px' />\n\n## ✔ API 호출 (데이터 가져오기)\n\nServer로부터 API 데이터를 불러오는 방법은 2가지가 있습니다.\n\n1. Access Token을 쿼리 파라미터로 전달하는 방법\n\n> https//www.googleapis.com/calendar/v3/users/me/calendarList?access_token=<access_token>\n\n2. Authentication : Bearer HTTP header로 전달하는 방법 (**preferred**)\n\n> Authentication : Bearer <access_token> <br/> <br/>\n> curl -H \"Authorization: Bearer <access_token>\" https//www.googleapis.com/calendar/v3/users/me/calendarList\n\n## ✔ Refresh Token 발급\n\n1. Access Token의 유효기간이 만료되면 Client는 **Authentication Server**로 Refresh Token 발급 요청을 합니다.\n2. Server는 새로운 Access Token을 발급하여 Client에 전달합니다.\n\n  <img src='https://user-images.githubusercontent.com/68415905/164982319-92220411-7f85-4147-a30b-b20a6f6a7417.JPG' alt='auth' width='800px' />\n<br/><br/>\n\n> REFERENCE<br /> Youtube 생활코딩 OAuth 2.0 https://youtu.be/hm2r6LtUbk8\n"},{"excerpt":"🔎 OAuth 개념 알기 웹 사이트를 이용할 때 \"네이버로 로그인\" 같이 별도의 회원가입 없이 로그인을 제공하는 서비스를 이용해 본적이 있나요? 이때 해당 플랫폼의 아이디가 있다면 외부 서비스에서도 인증을 가능하게하고 그 서비스의 API를 사용할 수 있습니다. 이것을 OAuth라고 합니다. OAuth 란? OAuth : 사용자가 애플리케이션에게 모든 권한…","fields":{"slug":"/about-auth/"},"frontmatter":{"date":"March 03, 2022","title":"OAuth 2.0 의 개념 및 용어 정리","tags":["auth"]},"rawMarkdownBody":"\n## 🔎 OAuth 개념 알기\n\n웹 사이트를 이용할 때 \"네이버로 로그인\" 같이 별도의 회원가입 없이 로그인을 제공하는 서비스를 이용해 본적이 있나요? 이때 해당 플랫폼의 아이디가 있다면 외부 서비스에서도 인증을 가능하게하고 그 서비스의 API를 사용할 수 있습니다. 이것을 OAuth라고 합니다.\n\n<img src='https://user-images.githubusercontent.com/68415905/164481902-412a2c42-d633-4d4c-8f65-a1e893fe8b9d.png' alt='google-auth' width='400px' />\n\n### OAuth 란?\n\n> OAuth : 사용자가 애플리케이션에게 모든 권한을 넘기지 않고 사용자 대신 서비스를 이용할 수있게 해주는 HTTP 기반의 보안 프로토콜\n\nOAuth 에서 Auth는 Authentication(인증) & Authorization(허가) 2가지 의미를 포함하고 있습니다. OAuth 실행에는 **‘서비스 제공자를 대신하여 제 3자가 어떤 정보를 사용하도록 접근을 허용하겠는가?’** 와 같은 사용자의 접근 권한 동의가 필요합니다. 이 물음에 동의하면, 서비스 제공자로부터 전달된 접근 권한을 제 3자(사용하고자 하는 서비스)가 갖게 됩니다.\n\n이때, 권한을 넘겨주는 과정에서 보안사고가 발생하지 않도록 사용자의 정보는 있는 그대로가 아닌 식별 가능한 토큰으로 변환되어 전달됩니다.\n\n- ❌ : A 서비스 ▶ (ID/PASSWORD) ▶ B 서비스\n- ⭕ : A 서비스 ▶ (ID/PASSWORD ➡ 토큰) ▶ B 서비스\n\n## 📰 OAuth 용어 정리\n\n### Owner, Server, Client\n\n1. **Resource Owner** : 정보의 소유권을 가진 사용자\n\n2. **Provider** : OAuth를 사용하는 Open API를 제공하는 서비스 (ex. 구글, 네이버 등)\n\n   - **Resource Server** : 사용자의 정보를 보관하고 있는 서버\n   - **Authorization Server** : 사용자 인증 후 Client에 accessToken을 발행하는 서버\n\n3. **Client** : 제 3의 서비스. 사용자 동의하에 Resource Server 에 사용자 정보를 요청 할 수 있습니다.\n\n<!-- - Request Token : Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값 인증이 완료된 후에는 Access Token으로 교환한다.\n- Access Toekn : 인증 후 Consumer가 Service Provider의 자원에 접근하기 위한 키를 포함한 값 -->\n\n### Tokens\n\nToken이란 Authorization Server로부터 발급된 랜덤한 문자열이며 2가지 종류가 있습니다.\n\n1. **Access Token**\n\nClient가 Resource Server에게 사용자 정보를 요청하기 위한 입장권 같은 것입니다.\n입장권에는 유효기간이 있습니다. 각 provider 마다 다릅니다. 유효 기간이 지나면 더 이상 이 토큰을 사용 할 수 없습니다.\n\n<!-- 2. Request Token : Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값 인증이 완료된 후에는 Access Token으로 교환한다. -->\n\n2. **Refresh Token**\n\n위 Access Token 이 유효기간이 만료 되면, 새로운 Access Token 을 발급 받기 위해 필요한 토큰입니다. 이 토큰에도 유효기간이 있습니다. 각 provider 마다 다릅니다. Access Token 보다는 유효기간이 훨씬 깁니다.\n\n## 🔀 OAuth Flow 예시\n\n![oauth2-flow](https://user-images.githubusercontent.com/68415905/164474091-491fb63d-bfe0-4fb6-9c11-0af53a674032.png)\n\n### Slack OAuth Flow\n\n![slack_oauth](https://user-images.githubusercontent.com/68415905/164478649-346a7233-4b0c-46e2-a6c6-cf462ed600a8.png)\n\n### Payco OAuth Flow\n\n![oauth-payco](https://user-images.githubusercontent.com/68415905/164478162-6f935cd6-21b6-45e8-a317-076cc522d9dd.png)\n\n### Kakao OAuth Flow\n\n![kakao](https://user-images.githubusercontent.com/68415905/164478340-fac28ca7-9c17-43b6-a1db-b52a05b27354.png)\n\n## 🤔 OAuth vs OAuth 2.0\n\n- 기능의 단순화, 기능과 규모의 확장성 등을 지원하기 위해 만들어 졌다.\n- 1.0은 만들어진 다음 표준이 된 반면 2.0은 처음부터 표준 프로세스\n- https가 필수여서 간단해 졌다.(암호화는 https가 담당)\n- 다양한 인증방식을 지원한다.\n- api서버에서 인증서버를 분리 할 수 있도록 해 놓았다.\n  <br/><br/>\n\n> REFERENCE<br /> OAuth2 이해하기 https://devhaks.github.io/2019/05/31/oauth2/ <br/> OAuth 개념 및 플로우 https://miaow-miaow.tistory.com/192\n"},{"excerpt":"💡 redux-thunk란? redux-thunk는 redux 에서 비동기 작업이 필요할 때 사용하는 미들웨어(middleware)입니다. 이 미들웨어를 사용하면 액션 객체가 아닌 함수를 디스패치 할 수 있습니다. 여기서 thunk란 특정 작업을 나중에 하도록 미루기 위해 함수로 감싼 것을 말합니다. 📝 redux-thunk 예시 기본 Redux : '액…","fields":{"slug":"/redux-thunk/"},"frontmatter":{"date":"February 28, 2022","title":"Redux-thunk로 비동기 작업하기","tags":["react","redux"]},"rawMarkdownBody":"\n## 💡 redux-thunk란?\n\nredux-thunk는 redux 에서 **비동기 작업**이 필요할 때 사용하는 미들웨어(middleware)입니다. 이 미들웨어를 사용하면 액션 객체가 아닌 함수를 디스패치 할 수 있습니다. 여기서 thunk란 특정 작업을 나중에 하도록 미루기 위해 **함수**로 감싼 것을 말합니다.\n\n## 📝 redux-thunk 예시\n\n### 기본 Redux : '액션 객체' 생성\n\n일반 액션 생성자는 아래와 같이 파라미터를 가지고 액션 객체를 리턴하는 작업만 합니다.\n\n```js\nconst getUser = id => ({ type: GET_USER, payload: id })\n```\n\n### Redux-thunk : '액션 함수' 생성\n\nRedux-thunk는 `dispatch`, `getState` 를 파라미터로 가지는 thunk 함수를 리턴합니다. 이 때 함수 안에서 액션을 dispatch 할 수도 있고 getState를 사용하여 현재 상태도 조회 할 수 있습니다.\n\n```js\nconst getComments = () => (dispatch, getState) => {\n  const id = getState().post.userId // 현재 상태 조회\n  dispatch({ type: \"GET_COMMENTS_REQUEST\" }) // 요청이 시작했음을 알리는 액션\n\n  api\n    .getUser(id) // 요청을 하고\n    // 성공시\n    .then(comments => dispatch({ type: \"GET_COMMENTS_SUCCESS\", id, comments }))\n    // 실패시\n    .catch(e => dispatch({ type: \"GET_COMMENTS_ERROR\", error: e }))\n}\n```\n\n위 코드를 try~catch 문과 async/await를 사용해 아래처럼 바꿀 수도 있습니다. 이런식으로 thunk 함수를 사용하면 비동기로 api 데이터 사용이 가능해집니다.\n\n```js\nconst getComments = () => async (dispatch, getState) => {\n  const id = getState().post.activeId\n  dispatch({ type: \"GET_COMMENTS\" })\n  try {\n    const comments = await api.getComments(id)\n    dispatch({ type: \"GET_COMMENTS_SUCCESS\", id, comments })\n  } catch (e) {\n    dispatch({ type: \"GET_COMMENTS_ERROR\", error: e })\n  }\n}\n```\n\n## ➕ redux-thunk 적용하기\n\n### applyMiddleware()\n\n먼저 npm으로 redux-thunk 를 설치하고 `store.js` 파일에서 설치한 패키지를 불러옵니다. 불러온 `thunk`는 store에 2번째 파라미터에 `applyMiddleware()`로 감싸준 후 전달합니다.\n\n```bash\nnpm i redux-thunk\n```\n\n```js\n// store.js\nimport { createStore, applyMiddleware, combineReducers } from \"redux\"\nimport thunk from \"redux-thunk\"\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk) // redux-thunk 추가\n)\n```\n\n### composeWithDevTools()\n\n크롬 관리자 도구에서 state는 물론 thunk를 사용한 비동기 처리를 한눈에 확인 할 수 있도록 하는 라이브러리입니다.\n\n1. 크롬 확장프로그램에서 Redux DevTools를 설치합니다.\n\n![tool](https://user-images.githubusercontent.com/68415905/164023530-d5a9a68d-785e-4e82-a7e6-fd819be755b5.JPG)\n\n2. npm을 통해 `redux-devtools-extension`을 설치합니다.\n\n```bash\nnpm i redux-devtools-extension -D\n```\n\n3. 설치한 패키지에서 `composeWithDevTools`를 가져와 `thunk`를 한번 더 감싸줍니다.\n\n```js\n// store.js\n// ...\nimport { composeWithDevTools } from \"redux-devtools-extension\"\n\nconst store = createStore(\n  rootReducer,\n  composeWithDevTools(applyMiddleware(thunk)) // redux-thunk 추가\n)\n```\n\n4. 크롬 관리자 > Redux 탭으로 이동하여 비동기 작업 목록과(왼쪽), state를(오른쪽) 확인할 수 있습니다.\n\n![devtool](https://user-images.githubusercontent.com/68415905/164022332-1bc68f8e-7696-464b-a399-d55baa79907b.JPG)\n\n<br />\n<br />\n\n> REFERENCE<br />Redux - redux-thunk란? https://jw910911.tistory.com/48<br/>벨로퍼트 Redux-thunk https://react.vlpt.us/redux-middleware\n\n````\n\n```\n\n```\n````\n"},{"excerpt":"💡 Redux란? Redux란 '상태 관리 라이브러리'로써 기존에 흩어져 있는 state들을 한 곳에 모아 관리하여 예측 불가능한 버그를 최소화하고 효율적으로 state를 사용할 수 있도록 합니다. 또한 Redux는 React 외에도 Angular, Vue, jQuery 등 다양한 환경에서 사용할 수 있습니다. why-using-redux 에서의 상태관리…","fields":{"slug":"/about-redux/"},"frontmatter":{"date":"February 20, 2022","title":"Redux - 상태 관리 라이브러리","tags":["react","redux"]},"rawMarkdownBody":"\n## 💡 Redux란?\n\nRedux란 '상태 관리 라이브러리'로써 기존에 흩어져 있는 state들을 한 곳에 모아 관리하여 예측 불가능한 버그를 최소화하고 효율적으로 state를 사용할 수 있도록 합니다. 또한 Redux는 React 외에도 Angular, Vue, jQuery 등 다양한 환경에서 사용할 수 있습니다.\n\n![why-using-redux](https://user-images.githubusercontent.com/68415905/157664466-dffebac5-4ead-438f-895b-dd53e3b01b70.jpg)\n\n- `React`에서의 상태관리\n\n  React에서의 상태는 `props`를 통해 각 컴포넌트로 전달됩니다. 특정 컴포넌트에서 state가 변화하면 `props`로 연결된 모든 컴포넌트가 함께 업데이트 됩니다.\n\n- `Redux`에서의 상태관리\n\n  Redux에서의 상태는 컴포넌트끼리 공유하지 않고 `store`라는 파일을 거쳐 필요한 컴포넌트로 즉시 전달됩니다. (`store` : 앱에서 사용되는 모든 state를 저장하고 관리하는 장소)\n\n## 📝 Redux의 3원칙\n\n1. **Single source of truth**\n\n   필요한 상태 데이터는 모두 `store`라는 데이터 공간에 저장하고 관리됩니다.\n\n2. **State is read-only**\n\n   리액트에서 useState로 상태 변경을 하듯이 리덕스에서는 `action`이라는 객체를 통해서만 상태를 변경할 수 있습니다. (예측 가능)\n\n3. **Changes are made with pure functions**\n\n   상태 변경은 순수함수(`reducer`)로만 가능합니다.\n\n![redux](https://user-images.githubusercontent.com/68415905/158020881-ecacf242-8f93-4518-9372-afa3b10d4609.png)\n\n## 🎉 Redux 시작하기\n\n### 0. Redux 설치 및 폴더 구조\n\n```bash\nnpm install redux react-redux\n```\n\n```bash\nredux/\n├── actions/\n│   ├── index.js # 액션 엔트리\n│   ├── actionTypes.js # 액션 타입 상수 파일\n│   ├── auth.js # action 1\n│   └── counter.js  # action 2\n├── reducers/\n│   ├── index.js # 리듀서 엔트리 (rootReducer)\n│   ├── auth.js # reducer 1\n│   └── counter.js # reducer 2\n└── store.js # 스토어 엔트리 (스토어 생성)\n```\n\n### 1. action 생성\n\n> `action` : 객체 형식으로 컴포넌트에서 상태 변경을 요청할 때 사용\n\n- `type` : 액션명 (필수)\n- `payload` : 변경할 상태 값 (옵션)\n\naction 생성 시 필요한 값으로는 `type`과 `payload` 가 있는데 이때, `type`은 파일을 별도로 만들어 상수(constant)로 관리하는 것이 유지 보수 하기 좋습니다.\n\n```jsx\n// actions/actionTypes.js\nexport const LOG_IN = \"LOG_IN\"\nexport const LOG_OUT = \"LOG_OUT\"\nexport const INCREASE_COUNT = \"INCREASE_COUNT\"\nexport const DECREASE_COUNT = \"DECREASE_COUNT\"\n```\n\n```jsx\n//actions/auth.js\nimport { LOG_IN, LOG_OUT } from \"./actionTypes\"\n// 로그인 요청 action\nexport const login = user => ({\n  type: LOG_IN,\n  payload: user, // 전달받은 상태값을 payload에 저장\n})\n// 로그아웃 요청 action\nexport const logout = () => ({\n  type: LOG_OUT,\n})\n```\n\n### 2. reducer 생성\n\n> `reducer` : action 에 맞게 state를 업데이트 하는 함수\n\nreducer는 상태(state)와 액션(action)을 전달 받아 '현재 상태'를 '새로운 상태'로 교체 한 후 반환하는 함수이며 주로 `switch` ~ `case` 문으로 작성합니다.\n\n```jsx\nconst initialState = {\n  user: '',\n  loading: false\n};\nconst reducer = (state = initialState, action) {\n  switch(action.type) {\n    case LOG_IN:\n      return {\n        ...state, // 현재 상태를 가져와\n        user: action.payload // 전달받은 payload값으로 교체\n      }\n    case LOG_OUT:\n      return {\n        ...state,\n        user: ''\n      }\n    default:\n      return state\n  }\n}\n```\n\nreducer 파일이 여러개라면 index.js 파일을 만들고 `combineReducers`를 사용해 reducer를 하나로 합쳐주는 `rootReducer`를 생성합니다.\n\n```jsx\n// reducers/index.js\nimport { combineReducers } from \"redux\"\nimport { authReducer, counterReducer } from \"reducers\"\nexport const rootReducer = combineReducers({\n  auth: authReducer,\n  counter: counterReducer,\n})\n```\n\n### 3. store 생성\n\n> `store` : 모든 상태가 저장되는 공간\n\n만들어둔 `reducer`(or `rootReducer`) 함수를 `createStore`에 전달하여 `store`를 생성합니다.\n\n```jsx\nimport { createStore } from \"redux\"\nconst store = createStore(rootReducer)\nexport default store\n```\n\n## 🔎 Redux 사용하기\n\n### - Provider\n\n> Provider : store에 저장된 상태값을 컴포넌트로 전달\n\n모든 컴포넌트에서 store에 접근할 수 있도록 최상단 컴포넌트(`App`)를 `Provider`로 감싸주고 store를 전달합니다.\n\n```jsx\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { App } from \"./App\"\nimport { Provider } from \"react-redux\"\nimport store from \"redux/store\"\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n)\n```\n\n### - useSelector\n\n> useSelector : store에 저장된 상태값 가져와서 사용\n\n```jsx\nimport { useSelector } from \"react-redux\"\n\nexport const mainPage = () => {\n  const user = useSelector(state => state.auth.user)\n\n  return <div>{user}님 환영합니다</div>\n}\n```\n\n### - useDispatch\n\n> useDispatch : action을 실행시켜 store의 상태값 업데이트\n\n```jsx\nimport { useDispatch } from \"react-redux\"\nimport {login} from \"actions/auth.js\"\n\nexport const loginPage = () => {\n  const [value, setValue] = useState('');\n  const dispatch = useDispatch()\n\n  // login 액션을 실행시켜 input value값을 store로 전달!\n  const handleLogIn = () => {\n    dispatch(login(value))\n  }\n\n  return (\n    <input value={value} type=\"text\"/>\n    <button onClick={handleLogIn}>Log In</button>\n  )\n}\n```\n\n<br />\n<br />\n\n> REFERENCE<br />Youtube 생활코딩 https://youtu.be/yjuwpf7VH74<br/>야무의 React 러닝 가이드 https://yamoo9.github.io/react-master/lecture/rd-redux.html\n"},{"excerpt":"☝ 프로젝트 시작하기 전 이번 프로젝트부터는 javascript가 아닌 typescript를 사용하기로 했다. 타입스크립트가 적용된 CRA를 내려받고 절대경로(ex ) 설정도 해두었다.  타입스크립트 절대경로 설정 (tsconfig.json) 📌 프로젝트 링크 Github\n배포링크 📑 견적서 게시판 제작 1. json-server로 REST-API 요청 …","fields":{"slug":"/estimate-board/"},"frontmatter":{"date":"February 10, 2022","title":"견적서 게시판 (필터링 기능)","tags":["wanted","typescript","react","heroku"]},"rawMarkdownBody":"\n## ☝ 프로젝트 시작하기 전\n\n이번 프로젝트부터는 javascript가 아닌 typescript를 사용하기로 했다. 타입스크립트가 적용된 CRA를 내려받고 절대경로(ex `components/Filter`) 설정도 해두었다.\n\n`npx create-react-app [project-name] --template typescript`\n\n- 타입스크립트 절대경로 설정 (**tsconfig.json**)\n\n```json\n{\n  \"compilerOptions\": {\n    // etc..\n    \"baseUrl\": \"src\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n## 📌 프로젝트 링크\n\n[Github](https://github.com/devjoylee/estimate-board)\n[배포링크](https://estimate-board-page.herokuapp.com/)\n\n## 📑 견적서 게시판 제작\n\n### 1. json-server로 REST-API 요청\n\njson-server로 가상의 서버를 만들어 REST-API 요청을 보내고 서버에 저장된 데이터베이스로 부터 필요한 데이터를 가져올 수 있도록 만들었다.\n\n> REST-API란? <br/>\n> url과 method를 사용해 HTTP 기반으로 클라이언트가 서버로 CRUD를 요청하는 것<br/>\n> ▪ Create : POST => 새로운 데이터 생성<br/>\n> ▪ Read : GET => 데이터 불러오기<br/>\n> ▪ Update : PUT => 데이터 수정<br/>\n> ▪ Delete : DELETE => 데이터 삭제<br/>\n\n먼저 json-server를 설치하고 프로젝트 최상단에 `server` 폴더를 생성했다.\n\n```bash\nnpm install json-server\n```\n\n그리고 server를 생성하는 명령어 파일(index.js)을 추가한 후 데이터가 저장된 db.json 파일을 만들었다. 저장한 데이터를 가져오기 위해서는 서버 url로 GET 요청을 보내야 한다. <br/>(요청 url - localhost:3001/requests)\n\n```json\n// db.json\n{\n  \"requests\": [\n    {\n      \"id\": 1,\n      \"title\": \"자동차 시제품 제작\",\n      \"client\": \"A 고객사\",\n      \"due\": \"2020.12.14\",\n      \"count\": 2,\n      \"amount\": 100,\n      \"method\": [\"밀링\", \"선반\"],\n      \"material\": [\"알루미늄\"],\n      \"status\": \"대기중\"\n    }\n    // ...\n  ]\n}\n```\n\n```js\n// index.js\nconst jsonServer = require(\"json-server\")\nconst path = require(\"path\")\n\nconst server = jsonServer.create()\nconst router = jsonServer.router(path.resolve(__dirname + \"/db.json\"))\nconst middlewares = jsonServer.defaults({\n  static: path.resolve(__dirname + \"/../build/\"),\n})\n\nconst port = process.env.PORT || 3001\n\nserver.use(middlewares)\n\nserver.use(jsonServer.bodyParser)\n\nserver.use(router)\nserver.listen(port, () => {\n  console.log(\"JSON Server is running\")\n})\n```\n\nserver로 보내는 GET 요청은 fetch 함수를 사용한다. useEffect를 사용해서 렌더링 시 데이터를 요청하고 불러온 데이터는 state에 저장하도록 설계했다.\n\n```jsx\nconst [apiData, setApiData] = useState<Estimate[]>([]);\n\nuseEffect(() => {\n  const fetchData = async () => {\n    const data = await fetch(\"/requests\")\n    setApiData(await data.json())\n  }\n  fetchData()\n}, [])\n```\n\nGET 요청 성공 여부를 알고 싶다면 브라우저 네트워크 탭을 확인하면 된다.\n\n![get](https://user-images.githubusercontent.com/68415905/156305269-37019cd0-fc20-4442-b98b-25cf1883295d.JPG)\n\n### 2. 필터링 기능 구현\n\n이번 프로젝트에서 필요한 필터링 기능은 총 2가지 이다. 각 기능은 서로 다른 방식으로 구현을 해보기로 했다.\n\n1. select 박스 형태의 카테고리 선택에 따라 해당 카테고리 내역만 출력<br/>\n   👉 `filter`와 `include()` method를 사용해서 구현\n2. 토글 버튼 클릭 시, '상담 중' 라벨이 붙어있는 내역만 출력<br/>\n   👉 className를 각각 부여하고 토글버튼 클릭 시 `display:block` or `none` 처리\n\n![image](https://user-images.githubusercontent.com/68415905/156330421-4364ff3e-a37e-41e3-b28f-bb22abd1466d.jpg)\n\n### - 카테고리 필터링\n\n먼저 카테고리 필터링은 util 함수를 따로 작성하였다. `filterData`라는 이 함수는 서버에서 받아온 API 데이터와 category에서 선택된 옵션을 비교하여 선택된 옵션과 모두 일치하는 item만 데이터에서 필터링시켜 출력하도록 구현했다.\n\n```jsx\n// filterData.ts\nimport { Estimate, Category } from \"types\"\n\nexport const filterData = (apiData: Estimate[], categories: Category) => {\n  const filtered = apiData.filter((item: Estimate) => {\n    // '재료' 카테고리에서 선택된 옵션과 모두 일치하면 true\n    const materials = categories.material.every((option: string) =>\n      item.material.includes(option)\n    )\n    // '가공방식' 카테고리에서 선택된 옵션과 모두 일치하면 true\n    const methods = categories.method.every((option: string) =>\n      item.method.includes(option)\n    )\n    // 두 조건에 모두 부합하는 item만 필터링하여 출력\n    return materials && methods\n  })\n  return filtered\n}\n```\n\n이때, 선택된 카테고리는 `categories`라는 state를 만들어 관리했다. 받아온 api데이터와 categories 목록을 `filterData` 함수의 인자로 넘겨주면 필터링된 새로운 데이터를 반환한다.\n필터링 데이터는 컴포넌트로 넘겨주어 `map`으로 각 아이템을 출력하게 했다.\n\nuseMemo를 사용하기 전 데이터를 state에 저장할지 useMemo로 메모리에 저장해둘지 고민을 많이 했는데 어떤 방식이 더 좋은지는 아직 잘 모르겠다. state에 저장을 하면 렌더링마다 같은 필터링이 반복되고, useMemo에 저장을 하면 추가적으로 메모리를 소비하는데 어떤게 더 좋은 선택일지는 차차 고민해보도록 해야겠다.\n\n```jsx\n// mainPage.ts\nconst [categories, setCategories] = useState({\n  method: [],\n  material: [],\n})\nconst filteredList = useMemo(() => {\n  return filterData(apiData, categories)\n}, [apiData, categories])\nreturn (\n  // 카테고리 컴포넌트 (옵션 선택 시 state 업데이트)\n  <FilterList categories={categories} setCategories={setCategories} />\n  // map으로 list를 순회하며 각 아이템을 출력하는 컴포넌트\n  <EstimateList list={filteredList} isChecked={isChecked} />\n)\n```\n\n### - 토글 필터링\n\n토글 필터링은 조금 간단한 방식을 사용했다. 먼저 `isChecked`라는 state를 만들어 토글이 on/off 되었을 때를 관리하도록 했다.\n\n```jsx\nconst [isChecked, setIsChecked] = useState(false)\nconst handleClick = () => {\n  setIsChecked(!isChecked)\n}\nreturn (\n  // ..\n  <Toggle isChecked={isChecked} handleClick={handleClick} />\n)\n```\n\n그리고 데이터 정보에 따라 status가 상담중이면 `active`, 대기중이면 `pending` 이라는 클래스명을 부여하고 토글이 켜진 경우(`isChecked`가 참인 경우) 상담중(`active`) 아이템만 display:block 시키고 나머지는 모두 display:none 하도록 설계했다.\n\n```jsx\n// EstimateItem.tsx\ninterface StyleProps {\n  isChecked: boolean;\n}\n\nexport const EstimateItem = ({ isChecked }: EstimateItemProps) => {\n  return (\n    <EstimateItemContainer\n      className={status === '상담중' ? 'active' : 'pending'}\n      isChecked={isChecked}\n    >\n    // ...\n    </EstimateItemContainer>\n  );\n}};\n\nconst EstimateItemContainer = styled.li<StyleProps>`\n  &.pending {\n    display: ${({ isChecked }) => (isChecked ? 'none' : 'block')};\n  }\n`;\n```\n\n<br/>\n\n- 🔎 필터링 구현 영상\n\n![gif](https://user-images.githubusercontent.com/68415905/156321675-9bc7f32d-0c7e-4cde-b0da-bb9daa8a132a.gif)\n\n## ♻ 프로젝트 리팩토링\n\n### 필터 기능 수정\n\n사실 이번 프로젝트에서 내가 맡은 부분은 필터 기능 구현이 아닌 UI 컴포넌트 설계과 토글 기능 구현 담당이었다. 그래서 필터링 부분에 대해서는 프로젝트가 끝난 후 다른 팀원이 작성한 필터링 코드를 보며 개선할 부분을 생각해보고 추가적으로 학습하였다.\n\n- 리팩토링 전\n\n```jsx\nimport { Estimate } from \"types/card\"\nimport { Category } from \"types/category\"\n\nexport const getFilter = (apiData: Estimate[], categories: Category) => {\n  const newData = []\n  for (let i = 0; i < apiData.length; i++) {\n    const methodFiltered = apiData[i].method.filter((data: string) =>\n      categories.method.includes(data)\n    )\n    const materialFiltered = apiData[i].material.filter((data: string) =>\n      categories.material.includes(data)\n    )\n    if (\n      methodFiltered.length >= categories.method.length &&\n      materialFiltered.length >= categories.material.length\n    ) {\n      newData.push(apiData[i])\n    }\n  }\n  return newData\n}\n```\n\n위 코드에서 리팩토링한 항목은 아래와 같다.\n\n1. type이 불필요하게 2군데로 나누어져 있음\n   👉 type 파일 1개로 합치기\n\n2. filter method도 배열을 반환하는데 별도로 배열 변수를 추가해서 push함\n\n   👉 추가로 할당된 배열을 없애고 filter된 배열 자체를 return하도록 수정\n\n3. for loop내부에서 filter를 써서 시간복잡도 발생\n\n   👉 2번에서 배열을 삭제함으로써 for loop 필요 없어짐\n\n4. 함수명을 getFilter에서 filterData 변경 (좀 더 명시적으로)\n\n<br/>\n\n- 리팩토링 후\n\n```jsx\nimport { Estimate, Category } from \"types\"\n\nexport const filterData = (apiData: Estimate[], categories: Category) => {\n  const filtered = apiData.filter((item: Estimate) => {\n    // '재료' 카테고리에서 선택된 옵션과 모두 일치하면 true\n    const materials = categories.material.every((option: string) =>\n      item.material.includes(option)\n    )\n    // '가공방식' 카테고리에서 선택된 옵션과 모두 일치하면 true\n    const methods = categories.method.every((option: string) =>\n      item.method.includes(option)\n    )\n    // 두 조건에 모두 부합하는 item만 필터링하여 출력\n    return materials && methods\n  })\n  return filtered\n}\n```\n\n### 옵션명 유틸 함수 추가\n\n아이템별로 `[밀링], [밀링,선반], [선반]...` 과 같이 옵션이 다 달랐는데 데이터가 가진 옵션을 분석하여 동적으로 카테고리 옵션을 만들어주었다.\n\n1. `.flat()` method로 데이터가 가진 옵션명 모두 합치기\n\n   ex) `[밀링], [밀링,선반], [선반]` ➡ `[밀링, 밀링, 선반, 선반]`\n\n2. `Set`을 사용하여 중복 제거\n\n   ex) `[밀링, 밀링, 선반, 선반]` ➡ `[밀링, 선반]`\n\n하지만 기존에는 두가지 옵션(material,method)을 각각 따로 `flat`처리하고 다른 state로 관리해서 코드의 가독성이 떨어졌다. 그래서 `getOptionList`라는 유틸함수를 만들어 코드의 가독성을 높이고 state도 1개로 통일시켜 재사용성을 높였다.\n\n<br/>\n\n- 리팩토링 전\n\n```jsx\nconst methodArr = apiData.map(data => data.method).flat(Infinity);\nconst materialArr = apiData.map(data => data.material).flat(Infinity);\nconst methodSet = Array.from(new Set(methodArr));\nconst materialSet = Array.from(new Set(materialArr));\nconst [selectMethod, setSelectMethod] = useState<string[]>([]);\nconst [selectMaterial, setSelectMaterial] = useState<string[]>([]);\nconst [isMethodOpen, setIsMethodOpen] = useState(false);\nconst [isMaterialOpen, setIsMaterialOpen] = useState(false);\n```\n\n- 리팩토링 후\n\n```js\nconst optionName = name === '가공방식' ? 'method' : 'material';\nconst optionList = getOptionList(apiData, optionName);\nconst [select, setSelect] = useState<string[]>([]);\nconst [isOpen, setIsOpen] = useState(false);\n```\n\n```js\n// getOptionList.ts\nimport { Estimate } from \"types\"\n\nexport const getOptionList = (\n  apiData: Estimate[],\n  option: \"method\" | \"material\"\n) => {\n  const list = apiData.map(data => data[option]).flat(1)\n  return Array.from(new Set(list))\n}\n```\n"},{"excerpt":"☝ 프로젝트 시작하기 전 이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다. no…","fields":{"slug":"/admin-registry/"},"frontmatter":{"date":"January 31, 2022","title":"어드민 페이지 (이미지 첨부 기능 / useForm)","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\n## ☝ 프로젝트 시작하기 전\n\n이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다.\n\n![none](https://user-images.githubusercontent.com/68415905/154843327-bd704dff-8fd1-40fd-a59c-ad9473b74690.jpg)\n\n## 📌 프로젝트 링크\n\n[Github](https://github.com/devjoylee/admin-product-registry)\n[배포링크](https://wanted-admin-product.netlify.app/)\n\n## 🧾 상품 등록 페이지\n\n### 이미지 첨부 기능 `input▫type=\"file\"`\n\n상품 썸네일은 **최대 1개,** 상품 대표 이미지는 **여러개** 첨부 가능하도록 기능 구현.\n\n![Untitled](https://user-images.githubusercontent.com/68415905/154844537-f04a2902-3194-478e-80b4-772e8f32539b.png)\n\n- 파일 업로드 버튼 custom 하기 : **input**의 `id`와 **label**의 `htmlFor`에 같은 id를 입력한 후 input은 `display:none` 해주고 `label` 스타일링.\n\n- 이미지 파일만 첨부 가능하게 : `accept=\"image/*\"` 또는 `accept=\"image/png\"`\n- 파일 중복 선택 `multiple`\n\n```jsx\n// ImageUpload.js\n<input\n  id={id}\n  type=\"file\"\n  accept=\"image/*\"\n  style={{ display: 'none' }}\n  multiple={!(id === 'thumbnail')}\n/>\n<label htmlFor={id}>\n  <RiAddLine />\n  이미지 첨부\n</label >\n```\n\n```jsx\n// Page.js\n<ImageUpload id=\"thumbnail\" />\n<ImageUpload id=\"main-img\" />\n\n```\n\n---\n\n### 업로드한 이미지 정보 가져오기 `e.target.files`\n\n- 이미지가 1개 인경우 `e.target.files[0]` 으로 첫번째 파일 정보를 바로 가져온다\n\n  ex) `e.target.files[0].name`\n\n![Untitled (1)](https://user-images.githubusercontent.com/68415905/154844914-ba2629f7-f07c-43f5-9dc3-6ed2b477bcd8.png)\n\n- 이미지가 여러개인 경우 `Array.from(e.target.files).map()` <br/>\n  `e.target.files` 로 불러온 객체 형식의 데이터를 배열로 바꾸어서 관리해준다.\n\n![Untitled (2)](https://user-images.githubusercontent.com/68415905/154844917-3640cfb1-63e8-4bc6-a679-a714aa0b575f.png)\n\n첨부한 이미지 데이터가 담긴 배열을 `map`으로 순회하며 이미지 파일명만 추출해서 새로운 state에 저장하고 화면에 출력하도록 설계했다.\n\n```jsx\n// ImageUpload.js\nconst [imageList, setImageList] = useState([])\nconst handleUpload = e => {\n  const uploadedImage = Array.from(e.target.files).map(file => file.name)\n  if (id === \"thumbnail\") {\n    setImageList(uploadedImage)\n  } else {\n    setImageList([...imageList, ...uploadedImage].reverse())\n  }\n}\n```\n\n---\n\n### 이미지 preview `URL.createObjectURL`\n\n`URL.createObjectURL`로 이미지 파일의 URL을 추출하고 img태그의 src로 넣어준다.\n\n```jsx\nconst [imgUrl, setImgUrl] = useState(\"\")\nconst getImageUrl = e => {\n  let file = e.target.files[0]\n  let url = URL.createObjectURL(file)\n  setImgUrl(url)\n}\n```\n\n```jsx\n<img src={imgUrl} alt=\"\" />\n```\n\n---\n\n## ♻ 프로젝트 리팩토링\n\n처음엔 필수옵션이 기입되지 않은 경우 '필수 값을 모두 입력하세요!' 라는 alert이 보여지도록 코드를 작성했다. 하지만 사용자의 입장에서 어떤 옵션이 비어있는지 구체적으로 알 수 있으면 좋을 것 같아 alert에서 비어있는 옵션명도 함께 알려주도록 리팩토링 해보기로 했다.\n\n먼저 validation이라는 유틸함수를 만들고 값이 전달되지 않는 필수 옵션명의 이름을 리턴하도록 작성했다. 그리고 코드의 가독성을 위해 useForm이라는 커스텀 hook을 만들었고 validation에서 리턴된 옵션명을 alert에 출력하는 함수를 리턴하도록 구현했다.\n\n![캡처](https://user-images.githubusercontent.com/68415905/154845357-06d08840-fb5d-455f-8aec-fe1331ce6d80.JPG)\n\n### validation.js\n\n```jsx\nexport const validation = required => {\n  const inVaild = Object.keys(required).filter(\n    key => !required[key] || required[key].length === 0\n  )\n\n  const inVaildList = inVaild.map(el => {\n    switch (el) {\n      case \"category\":\n        return \"카테고리\"\n      case \"productName\":\n        return \"상품명\"\n      case \"description\":\n        return \"상품 구성 소개 정보\"\n      case \"stock\":\n        return \"상품 총 재고\"\n      case \"option\":\n        return \"상품 옵션\"\n      default:\n        throw new Error(\"Unknown option type\")\n    }\n  })\n\n  return inVaildList\n}\n```\n\n### useForm.js\n\n```jsx\nexport const useForm = requiredList => {\n  const [required, setRequired] = useState(requiredList)\n  const addRequired = useCallback(\n    (name, value) => {\n      setRequired(prev => ({\n        ...prev,\n        [name]: value,\n      }))\n    },\n    [setRequired]\n  )\n\n  const handleClick = () => {\n    const inVaild = validation(required)\n    if (!inVaild.length) {\n      submitForm()\n    } else {\n      alert(\n        `필수 값을 모두 입력하세요 ❗❗\n👉 ${inVaild.join(\", \")}을(를) 추가해주세요!`\n      )\n    }\n  }\n\n  const submitForm = () => {\n    alert(\"상품이 등록 되었습니다 🎉🎉\")\n  }\n\n  return { addRequired, handleClick }\n}\n```\n\n- useForm 사용\n\n```jsx\nconst { addRequired, handleClick } = useForm({\n  category: [],\n  productName: \"\",\n  description: \"\",\n  stock: \"\",\n  option: [],\n})\n\nreturn (\n  <RegistryForm onSubmit={e => e.preventDefault()}>\n    <TopButton name=\"저장하기\" handleClick={handleClick} type=\"submit\" />\n    <BasicInformation title=\"상품 기본 정보\" addRequired={addRequired} />\n    <OptionMain title=\"상품 옵션\" addRequired={addRequired} />\n    // ...\n  </RegistryForm>\n)\n```\n\n<br />\n\n> REFERENCE<br />Stack Overflow https://stackoverflow.com/questions/60151566/display-file-name-for-custom-input-file-using-reactjs<br />[React] useForm 만들기 https://velog.io/@junghyeonsu/React-useForm\n"},{"excerpt":"☝ 프로젝트 시작하기 전 프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다. 본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다. 프로젝트 폴더 구조는 어떻게 만들까? 커…","fields":{"slug":"/currency-converter/"},"frontmatter":{"date":"January 28, 2022","title":"환율 계산기(Currency Converter) 만들기","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\n## ☝ 프로젝트 시작하기 전\n\n프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다.\n\n본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다.\n\n- 프로젝트 폴더 구조는 어떻게 만들까?\n- 커밋은 어떤 방식을 사용할 것인가?\n- 네임 컨벤션은 어떻게 따를 것인가? (컴포넌트이름, branch이름, 상수처리 등 )\n- CSS는 어떤 툴을 사용할 것인가? (Styled Component, SASS, CSS Modules 등)\n\n크게 4가지 주제로 팀원들과 협업규칙을 정했고 Docs로 정리해두었다. [👉 Docs 보러가기](https://www.notion.so/50aee26d48df4e0baf7ac3f8203c7f08)\n\n## 📌 프로젝트 링크\n\n[Github](https://github.com/devjoylee/currency-converter)\n[배포링크](https://currency-converter-w.netlify.app/)\n\n## 📲 환율 계산기 만들기\n\n환율 정보는 제공된 API(https://currencylayer.com/)에서 실시간 환율 데이터를 `fetch`해서 사용했다. 계산기에 값을 입력하고 화폐단위를 선택하면 해당 환율을 출력하도록 로직을 설계했다.\n\n### 입력값 상태 저장\n\n![Untitled](https://user-images.githubusercontent.com/68415905/154837797-6f5b9bb5-eebb-4a9f-9b4f-8fc47bc9c815.png)\n\n먼저 입력값은 2가지로 나뉜다.\n\n1. **input으로 입력한 금액**\n\n2. **select 박스로 선택한 화폐단위**\n\n```jsx\nconst [inputValue, setInputValue] = useState(\"\")\nconst [currency, setCurrency] = useState(\"USD\")\n```\n\n각각 다른 state를 만들어 입력 값을 관리하도록 하였고 input의 입력값에는 10자리 이하 숫자만 입력되도록 하기위해 입력값 length가 10을 넘는 경우 return 시켰다. 그리고 `toLocaleString` 을 사용해 숫자 3자리마다 콤마(,)가 자동으로 보이도록 만들었다. ex) 1,000,000\n\n```jsx\n// input에 값이 입력될 때\nconst handleType = e => {\n  const pureString = e.target.value.split(\",\").join(\"\")\n  if (isNaN(Number(pureString))) return\n  if (pureString.length > 10) return\n  if (Number(pureString) >= 1000) {\n    setInputValue(Number(pureString).toLocaleString())\n  } else {\n    setInputValue(pureString)\n  }\n}\n// select box 값이 선택될 때\nconst handleChange = e => {\n  setCurrency(e.target.value)\n  setInputValue(\"\")\n}\n```\n\n### 탭 기능 구현\n\n![Untitled](https://user-images.githubusercontent.com/68415905/154838315-42884797-688c-43c6-aab6-bc06f9b33f2a.JPG)\n\n위 select 박스에서 선택된 단위는 아래 탭박스에 나타나지 않도록 하기위해 전체 화폐단위 값을 가져와서 `filter`로 select 박스에 선택된 값을 제외하고 탭을 다시 정렬하도록 구현했다. 활성화된 탭은 border-bottom값을 none으로 해주었다.\n\n```jsx\nconst [tabs, setTabs] = useState(TAB_CURRENCY)\nconst [currentTab, setCurrentTab] = useState(\"\")\n\nconst handleClick = e => {\n  setCurrentTab(e.target.innerHTML)\n} // 탭 클릭 시 현재 탭 상태 업데이트\n\nuseEffect(() => {\n  const handleTab = () => {\n    let changedTabs = TAB_CURRENCY.filter(tab => tab !== currency)\n    setTabs(changedTabs)\n    setCurrentTab(changedTabs[0])\n  }\n  handleTab()\n}, [currency, setCurrentTab])\n```\n\n### 실시간 날짜 & 환율 계산\n\n![Untitled](https://user-images.githubusercontent.com/68415905/154838566-6341a0f4-bad8-4f66-b706-f6accb9e7488.jpg)\n\n데이터를 성공적으로 받아오면, `DateConverter`와 `CurrencyCalculator`로 실시간 환율을 계산한다. 환율 계산할 때는, 콤마(,)때문에 string으로 변한 value값을 다시 number로 바꾸어 준다. ex) “1,000” → 1000\n\n- 날짜 계산 (dateConverter.js)\n\n```jsx\nexport const DateConverter = timestamp => {\n  const time = new Date(timestamp * 1000)\n  const year = time.getFullYear()\n  const month = time.toLocaleString(\"en\", { month: \"short\" })\n  const date = time.getDate()\n  return `${year}-${month}-${date}`\n}\n```\n\n- 환율 계산 (currencyCalculator.js)\n\n```jsx\nconst CurrencyCalculator = (target, base, money) => {\n  let targetRate = apiData.quotes[`USD${target}`]\n  let baseRate = apiData.quotes[`USD${base}`]\n  let exchangeRate = Number((targetRate / baseRate) * money)\n  return exchangeRate.toLocaleString(\"en\", {\n    maximumFractionDigits: 2,\n  })\n}\n```\n\n## ♻ 프로젝트 리팩토링\n\n### API 상수화\n\n처음에는 API key, 화폐정보 등이 모두 포함된 API를 통째로 string으로 써서 data를 불러왔는데 화폐정보가 바뀔때 API를 수정해야한다는 불편함이 생겨 좀더 편리한 구조로 API 주소를 바꾸었다.\n\n- **리팩토링 전**\n\n```jsx\n// constants.js\nexport const API_ENDPOINT =\n  \"http://api.currencylayer.com/live?access_key=7cceb7113b3a6f9436614acd65e70c26&format=1\"\n\n// converter.jsx\nfetch(API_ENDPOINT)\n```\n\n- **리팩토링 후**\n\n```jsx\n// constants.js\nconst KEY = \"7cceb7113b3a6f9436614acd65e70c26\"\nexport const SELECT_CURRENCY = [\"KRW\", \"JPY\", \"PHP\"]\nexport const TAB_CURRENCY = [\"USD\", \"KRW\", \"JPY\", \"CAD\", \"HKD\", \"CNY\"]\nexport const API_ENDPOINT = currencies =>\n  `http://api.currencylayer.com/live?access_key=${KEY}&currencies=${currencies}&format=1`\n\n// converter.jsx\nfetch(API_ENDPOINT(TAB_CURRENCY.join(\",\")))\n```\n\n### API fetch 실패 시 로딩화면 추가\n\n처음에는 사용자가 입력창에 값을 입력하기 전 까지는 fetch 성공여부를 알 수 없었다. (fetch 실패 시 계산 안됨). 그래서 fetch가 실패한 경우 로딩이 실패했다는 UI를 보여줌으로써 사용자가 입력창에 입력을 해서 확인해보는 불필요한 작업을 최소화시켰다.\n\n<img src=\"https://user-images.githubusercontent.com/68415905/154838974-eb069e65-bbf1-4dbc-8794-2560ec8ac318.JPG\" width=\"450\" />\n\n### Netlify 배포 오류\n\n![error](https://user-images.githubusercontent.com/68415905/154839736-666c1574-4817-4461-9789-6d8edcf6bbda.jpg)\n프로젝트가 끝난 후, Netlify로 배포를 하려는데 `Mixed Content`라는 HTTP 관련 이슈가 생겨 배포가 안되는 문제가 발생했다. 알아본 결과 최신 브라우저에서는 `https` 페이지에서 `http` 리소스를 요청할 수 없다는 것을 알게되었다. 로컬에서는 API 사용이 가능했던 이유는 리액트 개발 서버는 http도 사용하기 때문이라고 했다.\n\n그래서 차선책으로 HTTP 업로드가 가능한 AWS를 통해 배포를 하기로 결정했다.\n[AWS 링크](http://beefplz.s3-website.ap-northeast-2.amazonaws.com/)\n\n하지만 AWS는 Netlify처럼 자동으로 업데이트되지 않고 배포한 사람이 매번 직접 빌드를 해야한다는 단점이 있었다. 그래서 Netlify에서 앞서 발생한 이슈를 해결할 수 있는 방법이 있을까 찾아보다가 public 위치에 `_redirects`라는 파일을 만들면 된다는 글을 보게되었다!\n\n```bash\n// _redirects\n/api/* http://api.currencylayer.com/:splat 200\n```\n\n```jsx\nfetch(`http://api.currencylayer.com/live?access_key=${KEY}`)\n👇\nfetch(`/api/live?access_key=${KEY}`)\n```\n\n`_redirects`에 HTTP 주소를 추가한 후, fetch 경로를 위처럼 수정하니 HTTP 이슈 없이 Netlify 배포에 성공했다! 🎉\n\n<br />\n\n> REFERENCE<br />Netlify 공식문서 https://www.netlify.com/blog/2021/12/13/setting-up-redirects-on-netlify/\n"},{"excerpt":"✨ useReducer 정의 useState처럼 state를 생성 및 관리하는 hook입니다. 여러개의 하위값을 가진 복잡한 state를 다뤄야하거나 배열값에 추가,삭제,수정 등의 동시작업이 필요한 경우 사용합니다.  : state 업데이트를 위한 요구  : 요구의 내용  : state를 업데이트하는 역할 (은행) reducer 🔎 useReducer 사…","fields":{"slug":"/hook-useReducer/"},"frontmatter":{"date":"January 25, 2022","title":"[React] React Hook - useReducer","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useReducer 정의\n\nuseState처럼 state를 생성 및 관리하는 hook입니다. 여러개의 하위값을 가진 복잡한 state를 다뤄야하거나 배열값에 추가,삭제,수정 등의 동시작업이 필요한 경우 사용합니다.\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState)\n```\n\n- `dispatch` : state 업데이트를 위한 요구\n- `action` : 요구의 내용\n- `reducer` : state를 업데이트하는 역할 (은행)\n\n![reducer](https://user-images.githubusercontent.com/68415905/156757818-b586bdeb-e253-4466-80eb-0b9af175d2e9.JPG)\n\n## 🔎 useReducer 사용하기\n\n### 1. 필요한 action 정하기\n\nreducer에서 사용할 action은 상수화시켜 관리하면 유지보수가 편리합니다.\n\n```jsx\nconst ACTION_TYPES = {\n  DEPOSIT: \"deposit\",\n  WITHDRAW: \"withdraw\",\n}\n```\n\n### 2. reducer 함수 작성\n\nreducer함수에는 `switch`~`case`문을 사용하여 action에 따라 state를 업데이트 시켜주는 코드를 작성합니다. `payload`란 배나 비행기에 실려온 '화물'을 뜻하는데 여기서는 action이 실행되었을 때 전달되는 값을 의미합니다.\n\n```jsx\n// 기존 state에 전달된 payload 값을 더하거나 빼서 state 업데이트\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case ACTION_TYPES.DEPOSIT:\n      return state + action.payload\n    case ACTION_TYPES.WITHDRAW:\n      return state - action.payload\n    default:\n      return state\n  }\n}\n```\n\n### 3. useReducer 호출\n\nuseReducer의 인자로 reducer 함수와 초기값(initialState)을 넘겨주면 state와 dispatch를 반환합니다. (`state`: 현재 상태 / `dispatch`: state 업데이트에 필요한 요구)\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState)\n```\n\n### 4. dispatch로 action 실행\n\n`dispatch`를 사용해서 필요한 값을 전달하고 action을 실행합니다. ex) '입금' 버튼을 클릭했을 때, 'DEPOSIT' action 실행. '출금' 버튼을 클릭했을 때, 'WITHDRAW' action 실행\n\n```jsx\nconst [value, setValue] = useState(0)\nconst [money, dispatch] = useReducer(reducer, 0)\nconst handleDeposit = () =>\n  dispatch({ type: ACTION_TYPES.DEPOSIT, payload: number })\nconst handleWithdraw = () =>\n  dispatch({ type: ACTION_TYPES.WITHDRAW, payload: number })\n\nreturn (\n  <div>\n    <h2>Reducer 은행</h2>\n    <p>잔고 : {money}원</p>\n    <input type=\"number\" value={value} step=\"1000\" />\n    <button onclick={handleDeposit}>입금</button>\n    <button onclick={handleWithdraw}>출금</button>\n  </div>\n)\n```\n\n## 🧐 useReducer 예시\n\n### reducer 함수\n\n```jsx\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"CHANGE_INPUT\":\n      return {\n        ...state,\n        inputs: {\n          ...state.inputs,\n          [action.name]: action.value,\n        },\n      }\n    case \"CREATE_USER\":\n      return {\n        inputs: initialState.inputs,\n        users: state.users.concat(action.user),\n      }\n    case \"TOGGLE_USER\":\n      return {\n        ...state,\n        users: state.users.map(user =>\n          user.id === action.id ? { ...user, active: !user.active } : user\n        ),\n      }\n    case \"REMOVE_USER\":\n      return {\n        ...state,\n        users: state.users.filter(user => user.id !== action.id),\n      }\n    default:\n      return state\n  }\n}\n```\n\n### dispatch 함수\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState)\nconst nextId = useRef(4)\n\nconst { users } = state\nconst { username, email } = state.inputs\n\nconst onChange = useCallback(e => {\n  const { name, value } = e.target\n  dispatch({\n    type: \"CHANGE_INPUT\",\n    name,\n    value,\n  })\n}, [])\n\nconst onCreate = useCallback(() => {\n  dispatch({\n    type: \"CREATE_USER\",\n    user: {\n      id: nextId.current,\n      username,\n      email,\n    },\n  })\n  nextId.current += 1\n}, [username, email])\n\nconst onToggle = useCallback(id => {\n  dispatch({\n    type: \"TOGGLE_USER\",\n    id,\n  })\n}, [])\n\nconst onRemove = useCallback(id => {\n  dispatch({\n    type: \"REMOVE_USER\",\n    id,\n  })\n}, [])\n```\n\n<br/>\n\n> REFERENCE<br /> Youtube 별코딩 https://youtu.be/tdORpiegLg0<br/>벨로퍼트 리액트 https://react.vlpt.us/basic/20-useReducer.html\n"},{"excerpt":"✨ useCallback 정의 useCallback은 useMemo와 같이 Memoization 기법을 사용하여 컴포넌트 최적화에 사용됩니다. useMemo는 함수에서 반환되는 '값'을 저장한다면 useCallback은 '함수 그 자체'를 저장해두고 재사용하는 것입니다. useCallback 역시 2개의 인자를 필요로 하는데, memoization할 콜백…","fields":{"slug":"/hook-useCallback/"},"frontmatter":{"date":"January 20, 2022","title":"[React] React Hook - useCallback","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useCallback 정의\n\nuseCallback은 useMemo와 같이 Memoization 기법을 사용하여 컴포넌트 최적화에 사용됩니다. useMemo는 함수에서 반환되는 '값'을 저장한다면 useCallback은 '함수 그 자체'를 저장해두고 재사용하는 것입니다. useCallback 역시 2개의 인자를 필요로 하는데, memoization할 콜백함수와 dependency array를 인자로 받아옵니다.\n\n```jsx\nconst result = useCallback(() => {\n  return value\n}, [])\n```\n\n## 🔎 useCallback 사용하기\n\n함수형 컴포넌트가 렌더링되면 내부의 모든 변수가 초기화됩니다. 그러므로 컴포넌트 내부에 존재하는 함수 역시 렌더링될 때마다 초기화되고 새로운 함수가 생성됩니다.\n\n이때, 내부 함수를 useCallback으로 감싸주면, 컴포넌트가 렌더링 되어도 함수가 초기화되는 것을 막을 수 있습니다. 첫 렌더링 때, 함수 객체를 만들어서 초기화한 후 저장해두고 이후 렌더링 부터는 저장된 함수를 사용하는 것 입니다.\n\n- `useCallback` 적용 전\n\n```jsx\nfunction App() {\n  const [number, setNumber] = useState(0);\n  const someFunction = () => { // 렌더링마다 초기화\n    console.log(`number: ${number}`)\n    return\n  }\n\n  useEffect(() => {\n    console.log(\"someFunction이 변경되었습니다.\")\n  }, [someFunction])\n\n  return (\n    // 렌더링 발생 로직..\n  )\n}\n```\n\n<br/>\n\n- `useCallback` 적용 후\n\n```jsx\nfunction App() {\n  const [number, setNumber] = useState(0);\n  const someFunction = useCallback(() => { // 첫 렌더링에만 초기화\n    console.log(`number: ${number}`)\n    return\n  }, [number]); // number가 바뀔 때 만 업데이트\n\n  useEffect(() => {\n    console.log(\"someFunction이 변경되었습니다.\")\n  }, [someFunction])\n\n  return (\n    // 렌더링 발생 로직..\n  )\n}\n```\n\n<br/>\n<br/>\n\n> REFERENCE<br/>Youtube 별코딩 https://youtu.be/XfUF9qLa3mU<br/>useCallback 과 useMemo 의 차이 https://basemenks.tistory.com/238\n"},{"excerpt":"✨ useMemo 정의 useMemo는 'Memoization' 되어있는 값을 반환시켜주는 hook입니다. Memoization이란 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말합니다. Memoization을 절적히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션…","fields":{"slug":"/hook-useMemo/"},"frontmatter":{"date":"January 14, 2022","title":"[React] React Hook - useMemo","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useMemo 정의\n\nuseMemo는 'Memoization' 되어있는 값을 반환시켜주는 hook입니다. Memoization이란 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말합니다. Memoization을 절적히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션의 성능을 최적화할 수 있습니다.\n\n```jsx\nconst result = useMemo(() => {\n  return calculate(a, b) // 10\n}, [a, b])\n```\n\n- 컴포넌트 성능 최적화에 사용된다!\n- dependency array에 추가한 값이 업데이트되면 useMemo값도 업데이트 된다.\n- 꼭 필요할 때만 사용할 것! 추가로 메모리를 소비해야하므로 많이 쓴다고 좋은 것 x\n\n## 🔎 useMemo 특징\n\n### 1. state 관리 최적화\n\n- `useMemo` 적용 전\n\nApp 컴포넌트가 렌더링될 때마다, `hardCalculate`와 `easyCalculate`가 다시 실행되어 딜레이가 발생할 수 있습니다.\n\n```jsx\n// calculate.js\nconst hardCalculate = num => {\n  console.log(\"어려운 계산!\")\n  for (let i = 0; i < 999999999; i++) {} // take your time..\n  return num + 10000\n}\nconst easyCalculate = num => {\n  console.log(\"쉬운 계산!\")\n  return num + 1\n}\n```\n\n```jsx\n// App.js\nconst App = () => {\n  const hardSum = hardCalculate(num);\n  const easySum = easyCalculate(num);\n\treturn (\n\t\t//...\n\t)\n};\n```\n\n<br/>\n\n- `useMemo` 적용 후\n\n첫 렌더링 시, useMemo가 적용된 함수의 리턴값을 저장해두고 이후 컴포넌트가 리렌더링되었을 때 저장되있던 값을 불러와 사용합니다. dependency array로 전달한 인자값이 변하면, 함수를 다시 실행 해서 저장된 값을 업데이트 시켜줍니다.\n\n```jsx\n// App.js\nconst App = () => {\n  const hardSum = useMemo(() => hardCalculate(num), [num]);\n  const easySum = easyCalculate(num);\n  return (\n    // ...\n  )\n}\n```\n\n### 2. 객체 주소 관리하기\n\n- `useMemo` 적용 전\n\nuseEffect의 dependency array로 객체를 전달할 경우, 객체에 변화가 없어도 useEffect가 실행됩니다. 렌더링이 발생하면 객체 메모리 주소가 새로운 주소로 바뀌기 때문입니다.\n\n```jsx\nconst location = {\n  country: isKorea ? \"한국\" : \"캐나다\",\n}\n\nuseEffect(() => {\n  console.log(\"렌더링\")\n}, [location])\n```\n\n위처럼 변수에 객체타입을 저장하면 객체 자신이 아닌 **객체가 담긴 메모리의 주소**가 할당됩니다. 객체값에는 변화가 없더라도 렌더링 시 `location`에 새로운 주소가 할당되었으므로 useEffect가 실행됩니다.\n\n![JPG](https://user-images.githubusercontent.com/68415905/156110497-9051a4f5-5669-4a08-9726-d16d56a86a4d.jpg)\n\n- `useMemo` 적용 후\n\nuseMemo를 사용해서 `객체 메모리 주소`값을 가진 변수가 매 렌더링 시 업데이트 되지 않도록 설정합니다. 이때, 객체 내부에서 변하는 값을 useMemo의 dependency array로 전달하여 그 값이 업데이트된 경우에만 변수(메모리주소)가 업데이트되도록 합니다.\n\n```jsx\nconst location = useMemo(() => {\n\treturn {\n\t  country: isKorea ? '한국' : '캐나다',\n\t};\n}, [isKorea]; // isKorea가 변할 때 location의 메모리 주소 업데이트\n\nuseEffect(() => {\n  console.log('렌더링');\n}, [location]); // location의 메모리주소가 업데이트 되면 실행\n```\n\n## 🚫 useMemo 사용 시 주의점\n\n성능 최적화를 할때는 기대되는 성능이 지불하는 대가에 비해서 미미하지 않은지 반드시 따져보고 사용을 해야합니다. 예를 들어, useMemo hook 함수를 남용하면, 컴포넌트의 복잡도가 올라가기 때문에 코드를 읽기도 어려워지고 유지보수성도 떨어지게 됩니다. 또한 useMemo가 적용된 레퍼런스는 재활용을 위해서 가바지 컬렉션(garbage collection)에서 제외되기 때문에 메모리를 더 쓰게 됩니다.\n\n일반적으로 수초 이상 걸리는 로직이 프론트엔드(front-end)에 존재하다는 것은 흔치 않은 일이고, 만약 그렇게 오래 걸리는 로직이 있다고 해도 useEffect 등을 이용해서 비동기로 처리하는 방안을 먼저 고려해보는 것이 좋습니다. 또한 컴포넌트가 여러 번 렌더링된다고 해서 실제로 심각한 성능 이슈로 이어지는 경우가 매우 적기때문에 무조건적인 useMemo의 사용은 지양할 필요가 있습니다.\n\n<br/>\n<br/>\n\n> REFERENCE<br />Youtube 별코딩 https://youtu.be/e-CnI8Q5RY4<br/>React Hooks: useMemo 사용법 https://www.daleseo.com/react-hooks-use-memo/\n"},{"excerpt":"✨ useContext 정의 Context API : 전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 방법 Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다. Prop drilling을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려해볼 것! **Prop drilling : …","fields":{"slug":"/hook-useContext/"},"frontmatter":{"date":"January 11, 2022","title":"[React] React Hook - useContext","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useContext 정의\n\n**Context API** : 전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 방법\n\n- Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다.\n- **Prop drilling**을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려해볼 것! <br/>\\*\\*_Prop drilling_ : 컴포넌트가 필요한 데이터를 여러 컴포넌트를 거쳐 전달받는 과정\n\n![Untitled](https://user-images.githubusercontent.com/68415905/155961762-07444598-b37f-4a31-991b-7cf610056aa4.png)\n\n## 🌱 Context 사용 전\n\n부모 App 컴포넌트에서 전역적으로 생성한 state를 자식 컴포넌트인 Header에서 사용하고자 합니다. state값은 App → Page → Header 순서로 전달됩니다. 중간에 있는 Page 컴포넌트는 state를 전달하는 매개체일 뿐, state 값을 사용하지는 않습니다.\n\n```jsx\n// App.js\nfunction App() {\n  const [isDark, setIsDark] = useState(false)\n  return <Page isDark={isDark} setIsDark={setIsDark} />\n}\n```\n\n```jsx\n// Page.js\nfunction Page({ isDark, setIsDark }) {\n  return (\n    <div>\n      <Header isDark={isDark} />\n      <Content isDark={isDark} />\n      <Footer isDark={isDark} setIsDark={setIsDark} />\n    </div>\n  )\n}\n```\n\n```jsx\n// Header.js\nfunction Header({ isDark }) {\n  return (\n    <header\n      style={{\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\n        color: isDark ? \"white\" : \"black\",\n      }}\n    ></header>\n  )\n}\n```\n\n## 🍀 Context 생성\n\n`context` 폴더를 만들고 js 파일을 생성한 후 context 코드를 작성합니다.\n\n```jsx\n// ThemeContext.js\nimport { createContext } from \"react\"\n\nexport const ThemeContext = createContext(null)\n```\n\n## 🌿 Context 전달\n\n생성한 Context는 데이터를 가진 부모컴포넌트에 import 시킨 후 `Provider`로 컴포넌트를 감싸줍니다. 그리고 `value`라는 prop에 전달하고자 하는 데이터를 집어넣어 줍니다.\n\n`Provider` 가 감싸는 모든 하위 컴포넌트는 `value`로 전달한 데이터에 접근이 가능합니다. <br/>(불필요한 props 전달 ❌)\n\n```jsx\n// App.js\nimport React, { useState } from \"react\"\nimport Page from \"./components/Page\"\nimport { ThemeContext } from \"./context/ThemeContext\"\n\nfunction App() {\n  const [isDark, setIsDark] = useState(false)\n  return (\n    <ThemeContext.Provider value={{ isDark, setIsDark }}>\n      <Page />\n    </ThemeContext.Provider>\n  )\n}\n\nexport default App\n```\n\n```jsx\n// Page.js\nfunction Page() {\n  return (\n    <div>\n      <Header />\n      <Content />\n      <Footer />\n    </div>\n  )\n}\n```\n\n## 🌳 Context 사용\n\n부모 컴포넌트에서 Context 로 state값을 전달하면 자식 컴포넌트에서 `useContext`를 사용해 데이터를 가져옵니다.\n\n```jsx\n// Header.js\nfunction Header() {\n  const { isDark } = useContext(ThemeContext) // Context 불러오기\n  return (\n    <header\n      style={{\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\n        color: isDark ? \"white\" : \"black\",\n      }}\n    ></header>\n  )\n}\n```\n\n```jsx\n// Footer.js\nimport React, { useContext } from \"react\"\nimport { ThemeContext } from \"../context/ThemeContext\"\n\nfunction Footer() {\n  const { isDark, setIsDark } = useContext(ThemeContext) // Context 불러오기\n  const toggleTheme = () => setIsDark(!isDark)\n  return (\n    <footer\n      style={{\n        backgroundColor: isDark ? \"black\" : \"lightgray\",\n      }}\n    >\n      <button onClick={toggleTheme}>Dark Mode</button>\n    </footer>\n  )\n}\n```\n"},{"excerpt":"✨ useRef 정의 Ref는 'reference'의 약자로 '참조'라는 뜻입니다. useRef는 인자로 전달된 값을 에 할당하여 객체로 반환해 주는데, 이때 current에 할당된 값은 렌더링되어도 그대로 유지됩니다.\n그래서 렌더링에 상관없이 동일한 참조값이 필요한 경우 useRef를 사용합니다. 또한 current 값이 바뀌어도 컴포넌트가 리렌더링되지…","fields":{"slug":"/hook-useRef/"},"frontmatter":{"date":"January 08, 2022","title":"[React] React Hook - useRef","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useRef 정의\n\n```jsx\nconst ref = useRef(value) // { current: value }\n```\n\nRef는 'reference'의 약자로 '참조'라는 뜻입니다. useRef는 인자로 전달된 값을 `current`에 할당하여 객체로 반환해 주는데, 이때 current에 할당된 값은 렌더링되어도 그대로 유지됩니다.\n그래서 렌더링에 상관없이 동일한 참조값이 필요한 경우 useRef를 사용합니다.\n\n또한 current 값이 바뀌어도 컴포넌트가 리렌더링되지 않기때문에 자주 업데이트 되는 값은 <br/>state가 아닌 ref로 관리하면 불필요한 렌더링을 줄일 수 있습니다.\n\n## 🤔 useRef 언제 사용할까?\n\n### 1. 컴포넌트 내부 변수 관리\n\n변화는 감지해야 하지만, 렌더링이 불필요한 변수값을 다룰 때 useRef를 사용하면 컴포넌트 성능을 높일 수 있습니다. useRef를 활용한 변수는 아래와 같은 곳에 쓰입니다.\n\n- setTimeout, setInterval을 통해 만들어진 id\n- scroll 위치\n- 배열에 새 항목을 추가할 때 필요한 고유값 key\n\n```jsx\n// App.js\nconst users = [\n  {\n    id: 1,\n    username: \"joy\",\n  },\n  {\n    id: 2,\n    username: \"user1\",\n  },\n]\n\nconst nextId = useRef(3) // 새로운 유저 id값 3으로 지정\nconst onCreate = username => {\n  users.push({\n    id: nextId, // ref에 저장된 id 값 할당\n    username: username,\n  })\n  nextId.current += 1 // id값 1 증가\n}\n```\n\n### 2. DOM 요소에 접근\n\n`Document.querySelector()` 와 비슷한 기능으로 DOM에 직접적인 접근이 필요할 때 useRef를 사용할 수 있습니다. 사용하고자 하는 DOM 요소의 인라인 속성으로 useRef 값이 할당된 변수를 전달해주면 해당 Ref의 current 값에 DOM 요소가 저장됩니다.\n\n```jsx\nconst inputRef = useRef(null)\nconsole.log(inputRef) // {current: input}\n\nreturn <input ref={inputRef} type=\"text\" />\n```\n\nDOM 요소에 접근이 필요한 경우는 아래와 같습니다.\n\n- 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.\n- 애니메이션을 직접적으로 실행시킬 때.\n- 서드 파티 DOM 라이브러리를 React와 같이 사용할 때.\n\n```jsx\n// input.js\nconst App = () => {\n  const inputRef = useRef()\n  useEffect(() => {\n    inputRef.current.focus() // input 요소에 focus\n  }, [])\n\n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" placeholder=\"username\" />\n      <button onClick={login}>로그인</button>\n    </div>\n  )\n}\n```\n\n## 🔎 useRef 특징\n\n1. 렌더링이 발생해도 current에 저장된 값은 그대로 유지됩니다.\n2. current 값이 바뀌어도 컴포넌트가 리렌더링되지 않습니다.\n\n### Ref와 변수의 차이점\n\n- 공통점 : 렌더링 발생 ❌\n\n- 차이점 : ref 와 변수에 각각 값을 저장하다가 **렌더링이 발생하면** 변수에 저장된 값은 초기화되지만 ref에 저장된 값은 그대로 유지됩니다.\n\n```jsx\nimport React, { useState, useRef } from \"react\"\n\nconst App = () => {\n  const [render, setRender] = useState(0)\n  console.log(\"렌더링 발생!!\")\n  const countRef = useRef(0)\n  let countVar = 0\n\n  return (\n    <div>\n      <p>Ref: {countRef.current}</p>\n      <p>Var: {countVar}</p>\n      <button onClick={() => countRef.current++}>Ref올려</button>\n      <button onClick={() => countVar++}>Var올려</button>\n      <button onClick={() => setRender(render + 1)}>렌더링 발생!</button>\n    </div>\n  )\n}\nexport default App\n```\n\n```jsx\nRef : 0 , Var : 0\nRef : 1 , Var : 1\nRef : 2 , Var : 2\nRef : 3 , Var : 3\n렌더링 발생!!\nRef : 4 , Var : 0\nRef : 5 , Var : 1\nRef : 6 , Var : 2\n렌더링 발생!!\nRef : 7 , Var : 0\nRef : 8 , Var : 1\n```\n\n### Ref와 state의 차이점\n\n- `state` 변화 → 렌더링 ⭕ → 컴포넌트 내부 변수들 초기화\n\n- `ref` 변화 → 렌더링 ❌ → 변수 값이 유지됨 <br/>\n  (state에 의해 다시 렌더링 되었을 때도 그대로 유지)\n\n```jsx\nimport React, { useState, useRef } from \"react\"\n\nconst App = () => {\n  const [count, setCount] = useState(0)\n  const countRef = useRef(0)\n  console.log(\"렌더링!\")\n\n  return (\n    <div>\n      <p>State: {count}</p>\n      <p>Ref: {countRef.current}</p>\n      <button onClick={() => setCount(count + 1)}>State올려</button>\n      <button onClick={() => countRef.current++}>Ref올려</button>\n    </div>\n  )\n}\nexport default App\n```\n\n- `state올려` 버튼 클릭 : 클릭할 때마다 화면에 증가한 state값이 나타납니다.\n\n  → state가 매번 업데이트되면서 App 컴포넌트가 다시 렌더링 되기 때문\n\n- `ref올려` 버튼 클릭 : 화면에는 변화가 없지만 내부적으로 ref값이 증가합니다.\n\n  → ref는 렌더링을 발생시키지 않으므로 화면이 업데이트되지 않기 때문\n\n  → 이후에 state가 변하고 렌더링이 발생하면, 이때 변화된 ref값이 화면에 나타난다!\n\n### useRef로 무한렌더링 방지\n\n렌더링 될 때마다 렌더링 횟수를 카운트하는 state를 만들고자 합니다. 아래 코드처럼 useEffect 내부에 상태 업데이트 함수를 사용하면 이렇게 무한루프가 발생하게 됩니다.\n\n렌더링 → `useEffect` 실행→ `setRenderCount` → state 업데이트 → 렌더링 → `useEffect` 실행 → `setRenderCount` → state 업데이트 → 렌더링 ...\n\n```jsx\nconst [renderCount, setRenderCount] = useState(1)\n\nuseEffect(() => {\n  console.log(\"렌더링\")\n  setRenderCount(renderCount + 1) // 렌더링 발생\n})\n```\n\n그러므로 이 경우에는, 렌더링 횟수를 저장하는 renderCount를 `useRef`로 관리하면 `useEffect` 내부에서 렌더링이 발생하지 않으므로 무한 렌더링을 막을 수 있습니다.\n\n```jsx\nconst renderCount = useRef(1)\n\nuseEffect(() => {\n  console.log(\"렌더링\")\n  renderCount.current++ // 렌더링 발생 ❌\n})\n```\n\n<br />\n<br />\n\n> REFERENCE<br /> Youtube 별코딩 https://youtu.be/VxqZrL4FLz8<br />[React] useRef() 는 언제 사용하는가? https://yoonjong-park.tistory.com/entry/React-useRef-는-언제-사용하는가\n"},{"excerpt":"✨ useEffect 정의 첫 렌더링 할 때(mount), 다시 렌더링될 때(update), 화면에서 사라질 때(unmount), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다.  를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다. 렌더링될 때마다 실행 - De…","fields":{"slug":"/hook-useEffect/"},"frontmatter":{"date":"December 26, 2021","title":"[React] React Hook - useEffect","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useEffect 정의\n\n첫 렌더링 할 때(**mount**), 다시 렌더링될 때(**update**), 화면에서 사라질 때(**unmount**), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다. `useEffect` 를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다.\n\n- 렌더링될 때마다 실행 - Dependency array ❌\n\n```jsx\nuseEffect(() => {\n  // code...\n})\n```\n\n- 첫 렌더링될 때(mount)만 실행 - Dependency array 빈 배열\n\n```jsx\nuseEffect(() => {\n  // code ...\n}, [])\n```\n\n- 첫 렌더링 될때 + 특정 `state`**가 바뀔 때** 실행 - Dependency array에 `state` 전달\n\n```jsx\nuseEffect(() => {\n  // code ...\n}, [value])\n```\n\n- 컴포넌트 unmount 시 실행 - `return` 추가\n\n```jsx\nuseEffect(() => {\n  // code ...\n  return () => {\n    // clean up!!\n  }\n}, [])\n```\n\n## 🤔 useEffect 언제 사용할까?\n\n### 마운트할 때 필요한 작업\n\n- props 로 받은 값을 컴포넌트의 로컬 상태로 설정\n- 외부 API 요청 (REST API 등)\n- 라이브러리 사용 (D3, Video.js 등...)\n- setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약\n\n### 언마운트할 때 필요한 작업\n\n- setInterval, setTimeout 을 사용하여 등록한 작업들 clear 하기<br/>\n  (clearInterval, clearTimeout)\n- 라이브러리 인스턴스 제거\n\n## 🔎 useEffect 제대로 사용하기\n\n### Dependency Array\n\n해당 컴포넌트에 state가 여러개 있는 경우, state가 호출될 때 다른 state값도 다같이 렌더링 됩니다. 이때 useEffect를 사용해 dependency array에 호출하고자 하는 state값을 전달해주면 다른 불필요한 state 렌더링을 막을 수 있습니다.\n\n```jsx\nconst [count, setCount] = useState(1)\nconst [name, setName] = useState(\"\")\n\n// count만 렌더링!  name은 사용 x\nuseEffect(() => {\n  console.log(\"count 렌더링\")\n}, [count])\n\n// name만 렌더링! count은 사용 x\nuseEffect(() => {\n  console.log(\"name 렌더링\")\n}, [name])\n```\n\n### return\n\n`useEffect` 에서는 함수를 return 할 수 있는데 이때 반환되는 함수를 **cleanup 함수**라고 부릅니다. cleanup 함수는 useEffect 에 대한 뒷정리를 해준다고 이해하시면 되는데요, deps 가 비어있는 경우에는 컴포넌트가 사라질 때 cleanup 함수가 호출됩니다.\n\n**_timer.js_**\n\n```jsx\nimport React, {useEffect} from 'react';\n\nconst Timer = () => {\n\tuseEffect(()=> {\n\t\t// 컴포넌트가 mount 될 때 실행\n\t\tconst timer = setInterval(() => {\n\t\t\tconsole.log('타이머 실행 중....');\n\t\t}, 1000);\n\n\t\t// 컴포넌트가 unmount 될 때 실행\n\t\treturn () => {\n\t\t\tclearInterval(timer);\n\t\t\tconsole.log('타이머 종료!');\n\t\t}\n}, []);\nreturn (\n\t<div>타이머를 시작합니다.</div>\n)\nexport default Timer;\n```\n\n**_App.js_**\n\n```jsx\nimport React, { useState } from \"react\"\nimport Timer from \"./Timer\"\n\nfunction App() {\n  const [showTimer, setShowTimer] = useState(false)\n  return (\n    <div>\n      {showTimer && <Timer />}\n      <button onClick={() => setShowTimer(!showTimer)}>Toggle</button>\n    </div>\n  )\n}\nexport default App\n```\n\n<br />\n\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/16-useEffect.html<br/>Youtube 별코딩 https://youtu.be/kyodvzc5GHU\n"},{"excerpt":"✨ useState 정의 상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.  : 상태 값 저장 변수 (현재 상태 값)  : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수) 💡 useState…","fields":{"slug":"/hook-useState/"},"frontmatter":{"date":"December 23, 2021","title":"[React] React Hook - useState","tags":["frontend","react"]},"rawMarkdownBody":"\n## ✨ useState 정의\n\n상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.\n\n```jsx\nconst [state, setState] = useState(<상태 초기 값>);\n```\n\n- `state` : 상태 값 저장 변수 (현재 상태 값)\n- `setState` : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수)\n\n## 💡 useState 예시\n\n### Counter 만들기\n\n초기값을 1로 설정 후, 버튼 클릭할 때마다 상태값(`count`)이 +1씩 업데이트 됩니다.\n\n```jsx\n// count.js\nimport { useState } from \"react\"\n\nfunction Count() {\n  const [count, setCount] = useState(1) // 초기값이 1인 count(state) 생성\n  const handleClick = () => {\n    setCount(count + 1) // 클릭 이벤트 발생 시, count = count + 1\n  }\n  return (\n    <div>\n      <span>클릭 횟수 : {count}</span>\n      <button onClick={handleClick}>Update</button>\n    </div>\n  )\n}\n```\n\n## 🔎 useState 제대로 사용하기\n\n### state가 배열 or 객체일 때?\n\n`setState` 함수로 `state`의 상태를 업데이트할 때는, **콜백함수** 내부에서 스프레드 연산자(`...`)로 이전 상태값을 가져온 뒤 현재 입력값을 추가하여 덮어쓰는 방식으로 사용합니다.\n\n```jsx\nconst updateArray = () => {\n  setNames(prevState => [newName, ...prevState])\n}\n```\n\n```jsx\nconst updateObject = () => {\n  const name = \"joy\"\n  const job = \"developer\"\n  setJobs(prevState => ({\n    ...prevState,\n    [name]: job,\n  }))\n}\n```\n\n### useState 최적화\n\nuseState가 호출되면 컴포넌트가 다시 렌더링됩니다. state 초기값을 호출하는 루트가 복잡한 경우 컴포넌트가 렌더링될 때마다 다시 실행되서 성능이 떨어지게 됩니다. 이때, useState 내부에 **콜백함수**를 만들어 초기값을 선언하면 첫 렌더링 때만 불러오므로 불필요한 메모리 소비를 막을 수 있습니다.\n\n```jsx\nimport {useState} from 'react';\n\nconst heavyWork = () => {\n\tconsole.log('엄청 무거운 작업!!')\n\treturn ['Joy', 'Hana']\n}\n\nfunction Input() {\n\tconst [names, setNames] = useState(() => {\n\t\treturn heavyWork(); // callback으로 초기값 선언\n\t});\n\tconst [input, setInput] = useState('');\n\n\tconst handleChange = (e) => {\n\t\tsetInput(e.target.value);\n\t}\n\tconst handleUpload =() => {\n\t\tsetNames((prev) => {\n\t\t\treturn([input, ...prev];\n\t\t});\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<input type=\"text\" value={input} onChnage={handleChange} />\n\t\t\t<button onClick={handleUpload}>Upload</button>\n\t\t\t{names.map((name,i) => {\n\t\t\t\treturn <p key={i}>{name}</p>\n\t\t\t})}\n\t\t</div>\n\t);\n}\n```\n\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/07-useState.html<br/>Youtube 별코딩 https://youtu.be/G3qglTF-fFI\n"},{"excerpt":"🌟 Hook의 등장 배경 리액트 컴포넌트 종류 : Class Component / Functional Component Hook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없…","fields":{"slug":"/about-react-hook/"},"frontmatter":{"date":"December 22, 2021","title":"[React] React Hook이란?","tags":["frontend","react"]},"rawMarkdownBody":"\n## 🌟 Hook의 등장 배경\n\n리액트 컴포넌트 종류 : **Class Component** / **Functional Component**\n\nHook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없었던 state관리나 Life Cycle Method가 가능하다는 이유로 어쩔 수 없이 Class Component를 사용해왔습니다.\n\nHook이 등장하기 전의 리액트는\n\n- 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어려웠습니다.\n\n- 생명주기 컴포넌트로 인한 복잡한 컴포넌트는 이해하기 어려웠습니다. 상태관련 로직이 모두 같은 공간에 위치하기 때문입니다.\n\n## 🧐 Hook 이란?\n\nHook은 리액트 16.8 버전 이후 함수형 컴포넌트에 추가된 기능입니다. 즉, React Hook은 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할 수 있도록 해주는 기능이며 Hook이 등장하면서 더 이상 상태를 관리하기 위해 Class Component를 쓸 필요가 없어졌습니다.\n\n기존에는 Class Component 에서만 상태를 관리 할 수 있었고, 함수형 컴포넌트에서는 상태를 관리할 수 없었습니다. 하지만 Hook이 등장하면서 함수형 컴포넌트 에서도 상태 관리를 할 수 있게 되었고, 상태 관리 뿐만 아니라 기존 클래스형 컴포넌트에서만 가능하던 여러 기능을 사용할 수 있게 되었습니다.\n\n👉 [React Hook 공식문서 바로가기](https://reactjs.org/docs/hooks-intro.html)\n\n## 🧾 Hook의 종류\n\n### useState\n\n가장 대표적인 Hook으로 상태값을 생성 및 업데이트시켜주는 Hook입니다.\n\n👉 [useState 더 알아보기](https://devjoylee.github.io/hook-useState)\n\n### useEffect\n\n컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정하는 Hook입니다.\n\n👉 [useEffect 더 알아보기](https://devjoylee.github.io/hook-useEffect)\n\n### useReducer\n\nuseState처럼 상태관리에 쓰이며 구조가 복잡한 상태관리에 적합한 Hook입니다.\n\n👉 [useReducer 더 알아보기](https://devjoylee.github.io/hook-useReducer)\n\n### useRef\n\n렌더링과 관련없는 값을 관리하거나 DOM에 접근이 필요한 경우 사용하는 Hook입니다.\n\n👉 [useRef 더 알아보기](https://devjoylee.github.io/hook-useRef)\n\n### useMemo\n\n렌더링 시 메모리에 값을 저장해두고 필요할 때 불러와서 사용할 수 있도록 하는 Hook입니다.\n\n👉 [useMemo 더 알아보기](https://devjoylee.github.io/hook-useMemo)\n\n### useCallback\n\nuseMemo와 비슷하나 값이 아닌 함수를 재사용하고자 할 때 사용하는 Hook입니다.\n\n👉 [useCallback 더 알아보기](https://devjoylee.github.io/hook-useCallback)\n\n### useContext\n\n전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 Hook입니다.\n\n👉 [useContext 더 알아보기](https://devjoylee.github.io/hook-useContext)\n\n<br />\n\n> REFERENCE<br /> React(23) 리액트 훅이란? https://devbirdfeet.tistory.com/52<br />리액트 공식 문서 https://reactjs.org/docs/hooks-intro.html<br/>[React] Hooks의 종류 https://lelana.tistory.com/146\n"},{"excerpt":"리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. () 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다! 리액트 시작하기 (CRA ❌) 1. 프…","fields":{"slug":"/react-scratch/"},"frontmatter":{"date":"December 21, 2021","title":"[React] 리액트 시작하기 (without CRA)","tags":["frontend","react"]},"rawMarkdownBody":"\n리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. (`npx create-react-app \"project-name\"`) 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다!\n\n## 리액트 시작하기 (CRA ❌)\n\n### 1. 프로젝트 폴더 생성 후 초기화\n\n원하는 경로에 프로젝트 폴더를 생성하고 프로젝트 초기화(`npm init -y`)를 진행합니다. 이때 `package.json`이라는 파일이 자동으로 생성되는데 이곳에 프로젝트 이름, 실행 명령어, 프로젝트에 필요한 라이브러리 등 관련 정보가 저장됩니다.\n\n```bash\nnpm init -y\n```\n\n### 2. 리액트 라이브러리 설치\n\n초기화가 끝나면 리액트 프로젝트에 필요한 패키지를 다운받습니다. 패키지 설치 방법은 아래와 같이 `npm install` 또는 `npm install --save-dev` 2가지 방식으로 가능합니다.\n\n✅ `npm i <패키지 이름>`\n\n- 배포(production mode) 할 때 해당 패키지 사용\n\n- package.json의 dependencies 항목에 저장됨\n\n```bash\nnpm i react react-dom\n```\n\n✅ `npm i --save-dev (or -D) <패키지 이름>`\n\n- 배포(production mode) 할 때 패키지 사용 ❌ (development mode에서만 사용)\n\n- package.json의 devDependencies 항목에 저장됨\n\n```bash\nnpm i -D @babel/core @babel/preset-env @babel/preset-react\nbabel-loader css-loader style-loader url-loader\nwebpack webpack-cli webpack-dev-server\nhtml-webpack-plugin\n```\n\n패키지 다운로드가 끝나면 프로젝트 폴더내부에 `node_modules` 폴더와 `package.lock.json` 파일이 새로 생성되고 (_yarn으로 설치한 경우_ `yarn.lock` _파일 생성_) `package.json`파일 내부에 아래와 같이 dependencies가 추가됩니다.\n\n![image](https://user-images.githubusercontent.com/68415905/154797755-7080fda7-541e-4ebf-a553-caa0ca4c79cc.png)\n\n### 3. `.babelrc` 파일 생성\n\n`babel` 이란 모든 브라우저에 호환이 가능하도록 최신 코드(ES6)를 구버전 코드(ES5)로 변환해주는 도구입니다. babel 설정을 위해서는 `.babelrc` 파일을 만들어 브라우저 호환에 필요한 babel 플러그인을 추가합니다. (preset : 필요한 플러그인 묶음)\n\n```bash\n// .babelrc\n{\n  presets: ['@babel/preset-env', '@babel/preset-react'],\n}\n```\n\n+) **webpack.config.js 파일 내부의 babel-loader의 옵션으로 추가한 경우 .babelrc 파일 생략 가능!!**\n\n### 4 . `webpack.config.js` 파일 생성\n\n`webpack`은 웹에서 사용되는 모든 자원(assets)을 묶음으로 번들링 해주는 도구입니다.\n\n웹팩을 사용하면 js 파일간의 종속성 뿐만 아니라 js 내에서 필요한 css나 img와 같은 파일(.css, .jpg)도 번들링해서 하나의 파일로 합쳐줘서 네트워크 요청을 최소화 시킬 수 있습니다.\n\n웹팩에 대해 자세히 알아보고 싶다면 링크를 참고해주세요!\n👉 [웹팩 포스팅 바로가기 ](https://devjoylee.github.io/dev-webpack-1)\n\n```jsx\n// webpack.config.js\nconst path = require(\"path\")\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.js\",\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"bundle.js\",\n    clean: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n          },\n        },\n      },\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n      {\n        test: /\\.(jpg|png)$/i,\n        loader: \"url-loader\",\n        options: {\n          outputPath: \"images\",\n        },\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".js\", \".jsx\"],\n  },\n  devServer: {\n    static: path.join(__dirname, \"dist\"),\n    host: \"localhost\",\n    port: 3000,\n    open: true,\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"./public/index.html\",\n      inject: false,\n    }),\n  ],\n}\n```\n"},{"excerpt":"🧐 React란? React는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다. 다운로드 ✨ React의 필요성 사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 …","fields":{"slug":"/about-react/"},"frontmatter":{"date":"December 20, 2021","title":"[React] 리액트의 개념과 특징","tags":["frontend","react"]},"rawMarkdownBody":"\n## 🧐 React란?\n\nReact는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다.\n\n![다운로드](https://user-images.githubusercontent.com/68415905/154801618-9bf1d698-3467-4f54-9df4-ebafce5b1e38.png)\n\n## ✨ React의 필요성\n\n사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 크고 UI 변화가 잦은 동적인 페이지라면 상태 변화 관리를 최소화 하고 DOM의 직접적인 업데이트를 막아주는 React 혹은 다른 프레임워크를 사용하는 것이 바람직합니다.\n\n## 🧾 React의 특징\n\n### 1. 단방향 데이터플로우\n\nReact는 데이터가 한방향으로만 이동하는 **단방향 데이터플로우**를 가집니다. 데이터가 UI로 이동하고 데이터가 변하면 UI도 함께 업데이트 되지만 반대로 UI쪽에서 데이터를 변화시키는 것은 불가능합니다. 단방향 데이터플로우를 사용하면 데이터 흐름이 간단해서 추적이 쉽고 예측이 가능해 유지보수가 편리하다는 장점이 있습니다.\n\n> ↔ 양방향 데이터 플로우 : 앵귤러(Angular.js) / 뷰(Vue.js)\n\n### 2. 가상돔(Virtual DOM)\n\nVirtual DOM이란 가상의 Document Object Model을 말합니다. 기존에는 javascript에서 DOM에 직접 접근하여 변화를 주는 방식을 사용하였는데 이경우 HTML,CSS,JS파일이 다시 리렌더링 되어 브라우저 내부에서 성능이슈가 발생했습니다.\n\nReact는 이런 단점을 보완하기 위해 Virtual DOM 이라는 것을 따로 만들었고 실제 DOM과 가상의 DOM을 비교하여 변화된 부분만 빠르게 업데이트 하는 방식을 사용하고 있습니다.\n\n**🔀 Virtual DOM 렌더링 순서**\n\n> JSX 수정 ➡ 가상 DOM 업데이트 ➡ 가상 DOM이 업데이트 되기 전과 비교하여 어떤 요소가 변경되었는지 확인 ➡ 가상 DOM에서 변경된 요소만 실제 DOM에서 업데이트\n\n### 3. Component 구조\n\n컴포넌트란 UI를 구성하는 개별 단위입니다. UI가 레고라면 컴포넌트는 하나의 블럭으로써 블럭을 쌓아 레고를 완성시키는 것처럼 컴포넌트를 조합하여 하나의 UI(페이지)를 만들 수 있습니다. 컴포넌트는 재사용이 가능하여 코드의 중복을 줄일 수 있고 효율적으로 유지보수를 할 수 있습니다.\n\n```js\nconst MainPage = () => {\n  return (\n    <Container>\n      <Header />\n      <MainContent>\n        <Section title=\"about\" />\n        <Section title=\"portfolio\" />\n      </MainContent>\n      <Footer />\n    </Container>\n  )\n}\n```\n\n### 4. JSX 문법\n\nJSX(Javascript + xml)는 Javascript에 대한 확장 구문으로서, Javascript를 좀더 편리하게 사용할 수 있도록 하는 Syntax Sugar 역할을 합니다. 이는 함수를 호출하거나 객체를 만들때 문법적인 편의를 제공하며 특히 DOM 요소를 만들 떄 `React.createElement()` 호출을 반복해야 하는 불편을 줄여줍니다. JSX는 React 엘리먼트를 생성하면서 자바스크립트의 모든 기능을 쓸 수 있도록 도와줍니다.\n\nJSX로 작성된 코드는 렌더링 시 Babel에 의해 자동으로 Javascript 코드로 컴파일됩니다.\n\n```jsx\n// jsx\n<MyButton color=\"blue\" shadowSize={2}>\n  Click Me\n</MyButton>\n```\n\n```jsx\n// javascript\nReact.createElement(\n  MyButton,\n  { color: \"blue\", shadowSize: 2 },\n  \"Click Me\"\n  //\n)\n```\n\n<br />\n\n> REFERENCE<br/>React란 무엇인가 https://firework-ham.tistory.com/5<br/>React란? https://velog.io/@jini_eun/React-React.js%EB%9E%80-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC\n"},{"excerpt":"✨ Webpack 등장 배경 이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게  을  태그에 추가하면 하나의  태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화) 👉 이전 포스팅 바로가기  image 하지만 안타깝게도 이런 모듈 시스템을 지원하는 브…","fields":{"slug":"/dev-webpack/"},"frontmatter":{"date":"November 29, 2021","title":"프론트엔드 개발환경 #3 - webpack이란?","tags":["frontend","development"]},"rawMarkdownBody":"\n## ✨ Webpack 등장 배경\n\n이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게 `type=\"module\"` 을 `script` 태그에 추가하면 하나의 `script` 태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화)\n\n👉 [이전 포스팅 바로가기 ](https://devjoylee.github.io/dev-module)\n\n![image](https://images.velog.io/images/joyact/post/dfabe050-6ecc-4706-9e40-208164cb5621/image.png)\n\n하지만 안타깝게도 이런 모듈 시스템을 지원하는 브라우저는 한정되어 있습니다. 인터넷 익스플로러를 포함한 몇 브라우저는 여전히 모듈 시스템을 사용하지 않고있습니다. 따라서 모든 브라우저에 호환가능한 모듈링 시스템이 필요했고 이때 등장한 것이 **Webpack** 입니다.\n\n---\n\n## 🧐 Webpack이란?\n\n> Webpack : a module bundler\n\n![image](https://images.velog.io/images/joyact/post/d47c7828-ea1a-4844-bf88-d950f185899c/image.png)\n\n**웹팩(Webpack)** 은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)입니다. 웹팩을 사용하면 여러개의 javascript 파일을 하나로 합쳐줌으로써 지저분한 `<script>` 태그의 반복 사용을 줄일 수 있고 효율적인 디버깅이 가능해집니다.\n\n또 다른 웹팩의 기능으로는 변환(transforming) 기능이 있습니다. ES6와 같은 모던 javascript를 ES5 형식으로 변환하고, Sass를 CSS로 변환시킴으로써 모든 브라우저가 이해할 수 있는 환경을 자체적으로 만들어냅니다.\n\n---\n\n## ➕ Webpack 설치\n\n1. npm install\n   `npm install webpack webpack-cli --save-dev`\n\n2. webpack.config.js 파일 생성\n   `module.exports` 내부에 필요한 configuration 옵션을 추가합니다.\n\n```javascript\n// webpack.config.js\nmodule.exports = {}\n```\n\n---\n\n## 🚀 Webpack의 기능\n\n![image](https://images.velog.io/images/joyact/post/835b56bd-c22f-4fdf-b49f-57559b59a90d/Full-Stack-Introduction-to-Webpack.docx-2.jpg)\n\n모듈을 번들링하기 전, Webpack은 모듈 파일들을 그래프의 형식으로 인덱싱을 하게됩니다. 이를 **Dependency Graph**라고 하며 쉽게 말해 비슷한 형태의 파일을 하나로 묶기위해 분류하는 작업이라고 볼 수 있습니다.\n<br />\n\n### 기능1. The entry point\n\n![](https://images.velog.io/images/joyact/post/2afea557-9875-4a91-ac40-94117260cc6a/image.png)\n\nThe entry point는 Dependency Graph의 출발점이자 모듈 번들링을 시작하는 파일을 의미합니다. default 값은 `./src/index.js` 이며 직접 값을 지정하고 싶은경우 아래와 같이 configuration을 설정합니다.\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: \"./app/index.js\",\n}\n```\n\n### 기능2. Loaders\n\n![image](https://images.velog.io/images/joyact/post/877e8797-5b3d-490e-9076-b428a968acf8/image.png)\n\nloader는 웹팩을 강력한 도구로 만들어주는 핵심 기능 중 하나입니다. 모듈에서 다루는 import, export 기능은 javascript와 json파일에만 국한되있는 것으로 css파일이나 image 파일을 다루게 되면 에러가 발생합니다. 하지만 loader를 사용하면 css, image 파일에도 접근이 가능하게 됩니다.\n\n1. 필요한 loader 설치\n\n   > **svg 파일 로더** : `npm install svg-inline-loader --save-dev` > **css 파일 로더** : `npm install style-loader css-loader --save-dev` > **js 파일 로더(es6->es5)** : `npm install babel-loader --save-dev`\n\n2. webpack.config.js 옵션 추가\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  rules: [\n    { test: /\\.svg$/, use: \"svg-inline-loader\" },\n    { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },\n    { test: /\\.(js)$/, use: \"babel-loader\" },\n  ],\n}\n```\n\n### 기능3. Output\n\nOutput은 번들링된 최종 파일 저장소를 뜻합니다. default 값으로 `dist/index.js` 가 설정이 되고 configuration 옵션에서 변경이 가능합니다.\n\n> **순서** : 모듈 번들링 ➡ dist 폴더 생성 ➡ dist 폴더 내부에 번들링된 최종 파일 저장\n> (생성된 파일 명은 옵션의 `filename`으로 지정)\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  output: {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"index_bundle.js\",\n  },\n}\n```\n\n### 기능4. Plugin\n\nLoader가 각 모듈(파일)을 위한 기능이라면, Plugin은 최종 번들된 파일을 위한 기능을 수행합니다.\n\n- _**HtmlWebpackPlugin**_\n\n웹팩 번들링이 완료된 후 최종파일이 생성되면, 생성된 파일을 경로로 하는 `script` 태그가 추가된 index.html 파일을 만들어주는 플러그인입니다. 만약 output의 경로가 변경되더라도 직접 html을 수정할 필요없이 자동으로 script태그의 경로가 함께 업데이트 됩니다.\n\n1. 플러그인 설치\n   `npm install html-webpack-plugin --save-dev`\n\n2. webpack.config.js 옵션 추가\n\n```javascript\n  // webpack.config.js\n\tconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\t...\n\tmodule.exports = {\n    \tplugins: [\n          new HtmlWebpackPlugin()\n        ]\n    }\n```\n\n![image](https://images.velog.io/images/joyact/post/ebea04b9-b261-4f62-911d-79da4c2a7635/image.png)\n\n> REFERENCE <br /> Youtube uidotdev Webpack Crash Course https://youtu.be/lFjinlwpcHY / <br /> 네이버 블로그 https://blog.naver.com/wlsdml1103/221333814197\n"},{"excerpt":"🧐 모듈(Module) 이란? Javascript를 공부하다보면 이라는 단어를 자주 접하게 됩니다.\nModule이란 코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n Module 사용 전 기존에는 html에  태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사…","fields":{"slug":"/dev-module/"},"frontmatter":{"date":"November 21, 2021","title":"프론트엔드 개발환경 #2 - 모듈 (Module)","tags":["frontend","development"]},"rawMarkdownBody":"\n## 🧐 모듈(Module) 이란?\n\nJavascript를 공부하다보면 `Module`이라는 단어를 자주 접하게 됩니다.\nModule이란 **코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음**을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n<br />\n\n### Module 사용 전\n\n```html\n<script src=\"./src/main.js\">\n<script src=\"./src/animation.js\">\n<script src=\"./src/banner.js\">\n```\n\n기존에는 html에 `<script>` 태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사용했습니다. 이 방식은 파일을 불러오는 순서가 코드에 영향을 주며, 생성한 파일의 object가 모두 전역 변수가되서 문제가 발생할 수 있다는 단점이 있습니다\n<br />\n\n### Module 사용 후\n\n```html\n<script type=\"module\" src=\"./src/main.js\">\n```\n\n하지만 모듈을 사용하면 하나의 `<script>` 태그만으로 모든 모듈화된 javascript 파일에 접근이 가능해져 효율적으로 코드를 관리할 수 있습니다.\n\n---\n\n## ⛓️ 파일 모듈화 하기\n\nJavascript 파일을 모듈화 하는 방식은 크게 2가지로 나뉩니다. **CommonJS**로 모듈화 하는 것과 **ES Module**로 모듈화하는 것입니다.\n<br />\n\n### CommonJS로 파일 내보내기/불러오기\n\nCommonJS는 NodeJS의 기본 모듈 시스템이며 모듈화가 되지 않고 표준 라이브러리가 없는 과거 javascript의 문제를 해결하기 위한 모듈화 방식입니다.\n\n주 키워드 : `module.exports`, `exports`, `require`\n\n- 파일 불러오기 : `require`\n- 여러 개의 객체를 내보낼 경우, `exports` 변수의 속성으로 할당\n- 딱 하나의 객체를 내보낼 경우, `module.exports` 변수 자체에 할당\n\n```javascript\n// main.js\nconst name = \"Joy\"\nconst age = 28\n//exports.name = name\n//exports.age = age\nmodule.exports = { name, age }\n\n// result.js\nconst { name, age } = require(\"./main.js\")\n```\n\n### ES Module로 파일 내보내기/불러오기\n\nES Module은 가장 대중적으로 사용되는 모듈 시스템입니다. 비동기 방식으로 작동하고 모듈에서 실제로 쓰이는 부분만 불러오기 때문에 성능과 메모리 부분에서 유리한 측면이 있습니다. 또한 직관적인 키워드를 사용해 가독성이 뛰어나고 `Named Parameter`와 같은 CommonJS에서는 지원하지 않는 기능들이 있습니다.\n\n주 키워드 : `import`, `export`, `from`, `default`\n\n```javascript\n// main.js\nexport const name = \"Joy\"\nexport const age = 28\nexport default function fullName(lastName) {\n  return name + lastName\n}\n\n// result.js\nimport fullName, { name, age } from \"./main.js\"\n```\n"},{"excerpt":"✔ npm npm : Node Package Manager(Modules) npm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다. ex)   명령어를 사용해 초기  파일을 만들고 프로젝트…","fields":{"slug":"/dev-npm/"},"frontmatter":{"date":"November 17, 2021","title":"프론트엔드 개발환경 #1 - npm / npx / yarn","tags":["frontend","development"]},"rawMarkdownBody":"\n## ✔ npm\n\n> npm : Node Package Manager(Modules)\n\nnpm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다.\n\nex) `npm install webpack`\n\n`npm init` 명령어를 사용해 초기 `package.json` 파일을 만들고 프로젝트를 초기화합니다. npm을 통해 다운된 패키지는 `package.json`에 기록됩니다.\n<br />\n\n### npm의 단점\n\n- 로컬 컴퓨터에 직접 설치되어 용량 차지가 크다\n- 다운받은 패키지의 새 버전이 나온 경우, 업데이트를 직접 해주어야한다.\n\n---\n\n## ✔ npx\n\n> npx : Node Package Runner\n\nnpx는 npm 5.2.0 버전부터 새로 도입된 패키지 관리 도구입니다. npm 5.2.0 버전 이상을 다운받았다면 자동으로 설치되며 이는 npm을 좀더 편리하게 사용할 수 있도록 도와줍니다.\n\nex) `npx install webpack`\n<br />\n\n### npx의 장점\n\n- 패키지를 컴퓨터에 직접 저장하지 않고 일회성으로 패키지를 사용해 용량차지를 하지 않는다.\n- 매번 최신 업데이트된 패키지를 사용할 수 있다.\n  <br />\n\n### npx 동작방법\n\n1. 기본적으로, 실행할 패키지가 실행 가능한 경로에 있는지 확인한다. (예를 들면, 프로젝트내에서 다운된 패키지가 있는지 확인)\n2. 만약에 있다면, 그것을 실행한다.\n3. 아니라면 패키지가 설치가 되지 않았다는 것으로 판단하여, npx가 가장 최신 버전의 패키지를 설치하고 실행한다.\n\n---\n\n## ✔ yarn\n\nyarn은 npm과 같은 패키지 매니저입니다. 차이점이 있다면 Node.js 설치시에 함께 설치되지 않고 별도의 명령어를 사용해 설치합니다. yarn을 사용하면 `yarn.lock` 이라는 파일에 다운한 패키지가 기록되며 이 파일은 모든 디바이스에 같은 패키지를 설치하는 것을 보장합니다.\n\nyarn 설치 : `npm install -g yarn`\n\n```bash\n# npm 사용법\nnpm install <package>\nnpm uninstall <package>\n\n# yarn 사용법\nyarn add <package>\nyarn remove <package>\n```\n\n### yarn의 장점\n\n- 속도나 안전성은 npm과 비슷하나 npm보다 보안이 뛰어나고 의존성 관리를 강조한다.\n- 버전을 어디에서나 같게 만들어 버전 충돌에 의한 버그가 적다.\n\n### yarn의 단점\n\n- npm에 비해 레퍼런스가 적고 덜 보편적이다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}
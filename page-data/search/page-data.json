{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"✨ Webpack 등장 배경 이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게  을  태그에 추가하면 하나의  태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화) 👉 이전 포스팅 바로가기  image 하지만 안타깝게도 이런 모듈 시스템을 지원하는 브…","fields":{"slug":"/webpack-1/"},"frontmatter":{"date":"November 29, 2021","title":"프론트엔드 개발환경 #3 - webpack이란?","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✨ Webpack 등장 배경\r\n\r\n이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게 `type=\"module\"` 을 `script` 태그에 추가하면 하나의 `script` 태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화)\r\n\r\n👉 [이전 포스팅 바로가기 ](https://devjoylee.github.io/module)\r\n\r\n![image](https://images.velog.io/images/joyact/post/dfabe050-6ecc-4706-9e40-208164cb5621/image.png)\r\n\r\n하지만 안타깝게도 이런 모듈 시스템을 지원하는 브라우저는 한정되어 있습니다. 인터넷 익스플로러를 포함한 몇 브라우저는 여전히 모듈 시스템을 사용하지 않고있습니다. 따라서 모든 브라우저에 호환가능한 모듈링 시스템이 필요했고 이때 등장한 것이 **Webpack** 입니다.\r\n\r\n---\r\n\r\n## 🧐 Webpack이란?\r\n\r\n> Webpack : a module bundler\r\n\r\n![image](https://images.velog.io/images/joyact/post/d47c7828-ea1a-4844-bf88-d950f185899c/image.png)\r\n\r\n**웹팩(Webpack)**은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)입니다. 웹팩을 사용하면 여러개의 javascript 파일을 하나로 합쳐줌으로써 지저분한 `<script>` 태그의 반복 사용을 줄일 수 있고 효율적인 디버깅이 가능해집니다.\r\n\r\n또 다른 웹팩의 기능으로는 변환(transforming) 기능이 있습니다. ES6와 같은 모던 javascript를 ES5 형식으로 변환하고, Sass를 CSS로 변환시킴으로써 모든 브라우저가 이해할 수 있는 환경을 자체적으로 만들어냅니다.\r\n\r\n---\r\n\r\n## ➕ Webpack 설치\r\n\r\n1. npm install\r\n   `npm install webpack webpack-cli --save-dev`\r\n\r\n2. webpack.config.js 파일 생성\r\n   `module.exports` 내부에 필요한 configuration 옵션을 추가합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {}\r\n```\r\n\r\n---\r\n\r\n## 🚀 Webpack의 기능\r\n\r\n![image](https://images.velog.io/images/joyact/post/835b56bd-c22f-4fdf-b49f-57559b59a90d/Full-Stack-Introduction-to-Webpack.docx-2.jpg)\r\n\r\n모듈을 번들링하기 전, Webpack은 모듈 파일들을 그래프의 형식으로 인덱싱을 하게됩니다. 이를 **Dependency Graph**라고 하며 쉽게 말해 비슷한 형태의 파일을 하나로 묶기위해 분류하는 작업이라고 볼 수 있습니다.\r\n<br />\r\n\r\n### 기능1. The entry point\r\n\r\n![](https://images.velog.io/images/joyact/post/2afea557-9875-4a91-ac40-94117260cc6a/image.png)\r\n\r\nThe entry point는 Dependency Graph의 출발점이자 모듈 번들링을 시작하는 파일을 의미합니다. default 값은 `./src/index.js` 이며 직접 값을 지정하고 싶은경우 아래와 같이 configuration을 설정합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  entry: \"./app/index.js\",\r\n}\r\n```\r\n\r\n### 기능2. Loaders\r\n\r\n![image](https://images.velog.io/images/joyact/post/877e8797-5b3d-490e-9076-b428a968acf8/image.png)\r\n\r\nloader는 웹팩을 강력한 도구로 만들어주는 핵심 기능 중 하나입니다. 모듈에서 다루는 import, export 기능은 javascript와 json파일에만 국한되있는 것으로 css파일이나 image 파일을 다루게 되면 에러가 발생합니다. 하지만 loader를 사용하면 css, image 파일에도 접근이 가능하게 됩니다.\r\n\r\n1. 필요한 loader 설치\r\n\r\n   > **svg 파일 로더** : `npm install svg-inline-loader --save-dev` > **css 파일 로더** : `npm install style-loader css-loader --save-dev` > **js 파일 로더(es6->es5)** : `npm install babel-loader --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  rules: [\r\n    { test: /\\.svg$/, use: \"svg-inline-loader\" },\r\n    { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },\r\n    { test: /\\.(js)$/, use: \"babel-loader\" },\r\n  ],\r\n}\r\n```\r\n\r\n### 기능3. Output\r\n\r\nOutput은 번들링된 최종 파일 저장소를 뜻합니다. default 값으로 `dist/index.js` 가 설정이 되고 configuration 옵션에서 변경이 가능합니다.\r\n\r\n> **순서** : 모듈 번들링 ➡ dist 폴더 생성 ➡ dist 폴더 내부에 번들링된 최종 파일 저장\r\n> (생성된 파일 명은 옵션의 `filename`으로 지정)\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  output: {\r\n    path: path.resolve(__dirname, \"dist\"),\r\n    filename: \"index_bundle.js\",\r\n  },\r\n}\r\n```\r\n\r\n### 기능4. Plugin\r\n\r\nLoader가 각 모듈(파일)을 위한 기능이라면, Plugin은 최종 번들된 파일을 위한 기능을 수행합니다.\r\n\r\n- _**HtmlWebpackPlugin**_\r\n\r\n웹팩 번들링이 완료된 후 최종파일이 생성되면, 생성된 파일을 경로로 하는 `script` 태그가 추가된 index.html 파일을 만들어주는 플러그인입니다. 만약 output의 경로가 변경되더라도 직접 html을 수정할 필요없이 자동으로 script태그의 경로가 함께 업데이트 됩니다.\r\n\r\n1. 플러그인 설치\r\n   `npm install html-webpack-plugin --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n  // webpack.config.js\r\n\tconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\t...\r\n\tmodule.exports = {\r\n    \tplugins: [\r\n          new HtmlWebpackPlugin()\r\n        ]\r\n    }\r\n```\r\n\r\n![image](https://images.velog.io/images/joyact/post/ebea04b9-b261-4f62-911d-79da4c2a7635/image.png)\r\n\r\n> REFERENCE <br /> Youtube uidotdev Webpack Crash Course https://youtu.be/lFjinlwpcHY / <br /> 네이버 블로그 https://blog.naver.com/wlsdml1103/221333814197\r\n"},{"excerpt":"🧐 모듈(Module) 이란? Javascript를 공부하다보면 이라는 단어를 자주 접하게 됩니다.\nModule이란 코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n Module 사용 전 기존에는 html에  태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사…","fields":{"slug":"/module/"},"frontmatter":{"date":"November 21, 2021","title":"프론트엔드 개발환경 #2 - 모듈 (Module)","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## 🧐 모듈(Module) 이란?\r\n\r\nJavascript를 공부하다보면 `Module`이라는 단어를 자주 접하게 됩니다.\r\nModule이란 **코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음**을 말하는데\r\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\r\n<br />\r\n\r\n### Module 사용 전\r\n\r\n```html\r\n<script src=\"./src/main.js\">\r\n<script src=\"./src/animation.js\">\r\n<script src=\"./src/banner.js\">\r\n```\r\n\r\n기존에는 html에 `<script>` 태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사용했습니다. 이 방식은 파일을 불러오는 순서가 코드에 영향을 주며, 생성한 파일의 object가 모두 전역 변수가되서 문제가 발생할 수 있다는 단점이 있습니다\r\n<br />\r\n\r\n### Module 사용 후\r\n\r\n```html\r\n<script type=\"module\" src=\"./src/main.js\">\r\n```\r\n\r\n하지만 모듈을 사용하면 하나의 `<script>` 태그만으로 모든 모듈화된 javascript 파일에 접근이 가능해져 효율적으로 코드를 관리할 수 있습니다.\r\n\r\n---\r\n\r\n## ⛓️ 파일 모듈화 하기\r\n\r\nJavascript 파일을 모듈화 하는 방식은 크게 2가지로 나뉩니다. **CommonJS**로 모듈화 하는 것과 **ES Module**로 모듈화하는 것입니다.\r\n<br />\r\n\r\n### CommonJS로 파일 내보내기/불러오기\r\n\r\nCommonJS는 NodeJS의 기본 모듈 시스템이며 모듈화가 되지 않고 표준 라이브러리가 없는 과거 javascript의 문제를 해결하기 위한 모듈화 방식입니다.\r\n\r\n주 키워드 : `module.exports`, `exports`, `require`\r\n\r\n- 파일 불러오기 : `require`\r\n- 여러 개의 객체를 내보낼 경우, `exports` 변수의 속성으로 할당\r\n- 딱 하나의 객체를 내보낼 경우, `module.exports` 변수 자체에 할당\r\n\r\n```javascript\r\n// main.js\r\nconst name = \"Joy\"\r\nconst age = 28\r\n//exports.name = name\r\n//exports.age = age\r\nmodule.exports = { name, age }\r\n\r\n// result.js\r\nconst { name, age } = require(\"./main.js\")\r\n```\r\n\r\n### ES Module로 파일 내보내기/불러오기\r\n\r\nES Module은 가장 대중적으로 사용되는 모듈 시스템입니다. 비동기 방식으로 작동하고 모듈에서 실제로 쓰이는 부분만 불러오기 때문에 성능과 메모리 부분에서 유리한 측면이 있습니다. 또한 직관적인 키워드를 사용해 가독성이 뛰어나고 `Named Parameter`와 같은 CommonJS에서는 지원하지 않는 기능들이 있습니다.\r\n\r\n주 키워드 : `import`, `export`, `from`, `default`\r\n\r\n```javascript\r\n// main.js\r\nexport const name = \"Joy\"\r\nexport const age = 28\r\nexport default function fullName(lastName) {\r\n  return name + lastName\r\n}\r\n\r\n// result.js\r\nimport fullName, { name, age } from \"./main.js\"\r\n```\r\n"},{"excerpt":"✔ npm npm : Node Package Manager(Modules) npm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다. ex)   명령어를 사용해 초기  파일을 만들고 프로젝트…","fields":{"slug":"/npm-npx/"},"frontmatter":{"date":"November 17, 2021","title":"프론트엔드 개발환경 #1 - npm / npx / yarn","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✔ npm\r\n\r\n> npm : Node Package Manager(Modules)\r\n\r\nnpm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다.\r\n\r\nex) `npm install webpack`\r\n\r\n`npm init` 명령어를 사용해 초기 `package.json` 파일을 만들고 프로젝트를 초기화합니다. npm을 통해 다운된 패키지는 `package.json`에 기록됩니다.\r\n<br />\r\n\r\n### npm의 단점\r\n\r\n- 로컬 컴퓨터에 직접 설치되어 용량 차지가 크다\r\n- 다운받은 패키지의 새 버전이 나온 경우, 업데이트를 직접 해주어야한다.\r\n\r\n---\r\n\r\n## ✔ npx\r\n\r\n> npx : Node Package Runner\r\n\r\nnpx는 npm 5.2.0 버전부터 새로 도입된 패키지 관리 도구입니다. npm 5.2.0 버전 이상을 다운받았다면 자동으로 설치되며 이는 npm을 좀더 편리하게 사용할 수 있도록 도와줍니다.\r\n\r\nex) `npx install webpack`\r\n<br />\r\n\r\n### npx의 장점\r\n\r\n- 패키지를 컴퓨터에 직접 저장하지 않고 일회성으로 패키지를 사용해 용량차지를 하지 않는다.\r\n- 매번 최신 업데이트된 패키지를 사용할 수 있다.\r\n  <br />\r\n\r\n### npx 동작방법\r\n\r\n1. 기본적으로, 실행할 패키지가 실행 가능한 경로에 있는지 확인한다. (예를 들면, 프로젝트내에서 다운된 패키지가 있는지 확인)\r\n2. 만약에 있다면, 그것을 실행한다.\r\n3. 아니라면 패키지가 설치가 되지 않았다는 것으로 판단하여, npx가 가장 최신 버전의 패키지를 설치하고 실행한다.\r\n\r\n---\r\n\r\n## ✔ yarn\r\n\r\nyarn은 npm과 같은 패키지 매니저입니다. 차이점이 있다면 Node.js 설치시에 함께 설치되지 않고 별도의 명령어를 사용해 설치합니다. yarn을 사용하면 `yarn.lock` 이라는 파일에 다운한 패키지가 기록되며 이 파일은 모든 디바이스에 같은 패키지를 설치하는 것을 보장합니다.\r\n\r\nyarn 설치 : `npm install -g yarn`\r\n\r\n```bash\r\n# npm 사용법\r\nnpm install <package>\r\nnpm uninstall <package>\r\n\r\n# yarn 사용법\r\nyarn add <package>\r\nyarn remove <package>\r\n```\r\n\r\n### yarn의 장점\r\n\r\n- 속도나 안전성은 npm과 비슷하나 npm보다 보안이 뛰어나고 의존성 관리를 강조한다.\r\n- 버전을 어디에서나 같게 만들어 버전 충돌에 의한 버그가 적다.\r\n\r\n### yarn의 단점\r\n\r\n- npm에 비해 레퍼런스가 적고 덜 보편적이다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}
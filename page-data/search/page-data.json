{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"☝ 프로젝트 시작하기 전 이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다. no…","fields":{"slug":"/wanted-admin/"},"frontmatter":{"date":"January 31, 2022","title":"어드민 페이지 (이미지 첨부 기능 / useForm)","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\r\n## ☝ 프로젝트 시작하기 전\r\n\r\n이번 프로젝트는 e-Commerce 서비스에서 주로 사용하는 어드민 페이지를 제작하는 것으로 판매 상품을 등록할 수 있는 폼 양식이 포함된 상품 등록 페이지를 만들기로 했다. 팀원들과는 비슷한 옵션별로 역할을 분담한 후 작업했는데 반복 코드를 줄이기 위해 페이지 전체에서 공통으로 쓰이는 UI는 미리 컴포넌트로 만들어 두었다.\r\n\r\n![none](https://user-images.githubusercontent.com/68415905/154843327-bd704dff-8fd1-40fd-a59c-ad9473b74690.jpg)\r\n\r\n## 📌 프로젝트 링크\r\n\r\n[Github](https://github.com/devjoylee/admin-product-registry)\r\n[배포링크](https://wanted-admin-product.netlify.app/)\r\n\r\n## 🧾 상품 등록 페이지\r\n\r\n### 이미지 첨부 기능 `input▫type=\"file\"`\r\n\r\n상품 썸네일은 **최대 1개,** 상품 대표 이미지는 **여러개** 첨부 가능하도록 기능 구현.\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154844537-f04a2902-3194-478e-80b4-772e8f32539b.png)\r\n\r\n- 파일 업로드 버튼 custom 하기 : **input**의 `id`와 **label**의 `htmlFor`에 같은 id를 입력한 후 input은 `display:none` 해주고 `label` 스타일링.\r\n\r\n- 이미지 파일만 첨부 가능하게 : `accept=\"image/*\"` 또는 `accept=\"image/png\"`\r\n- 파일 중복 선택 `multiple`\r\n\r\n```jsx\r\n// ImageUpload.js\r\n<input\r\n  id={id}\r\n  type=\"file\"\r\n  accept=\"image/*\"\r\n  style={{ display: 'none' }}\r\n  multiple={!(id === 'thumbnail')}\r\n/>\r\n<label htmlFor={id}>\r\n  <RiAddLine />\r\n  이미지 첨부\r\n</label >\r\n```\r\n\r\n```jsx\r\n// Page.js\r\n<ImageUpload id=\"thumbnail\" />\r\n<ImageUpload id=\"main-img\" />\r\n\r\n```\r\n\r\n---\r\n\r\n### 업로드한 이미지 정보 가져오기 `e.target.files`\r\n\r\n- 이미지가 1개 인경우 `e.target.files[0]` 으로 첫번째 파일 정보를 바로 가져온다\r\n\r\n  ex) `e.target.files[0].name`\r\n\r\n![Untitled (1)](https://user-images.githubusercontent.com/68415905/154844914-ba2629f7-f07c-43f5-9dc3-6ed2b477bcd8.png)\r\n\r\n- 이미지가 여러개인 경우 `Array.from(e.target.files).map()` <br/>\r\n  `e.target.files` 로 불러온 객체 형식의 데이터를 배열로 바꾸어서 관리해준다.\r\n\r\n![Untitled (2)](https://user-images.githubusercontent.com/68415905/154844917-3640cfb1-63e8-4bc6-a679-a714aa0b575f.png)\r\n\r\n첨부한 이미지 데이터가 담긴 배열을 `map`으로 순회하며 이미지 파일명만 추출해서 새로운 state에 저장하고 화면에 출력하도록 설계했다.\r\n\r\n```jsx\r\n// ImageUpload.js\r\nconst [imageList, setImageList] = useState([])\r\nconst handleUpload = e => {\r\n  const uploadedImage = Array.from(e.target.files).map(file => file.name)\r\n  if (id === \"thumbnail\") {\r\n    setImageList(uploadedImage)\r\n  } else {\r\n    setImageList([...imageList, ...uploadedImage].reverse())\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 이미지 preview `URL.createObjectURL`\r\n\r\n`URL.createObjectURL`로 이미지 파일의 URL을 추출하고 img태그의 src로 넣어준다.\r\n\r\n```jsx\r\nconst [imgUrl, setImgUrl] = useState(\"\")\r\nconst getImageUrl = e => {\r\n  let file = e.target.files[0]\r\n  let url = URL.createObjectURL(file)\r\n  setImgUrl(url)\r\n}\r\n```\r\n\r\n```jsx\r\n<img src={imgUrl} alt=\"\" />\r\n```\r\n\r\n---\r\n\r\n## ♻ 프로젝트 리팩토링\r\n\r\n처음엔 필수옵션이 기입되지 않은 경우 '필수 값을 모두 입력하세요!' 라는 alert이 보여지도록 코드를 작성했다. 하지만 사용자의 입장에서 어떤 옵션이 비어있는지 구체적으로 알 수 있으면 좋을 것 같아 alert에서 비어있는 옵션명도 함께 알려주도록 리팩토링 해보기로 했다.\r\n\r\n먼저 validation이라는 유틸함수를 만들고 값이 전달되지 않는 필수 옵션명의 이름을 리턴하도록 작성했다. 그리고 코드의 가독성을 위해 useForm이라는 커스텀 hook을 만들었고 validation에서 리턴된 옵션명을 alert에 출력하는 함수를 리턴하도록 구현했다.\r\n\r\n![캡처](https://user-images.githubusercontent.com/68415905/154845357-06d08840-fb5d-455f-8aec-fe1331ce6d80.JPG)\r\n\r\n### validation.js\r\n\r\n```jsx\r\nexport const validation = required => {\r\n  const inVaild = Object.keys(required).filter(\r\n    key => !required[key] || required[key].length === 0\r\n  )\r\n\r\n  const inVaildList = inVaild.map(el => {\r\n    switch (el) {\r\n      case \"category\":\r\n        return \"카테고리\"\r\n      case \"productName\":\r\n        return \"상품명\"\r\n      case \"description\":\r\n        return \"상품 구성 소개 정보\"\r\n      case \"stock\":\r\n        return \"상품 총 재고\"\r\n      case \"option\":\r\n        return \"상품 옵션\"\r\n      default:\r\n        throw new Error(\"Unknown option type\")\r\n    }\r\n  })\r\n\r\n  return inVaildList\r\n}\r\n```\r\n\r\n### useForm.js\r\n\r\n```jsx\r\nexport const useForm = requiredList => {\r\n  const [required, setRequired] = useState(requiredList)\r\n  const addRequired = useCallback(\r\n    (name, value) => {\r\n      setRequired(prev => ({\r\n        ...prev,\r\n        [name]: value,\r\n      }))\r\n    },\r\n    [setRequired]\r\n  )\r\n\r\n  const handleClick = () => {\r\n    const inVaild = validation(required)\r\n    if (!inVaild.length) {\r\n      submitForm()\r\n    } else {\r\n      alert(\r\n        `필수 값을 모두 입력하세요 ❗❗\r\n👉 ${inVaild.join(\", \")}을(를) 추가해주세요!`\r\n      )\r\n    }\r\n  }\r\n\r\n  const submitForm = () => {\r\n    alert(\"상품이 등록 되었습니다 🎉🎉\")\r\n  }\r\n\r\n  return { addRequired, handleClick }\r\n}\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Stack Overflow https://stackoverflow.com/questions/60151566/display-file-name-for-custom-input-file-using-reactjs<br />[React] useForm 만들기 https://velog.io/@junghyeonsu/React-useForm\r\n"},{"excerpt":"☝ 프로젝트 시작하기 전 프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다. 본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다. 프로젝트 폴더 구조는 어떻게 만들까? 커…","fields":{"slug":"/wanted-currency/"},"frontmatter":{"date":"January 28, 2022","title":"환율 계산기(Currency Converter) 만들기","tags":["wanted","javascript","react","netlify"]},"rawMarkdownBody":"\r\n## ☝ 프로젝트 시작하기 전\r\n\r\n프리온보딩 첫번째 과제가 발표되었다! 첫번째 과제는 4명의 팀원 중 2명씩 짝을 이루어 기능이 다른 환율계산기를 1개씩 구현하는 것이었다. 배정된 짝과 논의 해서 탭기능이 추가된 환율계산기를 만들기로 결정했다.\r\n\r\n본격적으로 프로젝트를 시작하기 전에 협업에 필요한 규칙을 몇가지 정하기로 했다.\r\n\r\n- 프로젝트 폴더 구조는 어떻게 만들까?\r\n- 커밋은 어떤 방식을 사용할 것인가?\r\n- 네임 컨벤션은 어떻게 따를 것인가? (컴포넌트이름, branch이름, 상수처리 등 )\r\n- CSS는 어떤 툴을 사용할 것인가? (Styled Component, SASS, CSS Modules 등)\r\n\r\n크게 4가지 주제로 팀원들과 협업규칙을 정했고 Docs로 정리해두었다. [👉 Docs 보러가기](https://www.notion.so/50aee26d48df4e0baf7ac3f8203c7f08)\r\n\r\n## 📌 프로젝트 링크\r\n\r\n[Github](https://github.com/devjoylee/currency-converter)\r\n[배포링크](https://currency-converter-w.netlify.app/)\r\n\r\n## 📲 환율 계산기 만들기\r\n\r\n환율 정보는 제공된 API(https://currencylayer.com/)에서 실시간 환율 데이터를 `fetch`해서 사용했다. 계산기에 값을 입력하고 화폐단위를 선택하면 해당 환율을 출력하도록 로직을 설계했다.\r\n\r\n### 입력값 상태 저장\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154837797-6f5b9bb5-eebb-4a9f-9b4f-8fc47bc9c815.png)\r\n\r\n먼저 입력값은 2가지로 나뉜다.\r\n\r\n1. **input으로 입력한 금액**\r\n\r\n2. **select 박스로 선택한 화폐단위**\r\n\r\n```jsx\r\nconst [inputValue, setInputValue] = useState(\"\")\r\nconst [currency, setCurrency] = useState(\"USD\")\r\n```\r\n\r\n각각 다른 state를 만들어 입력 값을 관리하도록 하였고 input의 입력값에는 10자리 이하 숫자만 입력되도록 하기위해 입력값 length가 10을 넘는 경우 return 시켰다. 그리고 `toLocaleString` 을 사용해 숫자 3자리마다 콤마(,)가 자동으로 보이도록 만들었다. ex) 1,000,000\r\n\r\n```jsx\r\n// input에 값이 입력될 때\r\nconst handleType = e => {\r\n  const pureString = e.target.value.split(\",\").join(\"\")\r\n  if (isNaN(Number(pureString))) return\r\n  if (pureString.length > 10) return\r\n  if (Number(pureString) >= 1000) {\r\n    setInputValue(Number(pureString).toLocaleString())\r\n  } else {\r\n    setInputValue(pureString)\r\n  }\r\n}\r\n// select box 값이 선택될 때\r\nconst handleChange = e => {\r\n  setCurrency(e.target.value)\r\n  setInputValue(\"\")\r\n}\r\n```\r\n\r\n### 탭 기능 구현\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154838315-42884797-688c-43c6-aab6-bc06f9b33f2a.JPG)\r\n\r\n위 select 박스에서 선택된 단위는 아래 탭박스에 나타나지 않도록 하기위해 전체 화폐단위 값을 가져와서 `filter`로 select 박스에 선택된 값을 제외하고 탭을 다시 정렬하도록 구현했다. 활성화된 탭은 border-bottom값을 none으로 해주었다.\r\n\r\n```jsx\r\nconst [tabs, setTabs] = useState(TAB_CURRENCY)\r\nconst [currentTab, setCurrentTab] = useState(\"\")\r\n\r\nconst handleClick = e => {\r\n  setCurrentTab(e.target.innerHTML)\r\n} // 탭 클릭 시 현재 탭 상태 업데이트\r\n\r\nuseEffect(() => {\r\n  const handleTab = () => {\r\n    let changedTabs = TAB_CURRENCY.filter(tab => tab !== currency)\r\n    setTabs(changedTabs)\r\n    setCurrentTab(changedTabs[0])\r\n  }\r\n  handleTab()\r\n}, [currency, setCurrentTab])\r\n```\r\n\r\n### 실시간 날짜 & 환율 계산\r\n\r\n![Untitled](https://user-images.githubusercontent.com/68415905/154838566-6341a0f4-bad8-4f66-b706-f6accb9e7488.jpg)\r\n\r\n데이터를 성공적으로 받아오면, `DateConverter`와 `CurrencyCalculator`로 실시간 환율을 계산한다. 환율 계산할 때는, 콤마(,)때문에 string으로 변한 value값을 다시 number로 바꾸어 준다. ex) “1,000” → 1000\r\n\r\n- 날짜 계산 (dateConverter.js)\r\n\r\n```jsx\r\nexport const DateConverter = timestamp => {\r\n  const time = new Date(timestamp * 1000)\r\n  const year = time.getFullYear()\r\n  const month = time.toLocaleString(\"en\", { month: \"short\" })\r\n  const date = time.getDate()\r\n  return `${year}-${month}-${date}`\r\n}\r\n```\r\n\r\n- 환율 계산 (currencyCalculator.js)\r\n\r\n```jsx\r\nconst CurrencyCalculator = (target, base, money) => {\r\n  let targetRate = apiData.quotes[`USD${target}`]\r\n  let baseRate = apiData.quotes[`USD${base}`]\r\n  let exchangeRate = Number((targetRate / baseRate) * money)\r\n  return exchangeRate.toLocaleString(\"en\", {\r\n    maximumFractionDigits: 2,\r\n  })\r\n}\r\n```\r\n\r\n## ♻ 프로젝트 리팩토링\r\n\r\n### API 상수화\r\n\r\n처음에는 API key, 화폐정보 등이 모두 포함된 API를 통째로 string으로 써서 data를 불러왔는데 화폐정보가 바뀔때 API를 수정해야한다는 불편함이 생겨 좀더 편리한 구조로 API 주소를 바꾸었다.\r\n\r\n- **리팩토링 전**\r\n\r\n```jsx\r\n// constants.js\r\nexport const API_ENDPOINT =\r\n  \"http://api.currencylayer.com/live?access_key=7cceb7113b3a6f9436614acd65e70c26&format=1\"\r\n\r\n// converter.jsx\r\nfetch(API_ENDPOINT)\r\n```\r\n\r\n- **리팩토링 후**\r\n\r\n```jsx\r\n// constants.js\r\nconst KEY = \"7cceb7113b3a6f9436614acd65e70c26\"\r\nexport const SELECT_CURRENCY = [\"KRW\", \"JPY\", \"PHP\"]\r\nexport const TAB_CURRENCY = [\"USD\", \"KRW\", \"JPY\", \"CAD\", \"HKD\", \"CNY\"]\r\nexport const API_ENDPOINT = currencies =>\r\n  `http://api.currencylayer.com/live?access_key=${KEY}&currencies=${currencies}&format=1`\r\n\r\n// converter.jsx\r\nfetch(API_ENDPOINT(TAB_CURRENCY.join(\",\")))\r\n```\r\n\r\n### API fetch 실패 시 로딩화면 추가\r\n\r\n처음에는 사용자가 입력창에 값을 입력하기 전 까지는 fetch 성공여부를 알 수 없었다. (fetch 실패 시 계산 안됨). 그래서 fetch가 실패한 경우 로딩이 실패했다는 UI를 보여줌으로써 사용자가 입력창에 입력을 해서 확인해보는 불필요한 작업을 최소화시켰다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/68415905/154838974-eb069e65-bbf1-4dbc-8794-2560ec8ac318.JPG\" width=\"450\" />\r\n\r\n### Netlify 배포 오류\r\n\r\n![error](https://user-images.githubusercontent.com/68415905/154839736-666c1574-4817-4461-9789-6d8edcf6bbda.jpg)\r\n프로젝트가 끝난 후, Netlify로 배포를 하려는데 `Mixed Content`라는 HTTP 관련 이슈가 생겨 배포가 안되는 문제가 발생했다. 알아본 결과 최신 브라우저에서는 `https` 페이지에서 `http` 리소스를 요청할 수 없다는 것을 알게되었다. 로컬에서는 API 사용이 가능했던 이유는 리액트 개발 서버는 http도 사용하기 때문이라고 했다.\r\n\r\n그래서 차선책으로 HTTP 업로드가 가능한 AWS를 통해 배포를 하기로 결정했다.\r\n[AWS 링크](http://beefplz.s3-website.ap-northeast-2.amazonaws.com/)\r\n\r\n하지만 AWS는 Netlify처럼 자동으로 업데이트되지 않고 배포한 사람이 매번 직접 빌드를 해야한다는 단점이 있었다. 그래서 Netlify에서 앞서 발생한 이슈를 해결할 수 있는 방법이 있을까 찾아보다가 public 위치에 `_redirects`라는 파일을 만들면 된다는 글을 보게되었다!\r\n\r\n```bash\r\n// _redirects\r\n/api/* http://api.currencylayer.com/:splat 200\r\n```\r\n\r\n```jsx\r\nfetch(`http://api.currencylayer.com/live?access_key=${KEY}`)\r\n👇\r\nfetch(`/api/live?access_key=${KEY}`)\r\n```\r\n\r\n`_redirects`에 HTTP 주소를 추가한 후, fetch 경로를 위처럼 수정하니 HTTP 이슈 없이 Netlify 배포에 성공했다! 🎉\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Netlify 공식문서 https://www.netlify.com/blog/2021/12/13/setting-up-redirects-on-netlify/\r\n"},{"excerpt":"✨ useEffect 정의 첫 렌더링 할 때(mount), 다시 렌더링될 때(update), 화면에서 사라질 때(unmount), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다.  를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다. 렌더링될 때마다 실행 - De…","fields":{"slug":"/react-hook-useEffect/"},"frontmatter":{"date":"December 26, 2021","title":"[React] React Hook - useEffect","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useEffect 정의\r\n\r\n첫 렌더링 할 때(**mount**), 다시 렌더링될 때(**update**), 화면에서 사라질 때(**unmount**), 특정한 작업을 수행하고 싶은 경우 사용하는 Hook입니다. `useEffect` 를 사용 할 때에는 첫번째 인자에는 함수, 두번째 인자로는 의존값이 들어있는 배열 Dependency Array(deps)를 넣습니다.\r\n\r\n- 렌더링될 때마다 실행 - Dependency array ❌\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code...\r\n})\r\n```\r\n\r\n- 첫 렌더링될 때(mount)만 실행 - Dependency array 빈 배열\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n}, [])\r\n```\r\n\r\n- 첫 렌더링 될때 + 특정 `state`**가 바뀔 때** 실행 - Dependency array에 `state` 전달\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n}, [value])\r\n```\r\n\r\n- 컴포넌트 unmount 시 실행 - `return` 추가\r\n\r\n```jsx\r\nuseEffect(() => {\r\n  // code ...\r\n  return () => {\r\n    // clean up!!\r\n  }\r\n}, [])\r\n```\r\n\r\n## 🤔 useEffect 언제 사용할까?\r\n\r\n### 마운트할 때 필요한 작업\r\n\r\n- props 로 받은 값을 컴포넌트의 로컬 상태로 설정\r\n- 외부 API 요청 (REST API 등)\r\n- 라이브러리 사용 (D3, Video.js 등...)\r\n- setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약\r\n\r\n### 언마운트할 때 필요한 작업\r\n\r\n- setInterval, setTimeout 을 사용하여 등록한 작업들 clear 하기<br/>\r\n  (clearInterval, clearTimeout)\r\n- 라이브러리 인스턴스 제거\r\n\r\n## 🔎 useEffect 제대로 사용하기\r\n\r\n### Dependency Array\r\n\r\n해당 컴포넌트에 state가 여러개 있는 경우, state가 호출될 때 다른 state값도 다같이 렌더링 된다. 이때 useEffect를 사용해 dependency array에 호출하고자 하는 state값을 전달해주면 다른 불필요한 state 렌더링을 막을 수 있다.\r\n\r\n```jsx\r\nconst [count, setCount] = useState(1)\r\nconst [name, setName] = useState(\"\")\r\n\r\n// count만 렌더링!  name은 사용 x\r\nuseEffect(() => {\r\n  console.log(\"count 렌더링\")\r\n}, [count])\r\n\r\n// name만 렌더링! count은 사용 x\r\nuseEffect(() => {\r\n  console.log(\"name 렌더링\")\r\n}, [name])\r\n```\r\n\r\n### return\r\n\r\n`useEffect` 에서는 함수를 return 할 수 있는데 이때 반환되는 함수를 **cleanup 함수**라고 부릅니다. cleanup 함수는 useEffect 에 대한 뒷정리를 해준다고 이해하시면 되는데요, deps 가 비어있는 경우에는 컴포넌트가 사라질 때 cleanup 함수가 호출됩니다.\r\n\r\n**_timer.js_**\r\n\r\n```jsx\r\nimport React, {useEffect} from 'react';\r\n\r\nconst Timer = () => {\r\n\tuseEffect(()=> {\r\n\t\t// 컴포넌트가 mount 될 때 실행\r\n\t\tconst timer = setInterval(() => {\r\n\t\t\tconsole.log('타이머 실행 중....');\r\n\t\t}, 1000);\r\n\r\n\t\t// 컴포넌트가 unmount 될 때 실행\r\n\t\treturn () => {\r\n\t\t\tclearInterval(timer);\r\n\t\t\tconsole.log('타이머 종료!');\r\n\t\t}\r\n}, []);\r\nreturn (\r\n\t<div>타이머를 시작합니다.</div>\r\n)\r\nexport default Timer;\r\n```\r\n\r\n**_App.js_**\r\n\r\n```jsx\r\nimport React, { useState } from \"react\"\r\nimport Timer from \"./Timer\"\r\n\r\nfunction App() {\r\n  const [showTimer, setShowTimer] = useState(false)\r\n  return (\r\n    <div>\r\n      {showTimer && <Timer />}\r\n      <button onClick={() => setShowTimer(!showTimer)}>Toggle</button>\r\n    </div>\r\n  )\r\n}\r\nexport default App\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/16-useEffect.html<br/>Youtube 별코딩 https://youtu.be/kyodvzc5GHU\r\n"},{"excerpt":"✨ useState 정의 상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.  : 상태 값 저장 변수 (현재 상태 값)  : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수) 💡 useState…","fields":{"slug":"/react-hook-useState/"},"frontmatter":{"date":"December 23, 2021","title":"[React] React Hook - useState","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## ✨ useState 정의\r\n\r\n상태 관리에 사용되는 Hook이며 상태값을 생성하고 업데이트 시킬 수 있습니다. useState를 호출 하면 state값이 저장되는 '변수'와 state값을 변화시키는 '함수'가 배열로 리턴됩니다.\r\n\r\n```jsx\r\nconst [state, setState] = useState(<상태 초기 값>);\r\n```\r\n\r\n- `state` : 상태 값 저장 변수 (현재 상태 값)\r\n- `setState` : 상태 값 갱신 함수 (state를 업데이트하는 setter 함수)\r\n\r\n## 💡 useState 예시\r\n\r\n### Counter 만들기\r\n\r\n초기값을 1로 설정 후, 버튼 클릭할 때마다 상태값(`count`)이 +1씩 업데이트 됩니다.\r\n\r\n```jsx\r\n// count.js\r\nimport { useState } from \"react\"\r\n\r\nfunction Count() {\r\n  const [count, setCount] = useState(1) // 초기값이 1인 count(state) 생성\r\n  const handleClick = () => {\r\n    setCount(count + 1) // 클릭 이벤트 발생 시, count = count + 1\r\n  }\r\n  return (\r\n    <div>\r\n      <span>클릭 횟수 : {count}</span>\r\n      <button onClick={handleClick}>Update</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n## 🔎 useState 제대로 사용하기\r\n\r\n### state가 배열 or 객체일 때?\r\n\r\n`setState` 함수로 `state`의 상태를 업데이트할 때는, **콜백함수** 내부에서 스프레드 연산자(`...`)로 이전 상태값을 가져온 뒤 현재 입력값을 추가하여 덮어쓰는 방식으로 사용한다.\r\n\r\n```jsx\r\nconst updateArray = () => {\r\n  setNames(prevState => [newName, ...prevState])\r\n}\r\n```\r\n\r\n```jsx\r\nconst updateObject = () => {\r\n  const name = \"joy\"\r\n  const job = \"developer\"\r\n  setJobs(prevState => ({\r\n    ...prevState,\r\n    [name]: job,\r\n  }))\r\n}\r\n```\r\n\r\n### useState 최적화\r\n\r\nuseState가 호출되면 컴포넌트가 다시 렌더링된다. state 초기값을 호출하는 루트가 복잡한 경우 컴포넌트가 렌더링될 때마다 다시 실행되서 성능이 떨어지게된다. 이때, useState 내부에 **콜백함수**를 만들어 초기값을 선언하면 첫 렌더링 때만 불러오므로 불필요한 메모리 소비를 막을 수 있다.\r\n\r\n**_input.js_**\r\n\r\n```jsx\r\nimport {useState} from 'react';\r\n\r\nconst heavyWork = () => {\r\n\tconsole.log('엄청 무거운 작업!!')\r\n\treturn ['Joy', 'Hana']\r\n}\r\n\r\nfunction Input() {\r\n\tconst [names, setNames] = useState(() => {\r\n\t\treturn heavyWork(); // callback으로 초기값 선언\r\n\t});\r\n\tconst [input, setInput] = useState('');\r\n\r\n\tconst handleChange = (e) => {\r\n\t\tsetInput(e.target.value);\r\n\t}\r\n\tconst handleUpload =() => {\r\n\t\tsetNames((prev) => {\r\n\t\t\treturn([input, ...prev];\r\n\t\t});\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<input type=\"text\" value={input} onChnage={handleChange} />\r\n\t\t\t<button onClick={handleUpload}>Upload</button>\r\n\t\t\t{names.map((name,i) => {\r\n\t\t\t\treturn <p key={i}>{name}</p>\r\n\t\t\t})}\r\n\t\t</div>\r\n\t);\r\n}\r\n```\r\n\r\n> REFERENCE<br />Velopert React https://react.vlpt.us/basic/07-useState.html<br/>Youtube 별코딩 https://youtu.be/G3qglTF-fFI\r\n"},{"excerpt":"🌟 Hook의 등장 배경 리액트 컴포넌트 종류 : Class Component / Functional Component Hook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없…","fields":{"slug":"/react-hook-about/"},"frontmatter":{"date":"December 22, 2021","title":"[React] React Hook이란?","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🌟 Hook의 등장 배경\r\n\r\n리액트 컴포넌트 종류 : **Class Component** / **Functional Component**\r\n\r\nHook이 등장하기 전 리액트에는 여러 문제들이 있었습니다. Class Component는 Functional Component에 비해 문법이 어렵고 로직의 재사용이 힘든 단점이 있으나 Functional Component로는 할 수 없었던 state관리나 Life Cycle Method가 가능하다는 이유로 어쩔 수 없이 Class Component를 사용해왔습니다.\r\n\r\nHook이 등장하기 전의 리액트는\r\n\r\n- 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어려웠습니다.\r\n\r\n- 생명주기 컴포넌트로 인한 복잡한 컴포넌트는 이해하기 어려웠습니다. 상태관련 로직이 모두 같은 공간에 위치하기 때문입니다.\r\n\r\n## 🧐 Hook 이란?\r\n\r\nHook은 리액트 16.8 버전 이후 함수형 컴포넌트에 추가된 기능입니다. 즉, React Hook은 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할 수 있도록 해주는 기능이며 Hook이 등장하면서 더 이상 상태를 관리하기 위해 Class Component를 쓸 필요가 없어졌습니다.\r\n\r\n기존에는 Class Component 에서만 상태를 관리 할 수 있었고, 함수형 컴포넌트에서는 상태를 관리할 수 없었습니다. 하지만 Hook이 등장하면서 함수형 컴포넌트 에서도 상태 관리를 할 수 있게 되었고, 상태 관리 뿐만 아니라 기존 클래스형 컴포넌트에서만 가능하던 여러 기능을 사용할 수 있게 되었습니다.\r\n\r\n👉 [React Hook 공식문서 바로가기](https://reactjs.org/docs/hooks-intro.html)\r\n\r\n## 🧾 Hook의 종류\r\n\r\n### useState\r\n\r\n가장 대표적인 Hook으로 상태값을 생성 및 업데이트시켜주는 Hook입니다.\r\n\r\n👉 [useState 더 알아보기](https://devjoylee.github.io/react-hook-useState)\r\n\r\n### useEffect\r\n\r\n컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정하는 Hook입니다.\r\n\r\n👉 [useEffect 더 알아보기](https://devjoylee.github.io/react-hook-useEffect)\r\n\r\n### useReducer\r\n\r\nuseState처럼 상태관리에 쓰이며 구조가 복잡한 상태관리에 적합한 Hook입니다.\r\n\r\n👉 [useReducer 더 알아보기](https://devjoylee.github.io/react-hook-useReducer)\r\n\r\n### useRef\r\n\r\n렌더링과 관련없는 값을 관리하거나 DOM에 접근이 필요한 경우 사용하는 Hook입니다.\r\n\r\n👉 [useRef 더 알아보기](https://devjoylee.github.io/react-hook-useRef)\r\n\r\n### useMemo\r\n\r\n렌더링 시 메모리에 값을 저장해두고 필요할 때 불러와서 사용할 수 있도록 하는 Hook입니다.\r\n\r\n👉 [useMemo 더 알아보기](https://devjoylee.github.io/react-hook-useMemo)\r\n\r\n### useCallback\r\n\r\nuseMemo와 비슷하나 값이 아닌 함수를 재사용하고자 할 때 사용하는 Hook입니다.\r\n\r\n👉 [useCallback 더 알아보기](https://devjoylee.github.io/react-hook-useCallback)\r\n\r\n### useContext\r\n\r\n전역적으로 사용되는 state나 데이터를 필요한 컴포넌트에 전달하는 Hook입니다.\r\n\r\n👉 [useContext 더 알아보기](https://devjoylee.github.io/react-hook-useContext)\r\n\r\n<br />\r\n\r\n> REFERENCE<br /> React(23) 리액트 훅이란? https://devbirdfeet.tistory.com/52<br />리액트 공식 문서 https://reactjs.org/docs/hooks-intro.html<br/>[React] Hooks의 종류 https://lelana.tistory.com/146\r\n"},{"excerpt":"리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. () 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다! 리액트 시작하기 (CRA ❌) 1. 프…","fields":{"slug":"/react-scratch/"},"frontmatter":{"date":"December 21, 2021","title":"[React] 리액트 시작하기 (without CRA)","tags":["frontend","react"]},"rawMarkdownBody":"\r\n리액트 기반의 프로젝트를 시작할 때 npm으로 create-react-app 패키지를 설치하면 손쉽게 리액트 프로젝트 빌드가 가능합니다. (`npx create-react-app \"project-name\"`) 하지만 리액트 폴더구조와 빌드 시스템에 대해 자세히 알아보고 싶다면 create-react-app을 사용하지 않고 아래 순서에 따라 직접 리액트를 빌드해보는 것을 추천합니다!\r\n\r\n## 리액트 시작하기 (CRA ❌)\r\n\r\n### 1. 프로젝트 폴더 생성 후 초기화\r\n\r\n원하는 경로에 프로젝트 폴더를 생성하고 프로젝트 초기화(`npm init -y`)를 진행합니다. 이때 `package.json`이라는 파일이 자동으로 생성되는데 이곳에 프로젝트 이름, 실행 명령어, 프로젝트에 필요한 라이브러리 등 관련 정보가 저장됩니다.\r\n\r\n```bash\r\nnpm init -y\r\n```\r\n\r\n### 2. 리액트 라이브러리 설치\r\n\r\n초기화가 끝나면 리액트 프로젝트에 필요한 패키지를 다운받습니다. 패키지 설치 방법은 아래와 같이 `npm install` 또는 `npm install --save-dev` 2가지 방식으로 가능합니다.\r\n\r\n✅ `npm i <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 해당 패키지 사용\r\n\r\n- package.json의 dependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i react react-dom\r\n```\r\n\r\n✅ `npm i --save-dev (or -D) <패키지 이름>`\r\n\r\n- 배포(production mode) 할 때 패키지 사용 ❌ (development mode에서만 사용)\r\n\r\n- package.json의 devDependencies 항목에 저장됨\r\n\r\n```bash\r\nnpm i -D @babel/core @babel/preset-env @babel/preset-react\r\nbabel-loader css-loader style-loader url-loader\r\nwebpack webpack-cli webpack-dev-server\r\nhtml-webpack-plugin\r\n```\r\n\r\n패키지 다운로드가 끝나면 프로젝트 폴더내부에 `node_modules` 폴더와 `package.lock.json` 파일이 새로 생성되고 (_yarn으로 설치한 경우_ `yarn.lock` _파일 생성_) `package.json`파일 내부에 아래와 같이 dependencies가 추가됩니다.\r\n\r\n![image](https://user-images.githubusercontent.com/68415905/154797755-7080fda7-541e-4ebf-a553-caa0ca4c79cc.png)\r\n\r\n### 3. `.babelrc` 파일 생성\r\n\r\n`babel` 이란 모든 브라우저에 호환이 가능하도록 최신 코드(ES6)를 구버전 코드(ES5)로 변환해주는 도구입니다. babel 설정을 위해서는 `.babelrc` 파일을 만들어 브라우저 호환에 필요한 babel 플러그인을 추가합니다. (preset : 필요한 플러그인 묶음)\r\n\r\n```bash\r\n// .babelrc\r\n{\r\n  presets: ['@babel/preset-env', '@babel/preset-react'],\r\n}\r\n```\r\n\r\n+) **webpack.config.js 파일 내부의 babel-loader의 옵션으로 추가한 경우 .babelrc 파일 생략 가능!!**\r\n\r\n### 4 . `webpack.config.js` 파일 생성\r\n\r\n`webpack`은 웹에서 사용되는 모든 자원(assets)을 묶음으로 번들링 해주는 도구입니다.\r\n\r\n웹팩을 사용하면 js 파일간의 종속성 뿐만 아니라 js 내에서 필요한 css나 img와 같은 파일(.css, .jpg)도 번들링해서 하나의 파일로 합쳐줘서 네트워크 요청을 최소화 시킬 수 있습니다.\r\n\r\n웹팩에 대해 자세히 알아보고 싶다면 링크를 참고해주세요!\r\n👉 [웹팩 포스팅 바로가기 ](https://devjoylee.github.io/dev-webpack-1)\r\n\r\n```jsx\r\n// webpack.config.js\r\nconst path = require(\"path\")\r\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: \"development\",\r\n  entry: \"./src/index.js\",\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"bundle.js\",\r\n    clean: true,\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx)$/,\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: \"babel-loader\",\r\n          options: {\r\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\r\n          },\r\n        },\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\"style-loader\", \"css-loader\"],\r\n      },\r\n      {\r\n        test: /\\.(jpg|png)$/i,\r\n        loader: \"url-loader\",\r\n        options: {\r\n          outputPath: \"images\",\r\n        },\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".js\", \".jsx\"],\r\n  },\r\n  devServer: {\r\n    static: path.join(__dirname, \"dist\"),\r\n    host: \"localhost\",\r\n    port: 3000,\r\n    open: true,\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: \"./public/index.html\",\r\n      inject: false,\r\n    }),\r\n  ],\r\n}\r\n```\r\n"},{"excerpt":"🧐 React란? React는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다. 다운로드 ✨ React의 필요성 사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 …","fields":{"slug":"/react-about/"},"frontmatter":{"date":"December 20, 2021","title":"[React] 리액트의 개념과 특징","tags":["frontend","react"]},"rawMarkdownBody":"\r\n## 🧐 React란?\r\n\r\nReact는 페이스북에서 개발한 Javascript 기반의 라이브러리로써 사용자와의 인터렉션을 UI로 쉽게 구현할 수 있도록 만들어 졌습니다.\r\n\r\n![다운로드](https://user-images.githubusercontent.com/68415905/154801618-9bf1d698-3467-4f54-9df4-ebafce5b1e38.png)\r\n\r\n## ✨ React의 필요성\r\n\r\n사용자 요청에 의한 UI 변화가 거의 없는 정적인 페이지는 React 라이브러리를 사용하지 않고도 개발이 가능합니다. 하지만 웹 애플리케이션이라 불릴 만큼 규모가 크고 UI 변화가 잦은 동적인 페이지라면 상태 변화 관리를 최소화 하고 DOM의 직접적인 업데이트를 막아주는 React 혹은 다른 프레임워크를 사용하는 것이 바람직합니다.\r\n\r\n## 🧾 React의 특징\r\n\r\n### 1. 단방향 데이터플로우\r\n\r\nReact는 데이터가 한방향으로만 이동하는 **단방향 데이터플로우**를 가집니다. 데이터가 UI로 이동하고 데이터가 변하면 UI도 함께 업데이트 되지만 반대로 UI쪽에서 데이터를 변화시키는 것은 불가능합니다. 단방향 데이터플로우를 사용하면 데이터 흐름이 간단해서 추적이 쉽고 예측이 가능해 유지보수가 편리하다는 장점이 있습니다.\r\n\r\n> ↔ 양방향 데이터 플로우 : 앵귤러(Angular.js) / 뷰(Vue.js)\r\n\r\n### 2. 가상돔(Virtual DOM)\r\n\r\nVirtual DOM이란 가상의 Document Object Model을 말합니다. 기존에는 javascript에서 DOM에 직접 접근하여 변화를 주는 방식을 사용하였는데 이경우 HTML,CSS,JS파일이 다시 리렌더링 되어 브라우저 내부에서 성능이슈가 발생했습니다.\r\n\r\nReact는 이런 단점을 보완하기 위해 Virtual DOM 이라는 것을 따로 만들었고 실제 DOM과 가상의 DOM을 비교하여 변화된 부분만 빠르게 업데이트 하는 방식을 사용하고 있습니다.\r\n\r\n**🔀 Virtual DOM 렌더링 순서**\r\n\r\n> JSX 수정 ➡ 가상 DOM 업데이트 ➡ 가상 DOM이 업데이트 되기 전과 비교하여 어떤 요소가 변경되었는지 확인 ➡ 가상 DOM에서 변경된 요소만 실제 DOM에서 업데이트\r\n\r\n### 3. Component 구조\r\n\r\n컴포넌트란 UI를 구성하는 개별 단위입니다. UI가 레고라면 컴포넌트는 하나의 블럭으로써 블럭을 쌓아 레고를 완성시키는 것처럼 컴포넌트를 조합하여 하나의 UI(페이지)를 만들 수 있습니다. 컴포넌트는 재사용이 가능하여 코드의 중복을 줄일 수 있고 효율적으로 유지보수를 할 수 있습니다.\r\n\r\n```js\r\nconst MainPage = () => {\r\n  return (\r\n    <Container>\r\n      <Header />\r\n      <MainContent>\r\n        <Section title=\"about\" />\r\n        <Section title=\"portfolio\" />\r\n      </MainContent>\r\n      <Footer />\r\n    </Container>\r\n  )\r\n}\r\n```\r\n\r\n### 4. JSX 문법\r\n\r\nJSX(Javascript + xml)는 Javascript에 대한 확장 구문으로서, Javascript를 좀더 편리하게 사용할 수 있도록 하는 Syntax Sugar 역할을 합니다. 이는 함수를 호출하거나 객체를 만들때 문법적인 편의를 제공하며 특히 DOM 요소를 만들 떄 `React.createElement()` 호출을 반복해야 하는 불편을 줄여줍니다. JSX는 React 엘리먼트를 생성하면서 자바스크립트의 모든 기능을 쓸 수 있도록 도와줍니다.\r\n\r\nJSX로 작성된 코드는 렌더링 시 Babel에 의해 자동으로 Javascript 코드로 컴파일됩니다.\r\n\r\n```jsx\r\n// jsx\r\n<MyButton color=\"blue\" shadowSize={2}>\r\n  Click Me\r\n</MyButton>\r\n```\r\n\r\n```jsx\r\n// javascript\r\nReact.createElement(\r\n  MyButton,\r\n  { color: \"blue\", shadowSize: 2 },\r\n  \"Click Me\"\r\n  //\r\n)\r\n```\r\n\r\n<br />\r\n\r\n> REFERENCE<br/>React란 무엇인가 https://firework-ham.tistory.com/5<br/>React란? https://velog.io/@jini_eun/React-React.js%EB%9E%80-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC\r\n"},{"excerpt":"✨ Webpack 등장 배경 이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게  을  태그에 추가하면 하나의  태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화) 👉 이전 포스팅 바로가기  image 하지만 안타깝게도 이런 모듈 시스템을 지원하는 브…","fields":{"slug":"/dev-webpack-1/"},"frontmatter":{"date":"November 29, 2021","title":"프론트엔드 개발환경 #3 - webpack이란?","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✨ Webpack 등장 배경\r\n\r\n이전 module 포스팅에서 javascript파일이 여러개로 나뉜 경우 간단하게 `type=\"module\"` 을 `script` 태그에 추가하면 하나의 `script` 태그만으로도 모든 javascript를 연결할 수 있다고 설명한 바 있습니다. (CommonJS / ES Module 모듈화)\r\n\r\n👉 [이전 포스팅 바로가기 ](https://devjoylee.github.io/dev-module)\r\n\r\n![image](https://images.velog.io/images/joyact/post/dfabe050-6ecc-4706-9e40-208164cb5621/image.png)\r\n\r\n하지만 안타깝게도 이런 모듈 시스템을 지원하는 브라우저는 한정되어 있습니다. 인터넷 익스플로러를 포함한 몇 브라우저는 여전히 모듈 시스템을 사용하지 않고있습니다. 따라서 모든 브라우저에 호환가능한 모듈링 시스템이 필요했고 이때 등장한 것이 **Webpack** 입니다.\r\n\r\n---\r\n\r\n## 🧐 Webpack이란?\r\n\r\n> Webpack : a module bundler\r\n\r\n![image](https://images.velog.io/images/joyact/post/d47c7828-ea1a-4844-bf88-d950f185899c/image.png)\r\n\r\n**웹팩(Webpack)**은 여러개 파일을 하나의 파일로 합쳐주는 번들러(bundler)입니다. 웹팩을 사용하면 여러개의 javascript 파일을 하나로 합쳐줌으로써 지저분한 `<script>` 태그의 반복 사용을 줄일 수 있고 효율적인 디버깅이 가능해집니다.\r\n\r\n또 다른 웹팩의 기능으로는 변환(transforming) 기능이 있습니다. ES6와 같은 모던 javascript를 ES5 형식으로 변환하고, Sass를 CSS로 변환시킴으로써 모든 브라우저가 이해할 수 있는 환경을 자체적으로 만들어냅니다.\r\n\r\n---\r\n\r\n## ➕ Webpack 설치\r\n\r\n1. npm install\r\n   `npm install webpack webpack-cli --save-dev`\r\n\r\n2. webpack.config.js 파일 생성\r\n   `module.exports` 내부에 필요한 configuration 옵션을 추가합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {}\r\n```\r\n\r\n---\r\n\r\n## 🚀 Webpack의 기능\r\n\r\n![image](https://images.velog.io/images/joyact/post/835b56bd-c22f-4fdf-b49f-57559b59a90d/Full-Stack-Introduction-to-Webpack.docx-2.jpg)\r\n\r\n모듈을 번들링하기 전, Webpack은 모듈 파일들을 그래프의 형식으로 인덱싱을 하게됩니다. 이를 **Dependency Graph**라고 하며 쉽게 말해 비슷한 형태의 파일을 하나로 묶기위해 분류하는 작업이라고 볼 수 있습니다.\r\n<br />\r\n\r\n### 기능1. The entry point\r\n\r\n![](https://images.velog.io/images/joyact/post/2afea557-9875-4a91-ac40-94117260cc6a/image.png)\r\n\r\nThe entry point는 Dependency Graph의 출발점이자 모듈 번들링을 시작하는 파일을 의미합니다. default 값은 `./src/index.js` 이며 직접 값을 지정하고 싶은경우 아래와 같이 configuration을 설정합니다.\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  entry: \"./app/index.js\",\r\n}\r\n```\r\n\r\n### 기능2. Loaders\r\n\r\n![image](https://images.velog.io/images/joyact/post/877e8797-5b3d-490e-9076-b428a968acf8/image.png)\r\n\r\nloader는 웹팩을 강력한 도구로 만들어주는 핵심 기능 중 하나입니다. 모듈에서 다루는 import, export 기능은 javascript와 json파일에만 국한되있는 것으로 css파일이나 image 파일을 다루게 되면 에러가 발생합니다. 하지만 loader를 사용하면 css, image 파일에도 접근이 가능하게 됩니다.\r\n\r\n1. 필요한 loader 설치\r\n\r\n   > **svg 파일 로더** : `npm install svg-inline-loader --save-dev` > **css 파일 로더** : `npm install style-loader css-loader --save-dev` > **js 파일 로더(es6->es5)** : `npm install babel-loader --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  rules: [\r\n    { test: /\\.svg$/, use: \"svg-inline-loader\" },\r\n    { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },\r\n    { test: /\\.(js)$/, use: \"babel-loader\" },\r\n  ],\r\n}\r\n```\r\n\r\n### 기능3. Output\r\n\r\nOutput은 번들링된 최종 파일 저장소를 뜻합니다. default 값으로 `dist/index.js` 가 설정이 되고 configuration 옵션에서 변경이 가능합니다.\r\n\r\n> **순서** : 모듈 번들링 ➡ dist 폴더 생성 ➡ dist 폴더 내부에 번들링된 최종 파일 저장\r\n> (생성된 파일 명은 옵션의 `filename`으로 지정)\r\n\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  output: {\r\n    path: path.resolve(__dirname, \"dist\"),\r\n    filename: \"index_bundle.js\",\r\n  },\r\n}\r\n```\r\n\r\n### 기능4. Plugin\r\n\r\nLoader가 각 모듈(파일)을 위한 기능이라면, Plugin은 최종 번들된 파일을 위한 기능을 수행합니다.\r\n\r\n- _**HtmlWebpackPlugin**_\r\n\r\n웹팩 번들링이 완료된 후 최종파일이 생성되면, 생성된 파일을 경로로 하는 `script` 태그가 추가된 index.html 파일을 만들어주는 플러그인입니다. 만약 output의 경로가 변경되더라도 직접 html을 수정할 필요없이 자동으로 script태그의 경로가 함께 업데이트 됩니다.\r\n\r\n1. 플러그인 설치\r\n   `npm install html-webpack-plugin --save-dev`\r\n\r\n2. webpack.config.js 옵션 추가\r\n\r\n```javascript\r\n  // webpack.config.js\r\n\tconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\t...\r\n\tmodule.exports = {\r\n    \tplugins: [\r\n          new HtmlWebpackPlugin()\r\n        ]\r\n    }\r\n```\r\n\r\n![image](https://images.velog.io/images/joyact/post/ebea04b9-b261-4f62-911d-79da4c2a7635/image.png)\r\n\r\n> REFERENCE <br /> Youtube uidotdev Webpack Crash Course https://youtu.be/lFjinlwpcHY / <br /> 네이버 블로그 https://blog.naver.com/wlsdml1103/221333814197\r\n"},{"excerpt":"🧐 모듈(Module) 이란? Javascript를 공부하다보면 이라는 단어를 자주 접하게 됩니다.\nModule이란 코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음을 말하는데\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\n Module 사용 전 기존에는 html에  태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사…","fields":{"slug":"/dev-module/"},"frontmatter":{"date":"November 21, 2021","title":"프론트엔드 개발환경 #2 - 모듈 (Module)","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## 🧐 모듈(Module) 이란?\r\n\r\nJavascript를 공부하다보면 `Module`이라는 단어를 자주 접하게 됩니다.\r\nModule이란 **코드를 내보낼 수 있는 파일 혹은 재사용 가능한 코드들의 묶음**을 말하는데\r\n이런 모듈이 모여서 하나의 프로그램이 완성된다고 볼 수 있습니다.\r\n<br />\r\n\r\n### Module 사용 전\r\n\r\n```html\r\n<script src=\"./src/main.js\">\r\n<script src=\"./src/animation.js\">\r\n<script src=\"./src/banner.js\">\r\n```\r\n\r\n기존에는 html에 `<script>` 태그를 이용해서 모든 파일을 하나하나 불러오는 방식을 사용했습니다. 이 방식은 파일을 불러오는 순서가 코드에 영향을 주며, 생성한 파일의 object가 모두 전역 변수가되서 문제가 발생할 수 있다는 단점이 있습니다\r\n<br />\r\n\r\n### Module 사용 후\r\n\r\n```html\r\n<script type=\"module\" src=\"./src/main.js\">\r\n```\r\n\r\n하지만 모듈을 사용하면 하나의 `<script>` 태그만으로 모든 모듈화된 javascript 파일에 접근이 가능해져 효율적으로 코드를 관리할 수 있습니다.\r\n\r\n---\r\n\r\n## ⛓️ 파일 모듈화 하기\r\n\r\nJavascript 파일을 모듈화 하는 방식은 크게 2가지로 나뉩니다. **CommonJS**로 모듈화 하는 것과 **ES Module**로 모듈화하는 것입니다.\r\n<br />\r\n\r\n### CommonJS로 파일 내보내기/불러오기\r\n\r\nCommonJS는 NodeJS의 기본 모듈 시스템이며 모듈화가 되지 않고 표준 라이브러리가 없는 과거 javascript의 문제를 해결하기 위한 모듈화 방식입니다.\r\n\r\n주 키워드 : `module.exports`, `exports`, `require`\r\n\r\n- 파일 불러오기 : `require`\r\n- 여러 개의 객체를 내보낼 경우, `exports` 변수의 속성으로 할당\r\n- 딱 하나의 객체를 내보낼 경우, `module.exports` 변수 자체에 할당\r\n\r\n```javascript\r\n// main.js\r\nconst name = \"Joy\"\r\nconst age = 28\r\n//exports.name = name\r\n//exports.age = age\r\nmodule.exports = { name, age }\r\n\r\n// result.js\r\nconst { name, age } = require(\"./main.js\")\r\n```\r\n\r\n### ES Module로 파일 내보내기/불러오기\r\n\r\nES Module은 가장 대중적으로 사용되는 모듈 시스템입니다. 비동기 방식으로 작동하고 모듈에서 실제로 쓰이는 부분만 불러오기 때문에 성능과 메모리 부분에서 유리한 측면이 있습니다. 또한 직관적인 키워드를 사용해 가독성이 뛰어나고 `Named Parameter`와 같은 CommonJS에서는 지원하지 않는 기능들이 있습니다.\r\n\r\n주 키워드 : `import`, `export`, `from`, `default`\r\n\r\n```javascript\r\n// main.js\r\nexport const name = \"Joy\"\r\nexport const age = 28\r\nexport default function fullName(lastName) {\r\n  return name + lastName\r\n}\r\n\r\n// result.js\r\nimport fullName, { name, age } from \"./main.js\"\r\n```\r\n"},{"excerpt":"✔ npm npm : Node Package Manager(Modules) npm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다. ex)   명령어를 사용해 초기  파일을 만들고 프로젝트…","fields":{"slug":"/dev-npm/"},"frontmatter":{"date":"November 17, 2021","title":"프론트엔드 개발환경 #1 - npm / npx / yarn","tags":["frontend","development"]},"rawMarkdownBody":"\r\n## ✔ npm\r\n\r\n> npm : Node Package Manager(Modules)\r\n\r\nnpm은 NodeJS를 설치하면 함께 설치되는 패키지 관리도구입니다. 이 패키지는 모듈이라고도 불리며 npm을 통해 서비스 개발에 필요한 webpack, CRA, react 등의 다양한 모듈 라이브러리를 설치할 수 있습니다.\r\n\r\nex) `npm install webpack`\r\n\r\n`npm init` 명령어를 사용해 초기 `package.json` 파일을 만들고 프로젝트를 초기화합니다. npm을 통해 다운된 패키지는 `package.json`에 기록됩니다.\r\n<br />\r\n\r\n### npm의 단점\r\n\r\n- 로컬 컴퓨터에 직접 설치되어 용량 차지가 크다\r\n- 다운받은 패키지의 새 버전이 나온 경우, 업데이트를 직접 해주어야한다.\r\n\r\n---\r\n\r\n## ✔ npx\r\n\r\n> npx : Node Package Runner\r\n\r\nnpx는 npm 5.2.0 버전부터 새로 도입된 패키지 관리 도구입니다. npm 5.2.0 버전 이상을 다운받았다면 자동으로 설치되며 이는 npm을 좀더 편리하게 사용할 수 있도록 도와줍니다.\r\n\r\nex) `npx install webpack`\r\n<br />\r\n\r\n### npx의 장점\r\n\r\n- 패키지를 컴퓨터에 직접 저장하지 않고 일회성으로 패키지를 사용해 용량차지를 하지 않는다.\r\n- 매번 최신 업데이트된 패키지를 사용할 수 있다.\r\n  <br />\r\n\r\n### npx 동작방법\r\n\r\n1. 기본적으로, 실행할 패키지가 실행 가능한 경로에 있는지 확인한다. (예를 들면, 프로젝트내에서 다운된 패키지가 있는지 확인)\r\n2. 만약에 있다면, 그것을 실행한다.\r\n3. 아니라면 패키지가 설치가 되지 않았다는 것으로 판단하여, npx가 가장 최신 버전의 패키지를 설치하고 실행한다.\r\n\r\n---\r\n\r\n## ✔ yarn\r\n\r\nyarn은 npm과 같은 패키지 매니저입니다. 차이점이 있다면 Node.js 설치시에 함께 설치되지 않고 별도의 명령어를 사용해 설치합니다. yarn을 사용하면 `yarn.lock` 이라는 파일에 다운한 패키지가 기록되며 이 파일은 모든 디바이스에 같은 패키지를 설치하는 것을 보장합니다.\r\n\r\nyarn 설치 : `npm install -g yarn`\r\n\r\n```bash\r\n# npm 사용법\r\nnpm install <package>\r\nnpm uninstall <package>\r\n\r\n# yarn 사용법\r\nyarn add <package>\r\nyarn remove <package>\r\n```\r\n\r\n### yarn의 장점\r\n\r\n- 속도나 안전성은 npm과 비슷하나 npm보다 보안이 뛰어나고 의존성 관리를 강조한다.\r\n- 버전을 어디에서나 같게 만들어 버전 충돌에 의한 버그가 적다.\r\n\r\n### yarn의 단점\r\n\r\n- npm에 비해 레퍼런스가 적고 덜 보편적이다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}